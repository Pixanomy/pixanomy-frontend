// @ts-nocheck

import { InContextSdkMethod } from '@graphql-mesh/types';
import { MeshContext } from '@graphql-mesh/runtime';

export namespace MainDbTypes {
  export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigInt: any;
  Datetime: any;
  Cursor: any;
  Date: any;
  BigFloat: any;
  JSON: any;
  Time: any;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `Account`. */
  allAccounts?: Maybe<AccountsConnection>;
  /** Reads a set of `Account`. */
  allAccountsList?: Maybe<Array<Account>>;
  /** Reads and enables pagination through a set of `Agreement`. */
  allAgreements?: Maybe<AgreementsConnection>;
  /** Reads a set of `Agreement`. */
  allAgreementsList?: Maybe<Array<Agreement>>;
  /** Reads and enables pagination through a set of `Analytic`. */
  allAnalytics?: Maybe<AnalyticsConnection>;
  /** Reads a set of `Analytic`. */
  allAnalyticsList?: Maybe<Array<Analytic>>;
  /** Reads and enables pagination through a set of `Apitoken`. */
  allApitokens?: Maybe<ApitokensConnection>;
  /** Reads a set of `Apitoken`. */
  allApitokensList?: Maybe<Array<Apitoken>>;
  /** Reads and enables pagination through a set of `Article`. */
  allArticles?: Maybe<ArticlesConnection>;
  /** Reads a set of `Article`. */
  allArticlesList?: Maybe<Array<Article>>;
  /** Reads and enables pagination through a set of `Attribute`. */
  allAttributes?: Maybe<AttributesConnection>;
  /** Reads a set of `Attribute`. */
  allAttributesList?: Maybe<Array<Attribute>>;
  /** Reads and enables pagination through a set of `Brand`. */
  allBrands?: Maybe<BrandsConnection>;
  /** Reads a set of `Brand`. */
  allBrandsList?: Maybe<Array<Brand>>;
  /** Reads and enables pagination through a set of `CartPriceRule`. */
  allCartPriceRules?: Maybe<CartPriceRulesConnection>;
  /** Reads a set of `CartPriceRule`. */
  allCartPriceRulesList?: Maybe<Array<CartPriceRule>>;
  /** Reads and enables pagination through a set of `Case`. */
  allCases?: Maybe<CasesConnection>;
  /** Reads a set of `Case`. */
  allCasesList?: Maybe<Array<Case>>;
  /** Reads and enables pagination through a set of `CatalogPriceRule`. */
  allCatalogPriceRules?: Maybe<CatalogPriceRulesConnection>;
  /** Reads a set of `CatalogPriceRule`. */
  allCatalogPriceRulesList?: Maybe<Array<CatalogPriceRule>>;
  /** Reads and enables pagination through a set of `Category`. */
  allCategories?: Maybe<CategoriesConnection>;
  /** Reads a set of `Category`. */
  allCategoriesList?: Maybe<Array<Category>>;
  /** Reads and enables pagination through a set of `Channel`. */
  allChannels?: Maybe<ChannelsConnection>;
  /** Reads a set of `Channel`. */
  allChannelsList?: Maybe<Array<Channel>>;
  /** Reads and enables pagination through a set of `Checklist`. */
  allChecklists?: Maybe<ChecklistsConnection>;
  /** Reads a set of `Checklist`. */
  allChecklistsList?: Maybe<Array<Checklist>>;
  /** Reads and enables pagination through a set of `City`. */
  allCities?: Maybe<CitiesConnection>;
  /** Reads a set of `City`. */
  allCitiesList?: Maybe<Array<City>>;
  /** Reads and enables pagination through a set of `Collection`. */
  allCollections?: Maybe<CollectionsConnection>;
  /** Reads a set of `Collection`. */
  allCollectionsList?: Maybe<Array<Collection>>;
  /** Reads and enables pagination through a set of `Comment`. */
  allComments?: Maybe<CommentsConnection>;
  /** Reads a set of `Comment`. */
  allCommentsList?: Maybe<Array<Comment>>;
  /** Reads and enables pagination through a set of `ContentType`. */
  allContentTypes?: Maybe<ContentTypesConnection>;
  /** Reads a set of `ContentType`. */
  allContentTypesList?: Maybe<Array<ContentType>>;
  /** Reads and enables pagination through a set of `Contract`. */
  allContracts?: Maybe<ContractsConnection>;
  /** Reads a set of `Contract`. */
  allContractsList?: Maybe<Array<Contract>>;
  /** Reads and enables pagination through a set of `Country`. */
  allCountries?: Maybe<CountriesConnection>;
  /** Reads a set of `Country`. */
  allCountriesList?: Maybe<Array<Country>>;
  /** Reads and enables pagination through a set of `Coupon`. */
  allCoupons?: Maybe<CouponsConnection>;
  /** Reads a set of `Coupon`. */
  allCouponsList?: Maybe<Array<Coupon>>;
  /** Reads and enables pagination through a set of `CreditMemo`. */
  allCreditMemos?: Maybe<CreditMemosConnection>;
  /** Reads a set of `CreditMemo`. */
  allCreditMemosList?: Maybe<Array<CreditMemo>>;
  /** Reads and enables pagination through a set of `Currency`. */
  allCurrencies?: Maybe<CurrenciesConnection>;
  /** Reads a set of `Currency`. */
  allCurrenciesList?: Maybe<Array<Currency>>;
  /** Reads and enables pagination through a set of `CurrencyRate`. */
  allCurrencyRates?: Maybe<CurrencyRatesConnection>;
  /** Reads a set of `CurrencyRate`. */
  allCurrencyRatesList?: Maybe<Array<CurrencyRate>>;
  /** Reads and enables pagination through a set of `CurrencySymbol`. */
  allCurrencySymbols?: Maybe<CurrencySymbolsConnection>;
  /** Reads a set of `CurrencySymbol`. */
  allCurrencySymbolsList?: Maybe<Array<CurrencySymbol>>;
  /** Reads and enables pagination through a set of `CustomerGroup`. */
  allCustomerGroups?: Maybe<CustomerGroupsConnection>;
  /** Reads a set of `CustomerGroup`. */
  allCustomerGroupsList?: Maybe<Array<CustomerGroup>>;
  /** Reads and enables pagination through a set of `Customer`. */
  allCustomers?: Maybe<CustomersConnection>;
  /** Reads a set of `Customer`. */
  allCustomersList?: Maybe<Array<Customer>>;
  /** Reads and enables pagination through a set of `Customization`. */
  allCustomizations?: Maybe<CustomizationsConnection>;
  /** Reads a set of `Customization`. */
  allCustomizationsList?: Maybe<Array<Customization>>;
  /** Reads and enables pagination through a set of `Dashboard`. */
  allDashboards?: Maybe<DashboardsConnection>;
  /** Reads a set of `Dashboard`. */
  allDashboardsList?: Maybe<Array<Dashboard>>;
  /** Reads and enables pagination through a set of `Deepdive`. */
  allDeepdives?: Maybe<DeepdivesConnection>;
  /** Reads a set of `Deepdive`. */
  allDeepdivesList?: Maybe<Array<Deepdive>>;
  /** Reads and enables pagination through a set of `Digiboard`. */
  allDigiboards?: Maybe<DigiboardsConnection>;
  /** Reads a set of `Digiboard`. */
  allDigiboardsList?: Maybe<Array<Digiboard>>;
  /** Reads and enables pagination through a set of `Email`. */
  allEmails?: Maybe<EmailsConnection>;
  /** Reads a set of `Email`. */
  allEmailsList?: Maybe<Array<Email>>;
  /** Reads and enables pagination through a set of `Endofshift`. */
  allEndofshifts?: Maybe<EndofshiftsConnection>;
  /** Reads a set of `Endofshift`. */
  allEndofshiftsList?: Maybe<Array<Endofshift>>;
  /** Reads and enables pagination through a set of `Event`. */
  allEvents?: Maybe<EventsConnection>;
  /** Reads a set of `Event`. */
  allEventsList?: Maybe<Array<Event>>;
  /** Reads and enables pagination through a set of `Fullfillment`. */
  allFullfillments?: Maybe<FullfillmentsConnection>;
  /** Reads a set of `Fullfillment`. */
  allFullfillmentsList?: Maybe<Array<Fullfillment>>;
  /** Reads and enables pagination through a set of `GiftCertificate`. */
  allGiftCertificates?: Maybe<GiftCertificatesConnection>;
  /** Reads a set of `GiftCertificate`. */
  allGiftCertificatesList?: Maybe<Array<GiftCertificate>>;
  /** Reads and enables pagination through a set of `Glossary`. */
  allGlossaries?: Maybe<GlossariesConnection>;
  /** Reads a set of `Glossary`. */
  allGlossariesList?: Maybe<Array<Glossary>>;
  /** Reads and enables pagination through a set of `Importm`. */
  allImportms?: Maybe<ImportmsConnection>;
  /** Reads a set of `Importm`. */
  allImportmsList?: Maybe<Array<Importm>>;
  /** Reads and enables pagination through a set of `Integration`. */
  allIntegrations?: Maybe<IntegrationsConnection>;
  /** Reads a set of `Integration`. */
  allIntegrationsList?: Maybe<Array<Integration>>;
  /** Reads and enables pagination through a set of `Internalization`. */
  allInternalizations?: Maybe<InternalizationsConnection>;
  /** Reads a set of `Internalization`. */
  allInternalizationsList?: Maybe<Array<Internalization>>;
  /** Reads and enables pagination through a set of `Invitation`. */
  allInvitations?: Maybe<InvitationsConnection>;
  /** Reads a set of `Invitation`. */
  allInvitationsList?: Maybe<Array<Invitation>>;
  /** Reads and enables pagination through a set of `Invoice`. */
  allInvoices?: Maybe<InvoicesConnection>;
  /** Reads a set of `Invoice`. */
  allInvoicesList?: Maybe<Array<Invoice>>;
  /** Reads and enables pagination through a set of `Lead`. */
  allLeads?: Maybe<LeadsConnection>;
  /** Reads a set of `Lead`. */
  allLeadsList?: Maybe<Array<Lead>>;
  /** Reads and enables pagination through a set of `Manufacturer`. */
  allManufacturers?: Maybe<ManufacturersConnection>;
  /** Reads a set of `Manufacturer`. */
  allManufacturersList?: Maybe<Array<Manufacturer>>;
  /** Reads and enables pagination through a set of `Mediamanager`. */
  allMediamanagers?: Maybe<MediamanagersConnection>;
  /** Reads a set of `Mediamanager`. */
  allMediamanagersList?: Maybe<Array<Mediamanager>>;
  /** Reads and enables pagination through a set of `Meeting`. */
  allMeetings?: Maybe<MeetingsConnection>;
  /** Reads a set of `Meeting`. */
  allMeetingsList?: Maybe<Array<Meeting>>;
  /** Reads and enables pagination through a set of `Message`. */
  allMessages?: Maybe<MessagesConnection>;
  /** Reads a set of `Message`. */
  allMessagesList?: Maybe<Array<Message>>;
  /** Reads and enables pagination through a set of `Newsletter`. */
  allNewsletters?: Maybe<NewslettersConnection>;
  /** Reads a set of `Newsletter`. */
  allNewslettersList?: Maybe<Array<Newsletter>>;
  /** Reads and enables pagination through a set of `Ooto`. */
  allOotos?: Maybe<OotosConnection>;
  /** Reads a set of `Ooto`. */
  allOotosList?: Maybe<Array<Ooto>>;
  /** Reads and enables pagination through a set of `Opportunity`. */
  allOpportunities?: Maybe<OpportunitiesConnection>;
  /** Reads a set of `Opportunity`. */
  allOpportunitiesList?: Maybe<Array<Opportunity>>;
  /** Reads and enables pagination through a set of `Order`. */
  allOrders?: Maybe<OrdersConnection>;
  /** Reads a set of `Order`. */
  allOrdersList?: Maybe<Array<Order>>;
  /** Reads and enables pagination through a set of `Page`. */
  allPages?: Maybe<PagesConnection>;
  /** Reads a set of `Page`. */
  allPagesList?: Maybe<Array<Page>>;
  /** Reads and enables pagination through a set of `Partner`. */
  allPartners?: Maybe<PartnersConnection>;
  /** Reads a set of `Partner`. */
  allPartnersList?: Maybe<Array<Partner>>;
  /** Reads and enables pagination through a set of `Payment`. */
  allPayments?: Maybe<PaymentsConnection>;
  /** Reads a set of `Payment`. */
  allPaymentsList?: Maybe<Array<Payment>>;
  /** Reads and enables pagination through a set of `Permission`. */
  allPermissions?: Maybe<PermissionsConnection>;
  /** Reads a set of `Permission`. */
  allPermissionsList?: Maybe<Array<Permission>>;
  /** Reads and enables pagination through a set of `Plugin`. */
  allPlugins?: Maybe<PluginsConnection>;
  /** Reads a set of `Plugin`. */
  allPluginsList?: Maybe<Array<Plugin>>;
  /** Reads and enables pagination through a set of `Poll`. */
  allPolls?: Maybe<PollsConnection>;
  /** Reads a set of `Poll`. */
  allPollsList?: Maybe<Array<Poll>>;
  /** Reads and enables pagination through a set of `ProductType`. */
  allProductTypes?: Maybe<ProductTypesConnection>;
  /** Reads a set of `ProductType`. */
  allProductTypesList?: Maybe<Array<ProductType>>;
  /** Reads and enables pagination through a set of `Product`. */
  allProducts?: Maybe<ProductsConnection>;
  /** Reads a set of `Product`. */
  allProductsList?: Maybe<Array<Product>>;
  /** Reads and enables pagination through a set of `Project`. */
  allProjects?: Maybe<ProjectsConnection>;
  /** Reads a set of `Project`. */
  allProjectsList?: Maybe<Array<Project>>;
  /** Reads and enables pagination through a set of `Provider`. */
  allProviders?: Maybe<ProvidersConnection>;
  /** Reads a set of `Provider`. */
  allProvidersList?: Maybe<Array<Provider>>;
  /** Reads and enables pagination through a set of `Quote`. */
  allQuotes?: Maybe<QuotesConnection>;
  /** Reads a set of `Quote`. */
  allQuotesList?: Maybe<Array<Quote>>;
  /** Reads and enables pagination through a set of `Rating`. */
  allRatings?: Maybe<RatingsConnection>;
  /** Reads a set of `Rating`. */
  allRatingsList?: Maybe<Array<Rating>>;
  /** Reads and enables pagination through a set of `Report`. */
  allReports?: Maybe<ReportsConnection>;
  /** Reads a set of `Report`. */
  allReportsList?: Maybe<Array<Report>>;
  /** Reads and enables pagination through a set of `Return`. */
  allReturns?: Maybe<ReturnsConnection>;
  /** Reads a set of `Return`. */
  allReturnsList?: Maybe<Array<Return>>;
  /** Reads and enables pagination through a set of `Review`. */
  allReviews?: Maybe<ReviewsConnection>;
  /** Reads a set of `Review`. */
  allReviewsList?: Maybe<Array<Review>>;
  /** Reads and enables pagination through a set of `Reward`. */
  allRewards?: Maybe<RewardsConnection>;
  /** Reads a set of `Reward`. */
  allRewardsList?: Maybe<Array<Reward>>;
  /** Reads and enables pagination through a set of `Role`. */
  allRoles?: Maybe<RolesConnection>;
  /** Reads a set of `Role`. */
  allRolesList?: Maybe<Array<Role>>;
  /** Reads and enables pagination through a set of `Scheduler`. */
  allSchedulers?: Maybe<SchedulersConnection>;
  /** Reads a set of `Scheduler`. */
  allSchedulersList?: Maybe<Array<Scheduler>>;
  /** Reads and enables pagination through a set of `Segment`. */
  allSegments?: Maybe<SegmentsConnection>;
  /** Reads a set of `Segment`. */
  allSegmentsList?: Maybe<Array<Segment>>;
  /** Reads and enables pagination through a set of `Setting`. */
  allSettings?: Maybe<SettingsConnection>;
  /** Reads a set of `Setting`. */
  allSettingsList?: Maybe<Array<Setting>>;
  /** Reads and enables pagination through a set of `Shipment`. */
  allShipments?: Maybe<ShipmentsConnection>;
  /** Reads a set of `Shipment`. */
  allShipmentsList?: Maybe<Array<Shipment>>;
  /** Reads and enables pagination through a set of `SpecialDiscount`. */
  allSpecialDiscounts?: Maybe<SpecialDiscountsConnection>;
  /** Reads a set of `SpecialDiscount`. */
  allSpecialDiscountsList?: Maybe<Array<SpecialDiscount>>;
  /** Reads and enables pagination through a set of `State`. */
  allStates?: Maybe<StatesConnection>;
  /** Reads a set of `State`. */
  allStatesList?: Maybe<Array<State>>;
  /** Reads and enables pagination through a set of `Statistic`. */
  allStatistics?: Maybe<StatisticsConnection>;
  /** Reads a set of `Statistic`. */
  allStatisticsList?: Maybe<Array<Statistic>>;
  /** Reads and enables pagination through a set of `Stock`. */
  allStocks?: Maybe<StocksConnection>;
  /** Reads a set of `Stock`. */
  allStocksList?: Maybe<Array<Stock>>;
  /** Reads and enables pagination through a set of `Survey`. */
  allSurveys?: Maybe<SurveysConnection>;
  /** Reads a set of `Survey`. */
  allSurveysList?: Maybe<Array<Survey>>;
  /** Reads and enables pagination through a set of `Tag`. */
  allTags?: Maybe<TagsConnection>;
  /** Reads a set of `Tag`. */
  allTagsList?: Maybe<Array<Tag>>;
  /** Reads and enables pagination through a set of `Target`. */
  allTargets?: Maybe<TargetsConnection>;
  /** Reads a set of `Target`. */
  allTargetsList?: Maybe<Array<Target>>;
  /** Reads and enables pagination through a set of `TaxCategory`. */
  allTaxCategories?: Maybe<TaxCategoriesConnection>;
  /** Reads a set of `TaxCategory`. */
  allTaxCategoriesList?: Maybe<Array<TaxCategory>>;
  /** Reads and enables pagination through a set of `TaxRate`. */
  allTaxRates?: Maybe<TaxRatesConnection>;
  /** Reads a set of `TaxRate`. */
  allTaxRatesList?: Maybe<Array<TaxRate>>;
  /** Reads and enables pagination through a set of `TaxRule`. */
  allTaxRules?: Maybe<TaxRulesConnection>;
  /** Reads a set of `TaxRule`. */
  allTaxRulesList?: Maybe<Array<TaxRule>>;
  /** Reads and enables pagination through a set of `Template`. */
  allTemplates?: Maybe<TemplatesConnection>;
  /** Reads a set of `Template`. */
  allTemplatesList?: Maybe<Array<Template>>;
  /** Reads and enables pagination through a set of `Theme`. */
  allThemes?: Maybe<ThemesConnection>;
  /** Reads a set of `Theme`. */
  allThemesList?: Maybe<Array<Theme>>;
  /** Reads and enables pagination through a set of `Ticketing`. */
  allTicketings?: Maybe<TicketingsConnection>;
  /** Reads a set of `Ticketing`. */
  allTicketingsList?: Maybe<Array<Ticketing>>;
  /** Reads and enables pagination through a set of `Training`. */
  allTrainings?: Maybe<TrainingsConnection>;
  /** Reads a set of `Training`. */
  allTrainingsList?: Maybe<Array<Training>>;
  /** Reads and enables pagination through a set of `Transaction`. */
  allTransactions?: Maybe<TransactionsConnection>;
  /** Reads a set of `Transaction`. */
  allTransactionsList?: Maybe<Array<Transaction>>;
  /** Reads and enables pagination through a set of `UploadFile`. */
  allUploadFiles?: Maybe<UploadFilesConnection>;
  /** Reads a set of `UploadFile`. */
  allUploadFilesList?: Maybe<Array<UploadFile>>;
  /** Reads and enables pagination through a set of `User`. */
  allUsers?: Maybe<UsersConnection>;
  /** Reads a set of `User`. */
  allUsersList?: Maybe<Array<User>>;
  /** Reads and enables pagination through a set of `Vendor`. */
  allVendors?: Maybe<VendorsConnection>;
  /** Reads a set of `Vendor`. */
  allVendorsList?: Maybe<Array<Vendor>>;
  /** Reads and enables pagination through a set of `Visit`. */
  allVisits?: Maybe<VisitsConnection>;
  /** Reads a set of `Visit`. */
  allVisitsList?: Maybe<Array<Visit>>;
  /** Reads and enables pagination through a set of `Warehouse`. */
  allWarehouses?: Maybe<WarehousesConnection>;
  /** Reads a set of `Warehouse`. */
  allWarehousesList?: Maybe<Array<Warehouse>>;
  /** Reads and enables pagination through a set of `Webhook`. */
  allWebhooks?: Maybe<WebhooksConnection>;
  /** Reads a set of `Webhook`. */
  allWebhooksList?: Maybe<Array<Webhook>>;
  /** Reads and enables pagination through a set of `Website`. */
  allWebsites?: Maybe<WebsitesConnection>;
  /** Reads a set of `Website`. */
  allWebsitesList?: Maybe<Array<Website>>;
  /** Reads and enables pagination through a set of `Wishlist`. */
  allWishlists?: Maybe<WishlistsConnection>;
  /** Reads a set of `Wishlist`. */
  allWishlistsList?: Maybe<Array<Wishlist>>;
  /** Reads and enables pagination through a set of `Workspace`. */
  allWorkspaces?: Maybe<WorkspacesConnection>;
  /** Reads a set of `Workspace`. */
  allWorkspacesList?: Maybe<Array<Workspace>>;
  /** Reads and enables pagination through a set of `Zone`. */
  allZones?: Maybe<ZonesConnection>;
  /** Reads a set of `Zone`. */
  allZonesList?: Maybe<Array<Zone>>;
  accountById?: Maybe<Account>;
  agreementById?: Maybe<Agreement>;
  analyticById?: Maybe<Analytic>;
  apitokenById?: Maybe<Apitoken>;
  articleById?: Maybe<Article>;
  attributeById?: Maybe<Attribute>;
  brandById?: Maybe<Brand>;
  cartPriceRuleById?: Maybe<CartPriceRule>;
  caseById?: Maybe<Case>;
  catalogPriceRuleById?: Maybe<CatalogPriceRule>;
  categoryById?: Maybe<Category>;
  channelById?: Maybe<Channel>;
  checklistById?: Maybe<Checklist>;
  cityById?: Maybe<City>;
  collectionById?: Maybe<Collection>;
  commentById?: Maybe<Comment>;
  contentTypeById?: Maybe<ContentType>;
  contractById?: Maybe<Contract>;
  countryById?: Maybe<Country>;
  couponById?: Maybe<Coupon>;
  creditMemoByCreditMemoAndId?: Maybe<CreditMemo>;
  currencyById?: Maybe<Currency>;
  currencyRateByImportService?: Maybe<CurrencyRate>;
  currencySymbolBySymbol?: Maybe<CurrencySymbol>;
  customerGroupById?: Maybe<CustomerGroup>;
  customerById?: Maybe<Customer>;
  customizationById?: Maybe<Customization>;
  dashboardById?: Maybe<Dashboard>;
  deepdiveById?: Maybe<Deepdive>;
  digiboardById?: Maybe<Digiboard>;
  emailById?: Maybe<Email>;
  endofshiftById?: Maybe<Endofshift>;
  eventById?: Maybe<Event>;
  fullfillmentById?: Maybe<Fullfillment>;
  giftCertificateById?: Maybe<GiftCertificate>;
  glossaryById?: Maybe<Glossary>;
  importmById?: Maybe<Importm>;
  integrationById?: Maybe<Integration>;
  internalizationById?: Maybe<Internalization>;
  invitationById?: Maybe<Invitation>;
  invoiceById?: Maybe<Invoice>;
  leadById?: Maybe<Lead>;
  manufacturerById?: Maybe<Manufacturer>;
  mediamanagerById?: Maybe<Mediamanager>;
  meetingById?: Maybe<Meeting>;
  messageById?: Maybe<Message>;
  newsletterById?: Maybe<Newsletter>;
  ootoById?: Maybe<Ooto>;
  opportunityById?: Maybe<Opportunity>;
  orderById?: Maybe<Order>;
  pageById?: Maybe<Page>;
  partnerById?: Maybe<Partner>;
  paymentById?: Maybe<Payment>;
  permissionById?: Maybe<Permission>;
  pluginById?: Maybe<Plugin>;
  pollById?: Maybe<Poll>;
  productTypeById?: Maybe<ProductType>;
  productById?: Maybe<Product>;
  projectById?: Maybe<Project>;
  providerById?: Maybe<Provider>;
  quoteById?: Maybe<Quote>;
  ratingById?: Maybe<Rating>;
  reportById?: Maybe<Report>;
  returnById?: Maybe<Return>;
  reviewById?: Maybe<Review>;
  rewardById?: Maybe<Reward>;
  roleById?: Maybe<Role>;
  schedulerById?: Maybe<Scheduler>;
  segmentById?: Maybe<Segment>;
  settingById?: Maybe<Setting>;
  shipmentById?: Maybe<Shipment>;
  specialDiscountById?: Maybe<SpecialDiscount>;
  stateById?: Maybe<State>;
  statisticById?: Maybe<Statistic>;
  stockById?: Maybe<Stock>;
  surveyById?: Maybe<Survey>;
  tagById?: Maybe<Tag>;
  targetById?: Maybe<Target>;
  taxCategoryById?: Maybe<TaxCategory>;
  taxRateById?: Maybe<TaxRate>;
  taxRuleById?: Maybe<TaxRule>;
  templateById?: Maybe<Template>;
  themeById?: Maybe<Theme>;
  ticketingById?: Maybe<Ticketing>;
  trainingById?: Maybe<Training>;
  transactionById?: Maybe<Transaction>;
  uploadFileById?: Maybe<UploadFile>;
  userById?: Maybe<User>;
  vendorById?: Maybe<Vendor>;
  visitById?: Maybe<Visit>;
  warehouseById?: Maybe<Warehouse>;
  webhookById?: Maybe<Webhook>;
  websiteById?: Maybe<Website>;
  wishlistById?: Maybe<Wishlist>;
  workspaceById?: Maybe<Workspace>;
  zoneById?: Maybe<Zone>;
  /** Reads a single `Account` using its globally unique `ID`. */
  account?: Maybe<Account>;
  /** Reads a single `Agreement` using its globally unique `ID`. */
  agreement?: Maybe<Agreement>;
  /** Reads a single `Analytic` using its globally unique `ID`. */
  analytic?: Maybe<Analytic>;
  /** Reads a single `Apitoken` using its globally unique `ID`. */
  apitoken?: Maybe<Apitoken>;
  /** Reads a single `Article` using its globally unique `ID`. */
  article?: Maybe<Article>;
  /** Reads a single `Attribute` using its globally unique `ID`. */
  attribute?: Maybe<Attribute>;
  /** Reads a single `Brand` using its globally unique `ID`. */
  brand?: Maybe<Brand>;
  /** Reads a single `CartPriceRule` using its globally unique `ID`. */
  cartPriceRule?: Maybe<CartPriceRule>;
  /** Reads a single `Case` using its globally unique `ID`. */
  case?: Maybe<Case>;
  /** Reads a single `CatalogPriceRule` using its globally unique `ID`. */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  /** Reads a single `Category` using its globally unique `ID`. */
  category?: Maybe<Category>;
  /** Reads a single `Channel` using its globally unique `ID`. */
  channel?: Maybe<Channel>;
  /** Reads a single `Checklist` using its globally unique `ID`. */
  checklist?: Maybe<Checklist>;
  /** Reads a single `City` using its globally unique `ID`. */
  city?: Maybe<City>;
  /** Reads a single `Collection` using its globally unique `ID`. */
  collection?: Maybe<Collection>;
  /** Reads a single `Comment` using its globally unique `ID`. */
  comment?: Maybe<Comment>;
  /** Reads a single `ContentType` using its globally unique `ID`. */
  contentType?: Maybe<ContentType>;
  /** Reads a single `Contract` using its globally unique `ID`. */
  contract?: Maybe<Contract>;
  /** Reads a single `Country` using its globally unique `ID`. */
  country?: Maybe<Country>;
  /** Reads a single `Coupon` using its globally unique `ID`. */
  coupon?: Maybe<Coupon>;
  /** Reads a single `CreditMemo` using its globally unique `ID`. */
  creditMemo?: Maybe<CreditMemo>;
  /** Reads a single `Currency` using its globally unique `ID`. */
  currency?: Maybe<Currency>;
  /** Reads a single `CurrencyRate` using its globally unique `ID`. */
  currencyRate?: Maybe<CurrencyRate>;
  /** Reads a single `CurrencySymbol` using its globally unique `ID`. */
  currencySymbol?: Maybe<CurrencySymbol>;
  /** Reads a single `CustomerGroup` using its globally unique `ID`. */
  customerGroup?: Maybe<CustomerGroup>;
  /** Reads a single `Customer` using its globally unique `ID`. */
  customer?: Maybe<Customer>;
  /** Reads a single `Customization` using its globally unique `ID`. */
  customization?: Maybe<Customization>;
  /** Reads a single `Dashboard` using its globally unique `ID`. */
  dashboard?: Maybe<Dashboard>;
  /** Reads a single `Deepdive` using its globally unique `ID`. */
  deepdive?: Maybe<Deepdive>;
  /** Reads a single `Digiboard` using its globally unique `ID`. */
  digiboard?: Maybe<Digiboard>;
  /** Reads a single `Email` using its globally unique `ID`. */
  email?: Maybe<Email>;
  /** Reads a single `Endofshift` using its globally unique `ID`. */
  endofshift?: Maybe<Endofshift>;
  /** Reads a single `Event` using its globally unique `ID`. */
  event?: Maybe<Event>;
  /** Reads a single `Fullfillment` using its globally unique `ID`. */
  fullfillment?: Maybe<Fullfillment>;
  /** Reads a single `GiftCertificate` using its globally unique `ID`. */
  giftCertificate?: Maybe<GiftCertificate>;
  /** Reads a single `Glossary` using its globally unique `ID`. */
  glossary?: Maybe<Glossary>;
  /** Reads a single `Importm` using its globally unique `ID`. */
  importm?: Maybe<Importm>;
  /** Reads a single `Integration` using its globally unique `ID`. */
  integration?: Maybe<Integration>;
  /** Reads a single `Internalization` using its globally unique `ID`. */
  internalization?: Maybe<Internalization>;
  /** Reads a single `Invitation` using its globally unique `ID`. */
  invitation?: Maybe<Invitation>;
  /** Reads a single `Invoice` using its globally unique `ID`. */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Lead` using its globally unique `ID`. */
  lead?: Maybe<Lead>;
  /** Reads a single `Manufacturer` using its globally unique `ID`. */
  manufacturer?: Maybe<Manufacturer>;
  /** Reads a single `Mediamanager` using its globally unique `ID`. */
  mediamanager?: Maybe<Mediamanager>;
  /** Reads a single `Meeting` using its globally unique `ID`. */
  meeting?: Maybe<Meeting>;
  /** Reads a single `Message` using its globally unique `ID`. */
  message?: Maybe<Message>;
  /** Reads a single `Newsletter` using its globally unique `ID`. */
  newsletter?: Maybe<Newsletter>;
  /** Reads a single `Ooto` using its globally unique `ID`. */
  ooto?: Maybe<Ooto>;
  /** Reads a single `Opportunity` using its globally unique `ID`. */
  opportunity?: Maybe<Opportunity>;
  /** Reads a single `Order` using its globally unique `ID`. */
  order?: Maybe<Order>;
  /** Reads a single `Page` using its globally unique `ID`. */
  page?: Maybe<Page>;
  /** Reads a single `Partner` using its globally unique `ID`. */
  partner?: Maybe<Partner>;
  /** Reads a single `Payment` using its globally unique `ID`. */
  payment?: Maybe<Payment>;
  /** Reads a single `Permission` using its globally unique `ID`. */
  permission?: Maybe<Permission>;
  /** Reads a single `Plugin` using its globally unique `ID`. */
  plugin?: Maybe<Plugin>;
  /** Reads a single `Poll` using its globally unique `ID`. */
  poll?: Maybe<Poll>;
  /** Reads a single `ProductType` using its globally unique `ID`. */
  productType?: Maybe<ProductType>;
  /** Reads a single `Product` using its globally unique `ID`. */
  product?: Maybe<Product>;
  /** Reads a single `Project` using its globally unique `ID`. */
  project?: Maybe<Project>;
  /** Reads a single `Provider` using its globally unique `ID`. */
  provider?: Maybe<Provider>;
  /** Reads a single `Quote` using its globally unique `ID`. */
  quote?: Maybe<Quote>;
  /** Reads a single `Rating` using its globally unique `ID`. */
  rating?: Maybe<Rating>;
  /** Reads a single `Report` using its globally unique `ID`. */
  report?: Maybe<Report>;
  /** Reads a single `Return` using its globally unique `ID`. */
  return?: Maybe<Return>;
  /** Reads a single `Review` using its globally unique `ID`. */
  review?: Maybe<Review>;
  /** Reads a single `Reward` using its globally unique `ID`. */
  reward?: Maybe<Reward>;
  /** Reads a single `Role` using its globally unique `ID`. */
  role?: Maybe<Role>;
  /** Reads a single `Scheduler` using its globally unique `ID`. */
  scheduler?: Maybe<Scheduler>;
  /** Reads a single `Segment` using its globally unique `ID`. */
  segment?: Maybe<Segment>;
  /** Reads a single `Setting` using its globally unique `ID`. */
  setting?: Maybe<Setting>;
  /** Reads a single `Shipment` using its globally unique `ID`. */
  shipment?: Maybe<Shipment>;
  /** Reads a single `SpecialDiscount` using its globally unique `ID`. */
  specialDiscount?: Maybe<SpecialDiscount>;
  /** Reads a single `State` using its globally unique `ID`. */
  state?: Maybe<State>;
  /** Reads a single `Statistic` using its globally unique `ID`. */
  statistic?: Maybe<Statistic>;
  /** Reads a single `Stock` using its globally unique `ID`. */
  stock?: Maybe<Stock>;
  /** Reads a single `Survey` using its globally unique `ID`. */
  survey?: Maybe<Survey>;
  /** Reads a single `Tag` using its globally unique `ID`. */
  tag?: Maybe<Tag>;
  /** Reads a single `Target` using its globally unique `ID`. */
  target?: Maybe<Target>;
  /** Reads a single `TaxCategory` using its globally unique `ID`. */
  taxCategory?: Maybe<TaxCategory>;
  /** Reads a single `TaxRate` using its globally unique `ID`. */
  taxRate?: Maybe<TaxRate>;
  /** Reads a single `TaxRule` using its globally unique `ID`. */
  taxRule?: Maybe<TaxRule>;
  /** Reads a single `Template` using its globally unique `ID`. */
  template?: Maybe<Template>;
  /** Reads a single `Theme` using its globally unique `ID`. */
  theme?: Maybe<Theme>;
  /** Reads a single `Ticketing` using its globally unique `ID`. */
  ticketing?: Maybe<Ticketing>;
  /** Reads a single `Training` using its globally unique `ID`. */
  training?: Maybe<Training>;
  /** Reads a single `Transaction` using its globally unique `ID`. */
  transaction?: Maybe<Transaction>;
  /** Reads a single `UploadFile` using its globally unique `ID`. */
  uploadFile?: Maybe<UploadFile>;
  /** Reads a single `User` using its globally unique `ID`. */
  user?: Maybe<User>;
  /** Reads a single `Vendor` using its globally unique `ID`. */
  vendor?: Maybe<Vendor>;
  /** Reads a single `Visit` using its globally unique `ID`. */
  visit?: Maybe<Visit>;
  /** Reads a single `Warehouse` using its globally unique `ID`. */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `Webhook` using its globally unique `ID`. */
  webhook?: Maybe<Webhook>;
  /** Reads a single `Website` using its globally unique `ID`. */
  website?: Maybe<Website>;
  /** Reads a single `Wishlist` using its globally unique `ID`. */
  wishlist?: Maybe<Wishlist>;
  /** Reads a single `Workspace` using its globally unique `ID`. */
  workspace?: Maybe<Workspace>;
  /** Reads a single `Zone` using its globally unique `ID`. */
  zone?: Maybe<Zone>;
};


/** The root query type which gives access points into the data universe. */
export type QuerynodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryallAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  condition?: InputMaybe<AccountCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAccountsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  condition?: InputMaybe<AccountCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAgreementsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
  condition?: InputMaybe<AgreementCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAgreementsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
  condition?: InputMaybe<AgreementCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAnalyticsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
  condition?: InputMaybe<AnalyticCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAnalyticsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
  condition?: InputMaybe<AnalyticCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallApitokensArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
  condition?: InputMaybe<ApitokenCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallApitokensListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
  condition?: InputMaybe<ApitokenCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallArticlesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
  condition?: InputMaybe<ArticleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallArticlesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
  condition?: InputMaybe<ArticleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAttributesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
  condition?: InputMaybe<AttributeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallAttributesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
  condition?: InputMaybe<AttributeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallBrandsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
  condition?: InputMaybe<BrandCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallBrandsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
  condition?: InputMaybe<BrandCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCartPriceRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
  condition?: InputMaybe<CartPriceRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCartPriceRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
  condition?: InputMaybe<CartPriceRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
  condition?: InputMaybe<CaseCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCasesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
  condition?: InputMaybe<CaseCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCatalogPriceRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
  condition?: InputMaybe<CatalogPriceRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCatalogPriceRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
  condition?: InputMaybe<CatalogPriceRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
  condition?: InputMaybe<CategoryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCategoriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
  condition?: InputMaybe<CategoryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
  condition?: InputMaybe<ChannelCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallChannelsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
  condition?: InputMaybe<ChannelCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallChecklistsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
  condition?: InputMaybe<ChecklistCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallChecklistsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
  condition?: InputMaybe<ChecklistCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  condition?: InputMaybe<CityCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCitiesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  condition?: InputMaybe<CityCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCollectionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
  condition?: InputMaybe<CollectionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCollectionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
  condition?: InputMaybe<CollectionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCommentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
  condition?: InputMaybe<CommentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCommentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
  condition?: InputMaybe<CommentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallContentTypesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
  condition?: InputMaybe<ContentTypeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallContentTypesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
  condition?: InputMaybe<ContentTypeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallContractsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
  condition?: InputMaybe<ContractCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallContractsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
  condition?: InputMaybe<ContractCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCountriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  condition?: InputMaybe<CountryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCountriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  condition?: InputMaybe<CountryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCouponsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
  condition?: InputMaybe<CouponCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCouponsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
  condition?: InputMaybe<CouponCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCreditMemosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
  condition?: InputMaybe<CreditMemoCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCreditMemosListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
  condition?: InputMaybe<CreditMemoCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrenciesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
  condition?: InputMaybe<CurrencyCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrenciesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
  condition?: InputMaybe<CurrencyCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrencyRatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
  condition?: InputMaybe<CurrencyRateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrencyRatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
  condition?: InputMaybe<CurrencyRateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrencySymbolsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
  condition?: InputMaybe<CurrencySymbolCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCurrencySymbolsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
  condition?: InputMaybe<CurrencySymbolCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomerGroupsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
  condition?: InputMaybe<CustomerGroupCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomerGroupsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
  condition?: InputMaybe<CustomerGroupCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
  condition?: InputMaybe<CustomerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
  condition?: InputMaybe<CustomerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomizationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
  condition?: InputMaybe<CustomizationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallCustomizationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
  condition?: InputMaybe<CustomizationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDashboardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
  condition?: InputMaybe<DashboardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDashboardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
  condition?: InputMaybe<DashboardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDeepdivesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
  condition?: InputMaybe<DeepdiveCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDeepdivesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
  condition?: InputMaybe<DeepdiveCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDigiboardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
  condition?: InputMaybe<DigiboardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallDigiboardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
  condition?: InputMaybe<DigiboardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEmailsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  condition?: InputMaybe<EmailCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEmailsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  condition?: InputMaybe<EmailCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEndofshiftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
  condition?: InputMaybe<EndofshiftCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEndofshiftsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
  condition?: InputMaybe<EndofshiftCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  condition?: InputMaybe<EventCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallEventsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  condition?: InputMaybe<EventCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallFullfillmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
  condition?: InputMaybe<FullfillmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallFullfillmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
  condition?: InputMaybe<FullfillmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallGiftCertificatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
  condition?: InputMaybe<GiftCertificateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallGiftCertificatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
  condition?: InputMaybe<GiftCertificateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallGlossariesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
  condition?: InputMaybe<GlossaryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallGlossariesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
  condition?: InputMaybe<GlossaryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallImportmsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
  condition?: InputMaybe<ImportmCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallImportmsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
  condition?: InputMaybe<ImportmCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallIntegrationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
  condition?: InputMaybe<IntegrationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallIntegrationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
  condition?: InputMaybe<IntegrationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInternalizationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
  condition?: InputMaybe<InternalizationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInternalizationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
  condition?: InputMaybe<InternalizationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInvitationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
  condition?: InputMaybe<InvitationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInvitationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
  condition?: InputMaybe<InvitationCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInvoicesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
  condition?: InputMaybe<InvoiceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallInvoicesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
  condition?: InputMaybe<InvoiceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallLeadsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
  condition?: InputMaybe<LeadCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallLeadsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
  condition?: InputMaybe<LeadCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallManufacturersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
  condition?: InputMaybe<ManufacturerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallManufacturersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
  condition?: InputMaybe<ManufacturerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMediamanagersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
  condition?: InputMaybe<MediamanagerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMediamanagersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
  condition?: InputMaybe<MediamanagerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMeetingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
  condition?: InputMaybe<MeetingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMeetingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
  condition?: InputMaybe<MeetingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMessagesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  condition?: InputMaybe<MessageCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallMessagesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  condition?: InputMaybe<MessageCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallNewslettersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
  condition?: InputMaybe<NewsletterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallNewslettersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
  condition?: InputMaybe<NewsletterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOotosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
  condition?: InputMaybe<OotoCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOotosListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
  condition?: InputMaybe<OotoCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOpportunitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
  condition?: InputMaybe<OpportunityCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOpportunitiesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
  condition?: InputMaybe<OpportunityCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOrdersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
  condition?: InputMaybe<OrderCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallOrdersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
  condition?: InputMaybe<OrderCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPagesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
  condition?: InputMaybe<PageCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPagesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
  condition?: InputMaybe<PageCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPartnersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
  condition?: InputMaybe<PartnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPartnersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
  condition?: InputMaybe<PartnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPaymentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
  condition?: InputMaybe<PaymentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPaymentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
  condition?: InputMaybe<PaymentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPermissionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  condition?: InputMaybe<PermissionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPermissionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  condition?: InputMaybe<PermissionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPluginsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
  condition?: InputMaybe<PluginCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPluginsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
  condition?: InputMaybe<PluginCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPollsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
  condition?: InputMaybe<PollCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallPollsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
  condition?: InputMaybe<PollCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProductTypesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
  condition?: InputMaybe<ProductTypeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProductTypesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
  condition?: InputMaybe<ProductTypeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProductsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
  condition?: InputMaybe<ProductCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProductsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
  condition?: InputMaybe<ProductCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProjectsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  condition?: InputMaybe<ProjectCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProjectsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  condition?: InputMaybe<ProjectCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProvidersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
  condition?: InputMaybe<ProviderCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallProvidersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
  condition?: InputMaybe<ProviderCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallQuotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  condition?: InputMaybe<QuoteCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallQuotesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  condition?: InputMaybe<QuoteCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRatingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
  condition?: InputMaybe<RatingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRatingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
  condition?: InputMaybe<RatingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
  condition?: InputMaybe<ReportCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReportsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
  condition?: InputMaybe<ReportCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReturnsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
  condition?: InputMaybe<ReturnCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReturnsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
  condition?: InputMaybe<ReturnCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReviewsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
  condition?: InputMaybe<ReviewCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallReviewsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
  condition?: InputMaybe<ReviewCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRewardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
  condition?: InputMaybe<RewardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRewardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
  condition?: InputMaybe<RewardCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRolesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  condition?: InputMaybe<RoleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallRolesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  condition?: InputMaybe<RoleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSchedulersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
  condition?: InputMaybe<SchedulerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSchedulersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
  condition?: InputMaybe<SchedulerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSegmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
  condition?: InputMaybe<SegmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSegmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
  condition?: InputMaybe<SegmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSettingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
  condition?: InputMaybe<SettingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSettingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
  condition?: InputMaybe<SettingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallShipmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
  condition?: InputMaybe<ShipmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallShipmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
  condition?: InputMaybe<ShipmentCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSpecialDiscountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
  condition?: InputMaybe<SpecialDiscountCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSpecialDiscountsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
  condition?: InputMaybe<SpecialDiscountCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
  condition?: InputMaybe<StateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
  condition?: InputMaybe<StateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStatisticsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
  condition?: InputMaybe<StatisticCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStatisticsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
  condition?: InputMaybe<StatisticCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStocksArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
  condition?: InputMaybe<StockCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallStocksListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
  condition?: InputMaybe<StockCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSurveysArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
  condition?: InputMaybe<SurveyCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallSurveysListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
  condition?: InputMaybe<SurveyCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTagsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
  condition?: InputMaybe<TagCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTagsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
  condition?: InputMaybe<TagCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTargetsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
  condition?: InputMaybe<TargetCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTargetsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
  condition?: InputMaybe<TargetCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
  condition?: InputMaybe<TaxCategoryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxCategoriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
  condition?: InputMaybe<TaxCategoryCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxRatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
  condition?: InputMaybe<TaxRateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxRatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
  condition?: InputMaybe<TaxRateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
  condition?: InputMaybe<TaxRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTaxRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
  condition?: InputMaybe<TaxRuleCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTemplatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
  condition?: InputMaybe<TemplateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTemplatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
  condition?: InputMaybe<TemplateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallThemesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
  condition?: InputMaybe<ThemeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallThemesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
  condition?: InputMaybe<ThemeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTicketingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
  condition?: InputMaybe<TicketingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTicketingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
  condition?: InputMaybe<TicketingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTrainingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
  condition?: InputMaybe<TrainingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTrainingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
  condition?: InputMaybe<TrainingCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
  condition?: InputMaybe<TransactionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallTransactionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
  condition?: InputMaybe<TransactionCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallUploadFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
  condition?: InputMaybe<UploadFileCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallUploadFilesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
  condition?: InputMaybe<UploadFileCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallUsersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  condition?: InputMaybe<UserCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallUsersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  condition?: InputMaybe<UserCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallVendorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
  condition?: InputMaybe<VendorCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallVendorsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
  condition?: InputMaybe<VendorCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallVisitsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
  condition?: InputMaybe<VisitCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallVisitsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
  condition?: InputMaybe<VisitCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWarehousesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
  condition?: InputMaybe<WarehouseCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWarehousesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
  condition?: InputMaybe<WarehouseCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWebhooksArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
  condition?: InputMaybe<WebhookCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWebhooksListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
  condition?: InputMaybe<WebhookCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWebsitesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
  condition?: InputMaybe<WebsiteCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWebsitesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
  condition?: InputMaybe<WebsiteCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWishlistsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
  condition?: InputMaybe<WishlistCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWishlistsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
  condition?: InputMaybe<WishlistCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWorkspacesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
  condition?: InputMaybe<WorkspaceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallWorkspacesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
  condition?: InputMaybe<WorkspaceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallZonesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
  condition?: InputMaybe<ZoneCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryallZonesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
  condition?: InputMaybe<ZoneCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryaccountByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryagreementByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryanalyticByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryapitokenByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryarticleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryattributeByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerybrandByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycartPriceRuleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycaseByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycatalogPriceRuleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycategoryByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerychannelByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerychecklistByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycityByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycollectionByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycommentByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycontentTypeByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycontractByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycountryByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycouponByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycreditMemoByCreditMemoAndIdArgs = {
  creditMemo: Scalars['String'];
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencyByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencyRateByImportServiceArgs = {
  importService: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencySymbolBySymbolArgs = {
  symbol: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomerGroupByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomerByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomizationByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydashboardByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydeepdiveByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydigiboardByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryemailByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryendofshiftByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryeventByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryfullfillmentByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerygiftCertificateByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryglossaryByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryimportmByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryintegrationByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinternalizationByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinvitationByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinvoiceByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryleadByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymanufacturerByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymediamanagerByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymeetingByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymessageByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerynewsletterByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryootoByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryopportunityByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryorderByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypageByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypartnerByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypaymentByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypermissionByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypluginByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypollByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproductTypeByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproductByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryprojectByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproviderByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryquoteByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryratingByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreportByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreturnByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreviewByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryrewardByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryroleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryschedulerByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysegmentByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysettingByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryshipmentByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryspecialDiscountByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystateByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystatisticByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystockByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysurveyByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytagByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytargetByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxCategoryByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxRateByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxRuleByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytemplateByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerythemeByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryticketingByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytrainingByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytransactionByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryuploadFileByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryuserByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryvendorByIdArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryvisitByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywarehouseByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywebhookByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywebsiteByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywishlistByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryworkspaceByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryzoneByIdArgs = {
  id: Scalars['BigInt'];
};


/** The root query type which gives access points into the data universe. */
export type QueryaccountArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryagreementArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryanalyticArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryapitokenArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryarticleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryattributeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerybrandArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycartPriceRuleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycaseArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycatalogPriceRuleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycategoryArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerychannelArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerychecklistArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycityArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycollectionArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycommentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycontentTypeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycontractArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycountryArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycouponArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycreditMemoArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencyArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencyRateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycurrencySymbolArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomerGroupArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerycustomizationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydashboardArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydeepdiveArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerydigiboardArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryemailArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryendofshiftArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryeventArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryfullfillmentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerygiftCertificateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryglossaryArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryimportmArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryintegrationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinternalizationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinvitationArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryinvoiceArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryleadArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymanufacturerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymediamanagerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymeetingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerymessageArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerynewsletterArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryootoArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryopportunityArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryorderArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypageArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypartnerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypaymentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypermissionArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypluginArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerypollArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproductTypeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproductArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryprojectArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryproviderArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryquoteArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryratingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreportArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreturnArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryreviewArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryrewardArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryroleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryschedulerArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysegmentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysettingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryshipmentArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryspecialDiscountArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystatisticArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerystockArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerysurveyArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytagArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytargetArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxCategoryArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxRateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytaxRuleArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytemplateArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerythemeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryticketingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytrainingArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerytransactionArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryuploadFileArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryuserArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryvendorArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryvisitArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywarehouseArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywebhookArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywebsiteArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerywishlistArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryworkspaceArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryzoneArgs = {
  nodeId: Scalars['ID'];
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

/** A connection to a list of `Account` values. */
export type AccountsConnection = {
  /** A list of `Account` objects. */
  nodes: Array<Maybe<Account>>;
  /** A list of edges which contains the `Account` and cursor to aid in pagination. */
  edges: Array<AccountsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Account` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Account = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  officePhone?: Maybe<Scalars['String']>;
  fax?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  postalcode?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  altAddress?: Maybe<Scalars['String']>;
  altPostalcode?: Maybe<Scalars['String']>;
  altCity?: Maybe<Scalars['String']>;
  altState?: Maybe<Scalars['String']>;
  altCountry?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  industry?: Maybe<Scalars['String']>;
  employees?: Maybe<Scalars['String']>;
  annualRevenue?: Maybe<Scalars['String']>;
  memberOf?: Maybe<Scalars['String']>;
  campaign?: Maybe<Scalars['String']>;
};

/** A `Account` edge in the connection. */
export type AccountsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Account` at the end of the edge. */
  node?: Maybe<Account>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
};

/** Methods to use when ordering `Account`. */
export type AccountsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'OFFICE_PHONE_ASC'
  | 'OFFICE_PHONE_DESC'
  | 'FAX_ASC'
  | 'FAX_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'POSTALCODE_ASC'
  | 'POSTALCODE_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'ALT_ADDRESS_ASC'
  | 'ALT_ADDRESS_DESC'
  | 'ALT_POSTALCODE_ASC'
  | 'ALT_POSTALCODE_DESC'
  | 'ALT_CITY_ASC'
  | 'ALT_CITY_DESC'
  | 'ALT_STATE_ASC'
  | 'ALT_STATE_DESC'
  | 'ALT_COUNTRY_ASC'
  | 'ALT_COUNTRY_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'INDUSTRY_ASC'
  | 'INDUSTRY_DESC'
  | 'EMPLOYEES_ASC'
  | 'EMPLOYEES_DESC'
  | 'ANNUAL_REVENUE_ASC'
  | 'ANNUAL_REVENUE_DESC'
  | 'MEMBER_OF_ASC'
  | 'MEMBER_OF_DESC'
  | 'CAMPAIGN_ASC'
  | 'CAMPAIGN_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical and. */
export type AccountCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `officePhone` field. */
  officePhone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `fax` field. */
  fax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `postalcode` field. */
  postalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altAddress` field. */
  altAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altPostalcode` field. */
  altPostalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altCity` field. */
  altCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altState` field. */
  altState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altCountry` field. */
  altCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `industry` field. */
  industry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `employees` field. */
  employees?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `annualRevenue` field. */
  annualRevenue?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `memberOf` field. */
  memberOf?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `campaign` field. */
  campaign?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Agreement` values. */
export type AgreementsConnection = {
  /** A list of `Agreement` objects. */
  nodes: Array<Maybe<Agreement>>;
  /** A list of edges which contains the `Agreement` and cursor to aid in pagination. */
  edges: Array<AgreementsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Agreement` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Agreement = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  referenceId?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  updated?: Maybe<Scalars['Datetime']>;
  content?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  excerpt?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['String']>;
  shopId?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
};

/** A `Agreement` edge in the connection. */
export type AgreementsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Agreement` at the end of the edge. */
  node?: Maybe<Agreement>;
};

/** Methods to use when ordering `Agreement`. */
export type AgreementsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'REFERENCE_ID_ASC'
  | 'REFERENCE_ID_DESC'
  | 'CREATED_ASC'
  | 'CREATED_DESC'
  | 'UPDATED_ASC'
  | 'UPDATED_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'USER_ID_ASC'
  | 'USER_ID_DESC'
  | 'SHOP_ID_ASC'
  | 'SHOP_ID_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Agreement` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type AgreementCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `referenceId` field. */
  referenceId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `updated` field. */
  updated?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `userId` field. */
  userId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shopId` field. */
  shopId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Analytic` values. */
export type AnalyticsConnection = {
  /** A list of `Analytic` objects. */
  nodes: Array<Maybe<Analytic>>;
  /** A list of edges which contains the `Analytic` and cursor to aid in pagination. */
  edges: Array<AnalyticsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Analytic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Analytic = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  shareData?: Maybe<Scalars['String']>;
  websiteName?: Maybe<Scalars['String']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  trackingId?: Maybe<Scalars['String']>;
  propertyName?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  defaultView?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  propertyHit?: Maybe<Scalars['String']>;
  trackingCode?: Maybe<Scalars['String']>;
  dataCollection?: Maybe<Scalars['Boolean']>;
  dataRetention?: Maybe<Scalars['Boolean']>;
  searchAnalytics?: Maybe<Scalars['String']>;
};

/** A `Analytic` edge in the connection. */
export type AnalyticsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Analytic` at the end of the edge. */
  node?: Maybe<Analytic>;
};

/** Methods to use when ordering `Analytic`. */
export type AnalyticsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'SHARE_DATA_ASC'
  | 'SHARE_DATA_DESC'
  | 'WEBSITE_NAME_ASC'
  | 'WEBSITE_NAME_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'TRACKING_ID_ASC'
  | 'TRACKING_ID_DESC'
  | 'PROPERTY_NAME_ASC'
  | 'PROPERTY_NAME_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'DEFAULT_VIEW_ASC'
  | 'DEFAULT_VIEW_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'PROPERTY_HIT_ASC'
  | 'PROPERTY_HIT_DESC'
  | 'TRACKING_CODE_ASC'
  | 'TRACKING_CODE_DESC'
  | 'DATA_COLLECTION_ASC'
  | 'DATA_COLLECTION_DESC'
  | 'DATA_RETENTION_ASC'
  | 'DATA_RETENTION_DESC'
  | 'SEARCH_ANALYTICS_ASC'
  | 'SEARCH_ANALYTICS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Analytic` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type AnalyticCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shareData` field. */
  shareData?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `websiteName` field. */
  websiteName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `trackingId` field. */
  trackingId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `propertyName` field. */
  propertyName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `defaultView` field. */
  defaultView?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `propertyHit` field. */
  propertyHit?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `trackingCode` field. */
  trackingCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `dataCollection` field. */
  dataCollection?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `dataRetention` field. */
  dataRetention?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `searchAnalytics` field. */
  searchAnalytics?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Apitoken` values. */
export type ApitokensConnection = {
  /** A list of `Apitoken` objects. */
  nodes: Array<Maybe<Apitoken>>;
  /** A list of edges which contains the `Apitoken` and cursor to aid in pagination. */
  edges: Array<ApitokensEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Apitoken` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Apitoken = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name: Scalars['String'];
  tokenType?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  token: Scalars['BigInt'];
};

/** A `Apitoken` edge in the connection. */
export type ApitokensEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Apitoken` at the end of the edge. */
  node?: Maybe<Apitoken>;
};

/** Methods to use when ordering `Apitoken`. */
export type ApitokensOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'TOKEN_TYPE_ASC'
  | 'TOKEN_TYPE_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'TOKEN_ASC'
  | 'TOKEN_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Apitoken` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type ApitokenCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tokenType` field. */
  tokenType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `token` field. */
  token?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Article` values. */
export type ArticlesConnection = {
  /** A list of `Article` objects. */
  nodes: Array<Maybe<Article>>;
  /** A list of edges which contains the `Article` and cursor to aid in pagination. */
  edges: Array<ArticlesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Article` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Article = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  excerpt?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['String']>;
  custId?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  metaName?: Maybe<Scalars['String']>;
  metaUrl?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** A `Article` edge in the connection. */
export type ArticlesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Article` at the end of the edge. */
  node?: Maybe<Article>;
};

/** Methods to use when ordering `Article`. */
export type ArticlesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'META_NAME_ASC'
  | 'META_NAME_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Article` object types. All fields are tested for equality and combined with a logical and. */
export type ArticleCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `published` field. */
  published?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaName` field. */
  metaName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Attribute` values. */
export type AttributesConnection = {
  /** A list of `Attribute` objects. */
  nodes: Array<Maybe<Attribute>>;
  /** A list of edges which contains the `Attribute` and cursor to aid in pagination. */
  edges: Array<AttributesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Attribute` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Attribute = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  defaultLabel?: Maybe<Scalars['String']>;
  attributeCode?: Maybe<Scalars['String']>;
  filterOptions?: Maybe<Scalars['String']>;
  useSearch?: Maybe<Scalars['String']>;
  layeredNavigation?: Maybe<Scalars['Boolean']>;
  searchResultsLayeredNavigation?: Maybe<Scalars['Boolean']>;
  position?: Maybe<Scalars['String']>;
  promoRuleConditions?: Maybe<Scalars['Boolean']>;
  allowHtmlTagsStorefront?: Maybe<Scalars['Boolean']>;
  visibleCatalogPagesStorefront?: Maybe<Scalars['Boolean']>;
  usedProductListing?: Maybe<Scalars['Boolean']>;
  usedSortingProductListing?: Maybe<Scalars['Boolean']>;
  prodId: Scalars['BigInt'];
  attributeClass?: Maybe<Scalars['String']>;
  attributeValue?: Maybe<Scalars['String']>;
  columnOptions?: Maybe<Scalars['String']>;
  facetedNavigation?: Maybe<Scalars['Boolean']>;
  isPublic?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  metaName?: Maybe<Scalars['Boolean']>;
  metaUrl?: Maybe<Scalars['String']>;
  productAttributeSet?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
};

/** A `Attribute` edge in the connection. */
export type AttributesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Attribute` at the end of the edge. */
  node?: Maybe<Attribute>;
};

/** Methods to use when ordering `Attribute`. */
export type AttributesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'DEFAULT_LABEL_ASC'
  | 'DEFAULT_LABEL_DESC'
  | 'ATTRIBUTE_CODE_ASC'
  | 'ATTRIBUTE_CODE_DESC'
  | 'FILTER_OPTIONS_ASC'
  | 'FILTER_OPTIONS_DESC'
  | 'USE_SEARCH_ASC'
  | 'USE_SEARCH_DESC'
  | 'LAYERED_NAVIGATION_ASC'
  | 'LAYERED_NAVIGATION_DESC'
  | 'SEARCH_RESULTS_LAYERED_NAVIGATION_ASC'
  | 'SEARCH_RESULTS_LAYERED_NAVIGATION_DESC'
  | 'POSITION_ASC'
  | 'POSITION_DESC'
  | 'PROMO_RULE_CONDITIONS_ASC'
  | 'PROMO_RULE_CONDITIONS_DESC'
  | 'ALLOW_HTML_TAGS_STOREFRONT_ASC'
  | 'ALLOW_HTML_TAGS_STOREFRONT_DESC'
  | 'VISIBLE_CATALOG_PAGES_STOREFRONT_ASC'
  | 'VISIBLE_CATALOG_PAGES_STOREFRONT_DESC'
  | 'USED_PRODUCT_LISTING_ASC'
  | 'USED_PRODUCT_LISTING_DESC'
  | 'USED_SORTING_PRODUCT_LISTING_ASC'
  | 'USED_SORTING_PRODUCT_LISTING_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'ATTRIBUTE_CLASS_ASC'
  | 'ATTRIBUTE_CLASS_DESC'
  | 'ATTRIBUTE_VALUE_ASC'
  | 'ATTRIBUTE_VALUE_DESC'
  | 'COLUMN_OPTIONS_ASC'
  | 'COLUMN_OPTIONS_DESC'
  | 'FACETED_NAVIGATION_ASC'
  | 'FACETED_NAVIGATION_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'META_NAME_ASC'
  | 'META_NAME_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'PRODUCT_ATTRIBUTE_SET_ASC'
  | 'PRODUCT_ATTRIBUTE_SET_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Attribute` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type AttributeCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `defaultLabel` field. */
  defaultLabel?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `attributeCode` field. */
  attributeCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `filterOptions` field. */
  filterOptions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `useSearch` field. */
  useSearch?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `layeredNavigation` field. */
  layeredNavigation?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `searchResultsLayeredNavigation` field. */
  searchResultsLayeredNavigation?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `position` field. */
  position?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `promoRuleConditions` field. */
  promoRuleConditions?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `allowHtmlTagsStorefront` field. */
  allowHtmlTagsStorefront?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `visibleCatalogPagesStorefront` field. */
  visibleCatalogPagesStorefront?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `usedProductListing` field. */
  usedProductListing?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `usedSortingProductListing` field. */
  usedSortingProductListing?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `attributeClass` field. */
  attributeClass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `attributeValue` field. */
  attributeValue?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `columnOptions` field. */
  columnOptions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `facetedNavigation` field. */
  facetedNavigation?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaName` field. */
  metaName?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `productAttributeSet` field. */
  productAttributeSet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Brand` values. */
export type BrandsConnection = {
  /** A list of `Brand` objects. */
  nodes: Array<Maybe<Brand>>;
  /** A list of edges which contains the `Brand` and cursor to aid in pagination. */
  edges: Array<BrandsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Brand` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Brand = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['BigInt']>;
  description?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Brand` edge in the connection. */
export type BrandsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Brand` at the end of the edge. */
  node?: Maybe<Brand>;
};

/** Methods to use when ordering `Brand`. */
export type BrandsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical and. */
export type BrandCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `product` field. */
  product?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `CartPriceRule` values. */
export type CartPriceRulesConnection = {
  /** A list of `CartPriceRule` objects. */
  nodes: Array<Maybe<CartPriceRule>>;
  /** A list of edges which contains the `CartPriceRule` and cursor to aid in pagination. */
  edges: Array<CartPriceRulesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CartPriceRule` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CartPriceRule = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  rule?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  coupon?: Maybe<Scalars['String']>;
  usesPerCustomer?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Date']>;
  endDate?: Maybe<Scalars['Date']>;
  status?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  actionsApply?: Maybe<Scalars['String']>;
  actionsDiscountAmount?: Maybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: Maybe<Scalars['Boolean']>;
  actionsMaxQtyDiscountIsAppliedTo?: Maybe<Scalars['BigFloat']>;
  actionsDiscountQtyStep?: Maybe<Scalars['BigFloat']>;
  actionsApplyShippingAmount?: Maybe<Scalars['Boolean']>;
};

/** A `CartPriceRule` edge in the connection. */
export type CartPriceRulesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CartPriceRule` at the end of the edge. */
  node?: Maybe<CartPriceRule>;
};

/** Methods to use when ordering `CartPriceRule`. */
export type CartPriceRulesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'RULE_ASC'
  | 'RULE_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'COUPON_ASC'
  | 'COUPON_DESC'
  | 'USES_PER_CUSTOMER_ASC'
  | 'USES_PER_CUSTOMER_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'ACTIONS_APPLY_ASC'
  | 'ACTIONS_APPLY_DESC'
  | 'ACTIONS_DISCOUNT_AMOUNT_ASC'
  | 'ACTIONS_DISCOUNT_AMOUNT_DESC'
  | 'ACTIONS_DISCARD_SUBSEQUENT_RULES_ASC'
  | 'ACTIONS_DISCARD_SUBSEQUENT_RULES_DESC'
  | 'ACTIONS_MAX_QTY_DISCOUNT_IS_APPLIED_TO_ASC'
  | 'ACTIONS_MAX_QTY_DISCOUNT_IS_APPLIED_TO_DESC'
  | 'ACTIONS_DISCOUNT_QTY_STEP_ASC'
  | 'ACTIONS_DISCOUNT_QTY_STEP_DESC'
  | 'ACTIONS_APPLY_SHIPPING_AMOUNT_ASC'
  | 'ACTIONS_APPLY_SHIPPING_AMOUNT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CartPriceRule` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type CartPriceRuleCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `rule` field. */
  rule?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `active` field. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `coupon` field. */
  coupon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `usesPerCustomer` field. */
  usesPerCustomer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `actionsApply` field. */
  actionsApply?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `actionsDiscountAmount` field. */
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `actionsDiscardSubsequentRules` field. */
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `actionsMaxQtyDiscountIsAppliedTo` field. */
  actionsMaxQtyDiscountIsAppliedTo?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `actionsDiscountQtyStep` field. */
  actionsDiscountQtyStep?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `actionsApplyShippingAmount` field. */
  actionsApplyShippingAmount?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Case` values. */
export type CasesConnection = {
  /** A list of `Case` objects. */
  nodes: Array<Maybe<Case>>;
  /** A list of edges which contains the `Case` and cursor to aid in pagination. */
  edges: Array<CasesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Case` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Case = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  caseNumber?: Maybe<Scalars['Int']>;
  state?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  resolution?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  accountName?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  dateModified?: Maybe<Scalars['Datetime']>;
};

/** A `Case` edge in the connection. */
export type CasesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Case` at the end of the edge. */
  node?: Maybe<Case>;
};

/** Methods to use when ordering `Case`. */
export type CasesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CASE_NUMBER_ASC'
  | 'CASE_NUMBER_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'RESOLUTION_ASC'
  | 'RESOLUTION_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'DATE_MODIFIED_ASC'
  | 'DATE_MODIFIED_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Case` object types. All fields are tested for equality and combined with a logical and. */
export type CaseCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `caseNumber` field. */
  caseNumber?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `resolution` field. */
  resolution?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `dateModified` field. */
  dateModified?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `CatalogPriceRule` values. */
export type CatalogPriceRulesConnection = {
  /** A list of `CatalogPriceRule` objects. */
  nodes: Array<Maybe<CatalogPriceRule>>;
  /** A list of edges which contains the `CatalogPriceRule` and cursor to aid in pagination. */
  edges: Array<CatalogPriceRulesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CatalogPriceRule` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CatalogPriceRule = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  rule?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  customerGroups?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['Date']>;
  endDate?: Maybe<Scalars['Date']>;
  status?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  actionsApply?: Maybe<Scalars['String']>;
  actionsDiscountAmount?: Maybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: Maybe<Scalars['Boolean']>;
};

/** A `CatalogPriceRule` edge in the connection. */
export type CatalogPriceRulesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CatalogPriceRule` at the end of the edge. */
  node?: Maybe<CatalogPriceRule>;
};

/** Methods to use when ordering `CatalogPriceRule`. */
export type CatalogPriceRulesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'RULE_ASC'
  | 'RULE_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'CUSTOMER_GROUPS_ASC'
  | 'CUSTOMER_GROUPS_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'ACTIONS_APPLY_ASC'
  | 'ACTIONS_APPLY_DESC'
  | 'ACTIONS_DISCOUNT_AMOUNT_ASC'
  | 'ACTIONS_DISCOUNT_AMOUNT_DESC'
  | 'ACTIONS_DISCARD_SUBSEQUENT_RULES_ASC'
  | 'ACTIONS_DISCARD_SUBSEQUENT_RULES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CatalogPriceRule` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type CatalogPriceRuleCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `rule` field. */
  rule?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `active` field. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `customerGroups` field. */
  customerGroups?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `actionsApply` field. */
  actionsApply?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `actionsDiscountAmount` field. */
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `actionsDiscardSubsequentRules` field. */
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of `Category` values. */
export type CategoriesConnection = {
  /** A list of `Category` objects. */
  nodes: Array<Maybe<Category>>;
  /** A list of edges which contains the `Category` and cursor to aid in pagination. */
  edges: Array<CategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Category` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Category = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  thumbnail?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  visibility?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Boolean']>;
  websites?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  metaTitle?: Maybe<Scalars['String']>;
  metaKeywords?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  metaUrl?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Category` edge in the connection. */
export type CategoriesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Category` at the end of the edge. */
  node?: Maybe<Category>;
};

/** Methods to use when ordering `Category`. */
export type CategoriesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'THUMBNAIL_ASC'
  | 'THUMBNAIL_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'VISIBILITY_ASC'
  | 'VISIBILITY_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'META_TITLE_ASC'
  | 'META_TITLE_DESC'
  | 'META_KEYWORDS_ASC'
  | 'META_KEYWORDS_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Category` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type CategoryCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `thumbnail` field. */
  thumbnail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `visibility` field. */
  visibility?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaTitle` field. */
  metaTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaKeywords` field. */
  metaKeywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Channel` values. */
export type ChannelsConnection = {
  /** A list of `Channel` objects. */
  nodes: Array<Maybe<Channel>>;
  /** A list of edges which contains the `Channel` and cursor to aid in pagination. */
  edges: Array<ChannelsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Channel` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Channel = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  defaultLang?: Maybe<Scalars['String']>;
  includeTax?: Maybe<Scalars['String']>;
  defaultZone?: Maybe<Scalars['String']>;
  defaultShipping?: Maybe<Scalars['String']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
};

/** A `Channel` edge in the connection. */
export type ChannelsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Channel` at the end of the edge. */
  node?: Maybe<Channel>;
};

/** Methods to use when ordering `Channel`. */
export type ChannelsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CURRENCY_ASC'
  | 'CURRENCY_DESC'
  | 'DEFAULT_LANG_ASC'
  | 'DEFAULT_LANG_DESC'
  | 'INCLUDE_TAX_ASC'
  | 'INCLUDE_TAX_DESC'
  | 'DEFAULT_ZONE_ASC'
  | 'DEFAULT_ZONE_DESC'
  | 'DEFAULT_SHIPPING_ASC'
  | 'DEFAULT_SHIPPING_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Channel` object types. All fields are tested for equality and combined with a logical and. */
export type ChannelCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `currency` field. */
  currency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `defaultLang` field. */
  defaultLang?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `includeTax` field. */
  includeTax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `defaultZone` field. */
  defaultZone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `defaultShipping` field. */
  defaultShipping?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Checklist` values. */
export type ChecklistsConnection = {
  /** A list of `Checklist` objects. */
  nodes: Array<Maybe<Checklist>>;
  /** A list of edges which contains the `Checklist` and cursor to aid in pagination. */
  edges: Array<ChecklistsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Checklist` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Checklist = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  username?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  regionalManager?: Maybe<Scalars['String']>;
  manager?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  ticket?: Maybe<Scalars['String']>;
  project?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  prodId?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
  task?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** A `Checklist` edge in the connection. */
export type ChecklistsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Checklist` at the end of the edge. */
  node?: Maybe<Checklist>;
};

/** Methods to use when ordering `Checklist`. */
export type ChecklistsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'REGIONAL_MANAGER_ASC'
  | 'REGIONAL_MANAGER_DESC'
  | 'MANAGER_ASC'
  | 'MANAGER_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'TICKET_ASC'
  | 'TICKET_DESC'
  | 'PROJECT_ASC'
  | 'PROJECT_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'TASK_ASC'
  | 'TASK_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Checklist` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type ChecklistCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `username` field. */
  username?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `regionalManager` field. */
  regionalManager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `manager` field. */
  manager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `ticket` field. */
  ticket?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `project` field. */
  project?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `region` field. */
  region?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `task` field. */
  task?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `City` values. */
export type CitiesConnection = {
  /** A list of `City` objects. */
  nodes: Array<Maybe<City>>;
  /** A list of edges which contains the `City` and cursor to aid in pagination. */
  edges: Array<CitiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `City` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type City = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  postalCode?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
};

/** A `City` edge in the connection. */
export type CitiesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `City` at the end of the edge. */
  node?: Maybe<City>;
};

/** Methods to use when ordering `City`. */
export type CitiesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'POSTAL_CODE_ASC'
  | 'POSTAL_CODE_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `City` object types. All fields are tested for equality and combined with a logical and. */
export type CityCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `postalCode` field. */
  postalCode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Collection` values. */
export type CollectionsConnection = {
  /** A list of `Collection` objects. */
  nodes: Array<Maybe<Collection>>;
  /** A list of edges which contains the `Collection` and cursor to aid in pagination. */
  edges: Array<CollectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Collection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Collection = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  metaTitle?: Maybe<Scalars['String']>;
  metaKeywords?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
};

/** A `Collection` edge in the connection. */
export type CollectionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Collection` at the end of the edge. */
  node?: Maybe<Collection>;
};

/** Methods to use when ordering `Collection`. */
export type CollectionsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'META_TITLE_ASC'
  | 'META_TITLE_DESC'
  | 'META_KEYWORDS_ASC'
  | 'META_KEYWORDS_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Collection` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type CollectionCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaTitle` field. */
  metaTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaKeywords` field. */
  metaKeywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Comment` values. */
export type CommentsConnection = {
  /** A list of `Comment` objects. */
  nodes: Array<Maybe<Comment>>;
  /** A list of edges which contains the `Comment` and cursor to aid in pagination. */
  edges: Array<CommentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Comment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Comment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  customerName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  response?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  custId: Scalars['Int'];
  customers?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
};

/** A `Comment` edge in the connection. */
export type CommentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Comment` at the end of the edge. */
  node?: Maybe<Comment>;
};

/** Methods to use when ordering `Comment`. */
export type CommentsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CUSTOMER_NAME_ASC'
  | 'CUSTOMER_NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'RESPONSE_ASC'
  | 'RESPONSE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Comment` object types. All fields are tested for equality and combined with a logical and. */
export type CommentCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `customerName` field. */
  customerName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `response` field. */
  response?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `ContentType` values. */
export type ContentTypesConnection = {
  /** A list of `ContentType` objects. */
  nodes: Array<Maybe<ContentType>>;
  /** A list of edges which contains the `ContentType` and cursor to aid in pagination. */
  edges: Array<ContentTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ContentType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ContentType = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  text?: Maybe<Scalars['String']>;
  number?: Maybe<Scalars['BigFloat']>;
  json?: Maybe<Scalars['JSON']>;
  link?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  uid?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['Date']>;
  time?: Maybe<Scalars['Time']>;
  timestamp?: Maybe<Scalars['Datetime']>;
  boolean?: Maybe<Scalars['Boolean']>;
  richText?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  databaseName?: Maybe<Scalars['String']>;
};

/** A `ContentType` edge in the connection. */
export type ContentTypesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ContentType` at the end of the edge. */
  node?: Maybe<ContentType>;
};

/** Methods to use when ordering `ContentType`. */
export type ContentTypesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'TEXT_ASC'
  | 'TEXT_DESC'
  | 'NUMBER_ASC'
  | 'NUMBER_DESC'
  | 'JSON_ASC'
  | 'JSON_DESC'
  | 'LINK_ASC'
  | 'LINK_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'UID_ASC'
  | 'UID_DESC'
  | 'DATE_ASC'
  | 'DATE_DESC'
  | 'TIME_ASC'
  | 'TIME_DESC'
  | 'TIMESTAMP_ASC'
  | 'TIMESTAMP_DESC'
  | 'BOOLEAN_ASC'
  | 'BOOLEAN_DESC'
  | 'RICH_TEXT_ASC'
  | 'RICH_TEXT_DESC'
  | 'PASSWORD_ASC'
  | 'PASSWORD_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'DATABASE_NAME_ASC'
  | 'DATABASE_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `ContentType` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type ContentTypeCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `text` field. */
  text?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `number` field. */
  number?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `json` field. */
  json?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the objects `link` field. */
  link?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `uid` field. */
  uid?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `date` field. */
  date?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the objects `time` field. */
  time?: InputMaybe<Scalars['Time']>;
  /** Checks for equality with the objects `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `boolean` field. */
  boolean?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `richText` field. */
  richText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `password` field. */
  password?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `databaseName` field. */
  databaseName?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Contract` values. */
export type ContractsConnection = {
  /** A list of `Contract` objects. */
  nodes: Array<Maybe<Contract>>;
  /** A list of edges which contains the `Contract` and cursor to aid in pagination. */
  edges: Array<ContractsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Contract` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Contract = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  contractTitle?: Maybe<Scalars['String']>;
  contractValue?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  renewalReminder?: Maybe<Scalars['String']>;
  customerSignedDate?: Maybe<Scalars['String']>;
  companySignedDate?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  contractManager?: Maybe<Scalars['String']>;
  account?: Maybe<Scalars['String']>;
  contact?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  opportunity?: Maybe<Scalars['String']>;
  contractType?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  lineItems?: Maybe<Scalars['String']>;
  total?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['String']>;
  subtotal?: Maybe<Scalars['String']>;
  shipping?: Maybe<Scalars['String']>;
  shippingTax?: Maybe<Scalars['String']>;
  tax?: Maybe<Scalars['String']>;
  grandTotal?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** A `Contract` edge in the connection. */
export type ContractsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Contract` at the end of the edge. */
  node?: Maybe<Contract>;
};

/** Methods to use when ordering `Contract`. */
export type ContractsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CONTRACT_TITLE_ASC'
  | 'CONTRACT_TITLE_DESC'
  | 'CONTRACT_VALUE_ASC'
  | 'CONTRACT_VALUE_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'RENEWAL_REMINDER_ASC'
  | 'RENEWAL_REMINDER_DESC'
  | 'CUSTOMER_SIGNED_DATE_ASC'
  | 'CUSTOMER_SIGNED_DATE_DESC'
  | 'COMPANY_SIGNED_DATE_ASC'
  | 'COMPANY_SIGNED_DATE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'CONTRACT_MANAGER_ASC'
  | 'CONTRACT_MANAGER_DESC'
  | 'ACCOUNT_ASC'
  | 'ACCOUNT_DESC'
  | 'CONTACT_ASC'
  | 'CONTACT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'OPPORTUNITY_ASC'
  | 'OPPORTUNITY_DESC'
  | 'CONTRACT_TYPE_ASC'
  | 'CONTRACT_TYPE_DESC'
  | 'CURRENCY_ASC'
  | 'CURRENCY_DESC'
  | 'LINE_ITEMS_ASC'
  | 'LINE_ITEMS_DESC'
  | 'TOTAL_ASC'
  | 'TOTAL_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'SUBTOTAL_ASC'
  | 'SUBTOTAL_DESC'
  | 'SHIPPING_ASC'
  | 'SHIPPING_DESC'
  | 'SHIPPING_TAX_ASC'
  | 'SHIPPING_TAX_DESC'
  | 'TAX_ASC'
  | 'TAX_DESC'
  | 'GRAND_TOTAL_ASC'
  | 'GRAND_TOTAL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Contract` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type ContractCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `contractTitle` field. */
  contractTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `contractValue` field. */
  contractValue?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `renewalReminder` field. */
  renewalReminder?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerSignedDate` field. */
  customerSignedDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `companySignedDate` field. */
  companySignedDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `contractManager` field. */
  contractManager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `account` field. */
  account?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `contact` field. */
  contact?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `opportunity` field. */
  opportunity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `contractType` field. */
  contractType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `currency` field. */
  currency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lineItems` field. */
  lineItems?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `total` field. */
  total?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `discount` field. */
  discount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `subtotal` field. */
  subtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shipping` field. */
  shipping?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingTax` field. */
  shippingTax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tax` field. */
  tax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `grandTotal` field. */
  grandTotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Country` values. */
export type CountriesConnection = {
  /** A list of `Country` objects. */
  nodes: Array<Maybe<Country>>;
  /** A list of edges which contains the `Country` and cursor to aid in pagination. */
  edges: Array<CountriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Country` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Country = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
};

/** A `Country` edge in the connection. */
export type CountriesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Country` at the end of the edge. */
  node?: Maybe<Country>;
};

/** Methods to use when ordering `Country`. */
export type CountriesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical and. */
export type CountryCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `region` field. */
  region?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Coupon` values. */
export type CouponsConnection = {
  /** A list of `Coupon` objects. */
  nodes: Array<Maybe<Coupon>>;
  /** A list of edges which contains the `Coupon` and cursor to aid in pagination. */
  edges: Array<CouponsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Coupon` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Coupon = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  expiration?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  productsCouponsToproducts?: Maybe<Scalars['String']>;
};

/** A `Coupon` edge in the connection. */
export type CouponsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Coupon` at the end of the edge. */
  node?: Maybe<Coupon>;
};

/** Methods to use when ordering `Coupon`. */
export type CouponsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_COUPONS_TOPRODUCTS_ASC'
  | 'PRODUCTS_COUPONS_TOPRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Coupon` object types. All fields are tested for equality and combined with a logical and. */
export type CouponCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `discount` field. */
  discount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `expiration` field. */
  expiration?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `productsCouponsToproducts` field. */
  productsCouponsToproducts?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `CreditMemo` values. */
export type CreditMemosConnection = {
  /** A list of `CreditMemo` objects. */
  nodes: Array<Maybe<CreditMemo>>;
  /** A list of edges which contains the `CreditMemo` and cursor to aid in pagination. */
  edges: Array<CreditMemosEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CreditMemo` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CreditMemo = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  creditMemo: Scalars['String'];
  orderNumber: Scalars['Int'];
  created?: Maybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  status?: Maybe<Scalars['String']>;
  refunded?: Maybe<Scalars['String']>;
  action?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  customers?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
};

/** A `CreditMemo` edge in the connection. */
export type CreditMemosEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CreditMemo` at the end of the edge. */
  node?: Maybe<CreditMemo>;
};

/** Methods to use when ordering `CreditMemo`. */
export type CreditMemosOrderBy =
  | 'NATURAL'
  | 'CREDIT_MEMO_ASC'
  | 'CREDIT_MEMO_DESC'
  | 'ORDER_NUMBER_ASC'
  | 'ORDER_NUMBER_DESC'
  | 'CREATED_ASC'
  | 'CREATED_DESC'
  | 'BILL_TO_NAME_ASC'
  | 'BILL_TO_NAME_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'REFUNDED_ASC'
  | 'REFUNDED_DESC'
  | 'ACTION_ASC'
  | 'ACTION_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CreditMemo` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type CreditMemoCondition = {
  /** Checks for equality with the objects `creditMemo` field. */
  creditMemo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `orderNumber` field. */
  orderNumber?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `billToName` field. */
  billToName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `refunded` field. */
  refunded?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `action` field. */
  action?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Currency` values. */
export type CurrenciesConnection = {
  /** A list of `Currency` objects. */
  nodes: Array<Maybe<Currency>>;
  /** A list of edges which contains the `Currency` and cursor to aid in pagination. */
  edges: Array<CurrenciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Currency` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Currency = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
};

/** A `Currency` edge in the connection. */
export type CurrenciesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Currency` at the end of the edge. */
  node?: Maybe<Currency>;
};

/** Methods to use when ordering `Currency`. */
export type CurrenciesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Currency` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type CurrencyCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `region` field. */
  region?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `CurrencyRate` values. */
export type CurrencyRatesConnection = {
  /** A list of `CurrencyRate` objects. */
  nodes: Array<Maybe<CurrencyRate>>;
  /** A list of edges which contains the `CurrencyRate` and cursor to aid in pagination. */
  edges: Array<CurrencyRatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CurrencyRate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CurrencyRate = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  importService: Scalars['String'];
  usd?: Maybe<Scalars['BigFloat']>;
  id: Scalars['BigInt'];
};

/** A `CurrencyRate` edge in the connection. */
export type CurrencyRatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CurrencyRate` at the end of the edge. */
  node?: Maybe<CurrencyRate>;
};

/** Methods to use when ordering `CurrencyRate`. */
export type CurrencyRatesOrderBy =
  | 'NATURAL'
  | 'IMPORT_SERVICE_ASC'
  | 'IMPORT_SERVICE_DESC'
  | 'USD_ASC'
  | 'USD_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CurrencyRate` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type CurrencyRateCondition = {
  /** Checks for equality with the objects `importService` field. */
  importService?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `usd` field. */
  usd?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `CurrencySymbol` values. */
export type CurrencySymbolsConnection = {
  /** A list of `CurrencySymbol` objects. */
  nodes: Array<Maybe<CurrencySymbol>>;
  /** A list of edges which contains the `CurrencySymbol` and cursor to aid in pagination. */
  edges: Array<CurrencySymbolsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CurrencySymbol` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CurrencySymbol = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  symbol: Scalars['String'];
  useStandard?: Maybe<Scalars['Boolean']>;
  id: Scalars['BigInt'];
};

/** A `CurrencySymbol` edge in the connection. */
export type CurrencySymbolsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CurrencySymbol` at the end of the edge. */
  node?: Maybe<CurrencySymbol>;
};

/** Methods to use when ordering `CurrencySymbol`. */
export type CurrencySymbolsOrderBy =
  | 'NATURAL'
  | 'SYMBOL_ASC'
  | 'SYMBOL_DESC'
  | 'USE_STANDARD_ASC'
  | 'USE_STANDARD_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CurrencySymbol` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type CurrencySymbolCondition = {
  /** Checks for equality with the objects `symbol` field. */
  symbol?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `useStandard` field. */
  useStandard?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `CustomerGroup` values. */
export type CustomerGroupsConnection = {
  /** A list of `CustomerGroup` objects. */
  nodes: Array<Maybe<CustomerGroup>>;
  /** A list of edges which contains the `CustomerGroup` and cursor to aid in pagination. */
  edges: Array<CustomerGroupsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `CustomerGroup` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type CustomerGroup = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  taxClass?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  customers?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  coverPhoto?: Maybe<Scalars['String']>;
};

/** A `CustomerGroup` edge in the connection. */
export type CustomerGroupsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `CustomerGroup` at the end of the edge. */
  node?: Maybe<CustomerGroup>;
};

/** Methods to use when ordering `CustomerGroup`. */
export type CustomerGroupsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'TAX_CLASS_ASC'
  | 'TAX_CLASS_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'COVER_PHOTO_ASC'
  | 'COVER_PHOTO_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `CustomerGroup` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type CustomerGroupCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taxClass` field. */
  taxClass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `coverPhoto` field. */
  coverPhoto?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Customer` values. */
export type CustomersConnection = {
  /** A list of `Customer` objects. */
  nodes: Array<Maybe<Customer>>;
  /** A list of edges which contains the `Customer` and cursor to aid in pagination. */
  edges: Array<CustomersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Customer = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  thumbnail?: Maybe<Scalars['String']>;
  namePrefix?: Maybe<Scalars['String']>;
  firstName: Scalars['String'];
  middleName?: Maybe<Scalars['String']>;
  lastName: Scalars['String'];
  email: Scalars['String'];
  customerGroup?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  zipcode?: Maybe<Scalars['String']>;
  nameSuffix?: Maybe<Scalars['String']>;
  websites?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  customerSince?: Maybe<Scalars['Datetime']>;
  confirmedEmail?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['String']>;
  taxVatNumber?: Maybe<Scalars['String']>;
  gender?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  addressTwo?: Maybe<Scalars['String']>;
  paymentType?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  creditMemos?: Maybe<Scalars['String']>;
  customerPayment?: Maybe<Scalars['String']>;
  emails?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  messages?: Maybe<Scalars['String']>;
  newsletterSubscribers?: Maybe<Scalars['String']>;
  orders?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  quotes?: Maybe<Scalars['String']>;
  returns?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Customer` edge in the connection. */
export type CustomersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customer` at the end of the edge. */
  node?: Maybe<Customer>;
};

/** Methods to use when ordering `Customer`. */
export type CustomersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'THUMBNAIL_ASC'
  | 'THUMBNAIL_DESC'
  | 'NAME_PREFIX_ASC'
  | 'NAME_PREFIX_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'MIDDLE_NAME_ASC'
  | 'MIDDLE_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'CUSTOMER_GROUP_ASC'
  | 'CUSTOMER_GROUP_DESC'
  | 'PHONE_ASC'
  | 'PHONE_DESC'
  | 'ZIPCODE_ASC'
  | 'ZIPCODE_DESC'
  | 'NAME_SUFFIX_ASC'
  | 'NAME_SUFFIX_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'CUSTOMER_SINCE_ASC'
  | 'CUSTOMER_SINCE_DESC'
  | 'CONFIRMED_EMAIL_ASC'
  | 'CONFIRMED_EMAIL_DESC'
  | 'DATE_OF_BIRTH_ASC'
  | 'DATE_OF_BIRTH_DESC'
  | 'TAX_VAT_NUMBER_ASC'
  | 'TAX_VAT_NUMBER_DESC'
  | 'GENDER_ASC'
  | 'GENDER_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'SHORT_DESCRIPTION_ASC'
  | 'SHORT_DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'ADDRESS_TWO_ASC'
  | 'ADDRESS_TWO_DESC'
  | 'PAYMENT_TYPE_ASC'
  | 'PAYMENT_TYPE_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC'
  | 'PASSWORD_ASC'
  | 'PASSWORD_DESC'
  | 'COMMENTS_ASC'
  | 'COMMENTS_DESC'
  | 'CREDIT_MEMOS_ASC'
  | 'CREDIT_MEMOS_DESC'
  | 'CUSTOMER_PAYMENT_ASC'
  | 'CUSTOMER_PAYMENT_DESC'
  | 'EMAILS_ASC'
  | 'EMAILS_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'MESSAGES_ASC'
  | 'MESSAGES_DESC'
  | 'NEWSLETTER_SUBSCRIBERS_ASC'
  | 'NEWSLETTER_SUBSCRIBERS_DESC'
  | 'ORDERS_ASC'
  | 'ORDERS_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'QUOTES_ASC'
  | 'QUOTES_DESC'
  | 'RETURNS_ASC'
  | 'RETURNS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Customer` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type CustomerCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `thumbnail` field. */
  thumbnail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `namePrefix` field. */
  namePrefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `middleName` field. */
  middleName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerGroup` field. */
  customerGroup?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `phone` field. */
  phone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `zipcode` field. */
  zipcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `nameSuffix` field. */
  nameSuffix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerSince` field. */
  customerSince?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `confirmedEmail` field. */
  confirmedEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taxVatNumber` field. */
  taxVatNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `gender` field. */
  gender?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `addressTwo` field. */
  addressTwo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `paymentType` field. */
  paymentType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `username` field. */
  username?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `password` field. */
  password?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `comments` field. */
  comments?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `creditMemos` field. */
  creditMemos?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerPayment` field. */
  customerPayment?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `emails` field. */
  emails?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `messages` field. */
  messages?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `newsletterSubscribers` field. */
  newsletterSubscribers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `orders` field. */
  orders?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `quotes` field. */
  quotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `returns` field. */
  returns?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Customization` values. */
export type CustomizationsConnection = {
  /** A list of `Customization` objects. */
  nodes: Array<Maybe<Customization>>;
  /** A list of edges which contains the `Customization` and cursor to aid in pagination. */
  edges: Array<CustomizationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Customization` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Customization = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  createdAt?: Maybe<Scalars['Datetime']>;
  siteName?: Maybe<Scalars['String']>;
  navLink?: Maybe<Scalars['String']>;
  notification?: Maybe<Scalars['String']>;
  banner?: Maybe<Scalars['String']>;
  footerLink?: Maybe<Scalars['String']>;
  announcement?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  siteUrl?: Maybe<Scalars['String']>;
  allowSignup?: Maybe<Scalars['String']>;
};

/** A `Customization` edge in the connection. */
export type CustomizationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Customization` at the end of the edge. */
  node?: Maybe<Customization>;
};

/** Methods to use when ordering `Customization`. */
export type CustomizationsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SITE_NAME_ASC'
  | 'SITE_NAME_DESC'
  | 'NAV_LINK_ASC'
  | 'NAV_LINK_DESC'
  | 'NOTIFICATION_ASC'
  | 'NOTIFICATION_DESC'
  | 'BANNER_ASC'
  | 'BANNER_DESC'
  | 'FOOTER_LINK_ASC'
  | 'FOOTER_LINK_DESC'
  | 'ANNOUNCEMENT_ASC'
  | 'ANNOUNCEMENT_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'SITE_URL_ASC'
  | 'SITE_URL_DESC'
  | 'ALLOW_SIGNUP_ASC'
  | 'ALLOW_SIGNUP_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Customization` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type CustomizationCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `siteName` field. */
  siteName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `navLink` field. */
  navLink?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `notification` field. */
  notification?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `banner` field. */
  banner?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `footerLink` field. */
  footerLink?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `announcement` field. */
  announcement?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `siteUrl` field. */
  siteUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `allowSignup` field. */
  allowSignup?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Dashboard` values. */
export type DashboardsConnection = {
  /** A list of `Dashboard` objects. */
  nodes: Array<Maybe<Dashboard>>;
  /** A list of edges which contains the `Dashboard` and cursor to aid in pagination. */
  edges: Array<DashboardsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Dashboard` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Dashboard = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  privacy?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  task?: Maybe<Scalars['String']>;
  reports?: Maybe<Scalars['String']>;
  tasks?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  tickets?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  checklists?: Maybe<Scalars['String']>;
  visits?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  sales?: Maybe<Scalars['String']>;
};

/** A `Dashboard` edge in the connection. */
export type DashboardsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Dashboard` at the end of the edge. */
  node?: Maybe<Dashboard>;
};

/** Methods to use when ordering `Dashboard`. */
export type DashboardsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'PRIVACY_ASC'
  | 'PRIVACY_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'TASK_ASC'
  | 'TASK_DESC'
  | 'REPORTS_ASC'
  | 'REPORTS_DESC'
  | 'TASKS_ASC'
  | 'TASKS_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'TICKETS_ASC'
  | 'TICKETS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'CHECKLISTS_ASC'
  | 'CHECKLISTS_DESC'
  | 'VISITS_ASC'
  | 'VISITS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'SALES_ASC'
  | 'SALES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Dashboard` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type DashboardCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `privacy` field. */
  privacy?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `task` field. */
  task?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `reports` field. */
  reports?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tasks` field. */
  tasks?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tickets` field. */
  tickets?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `checklists` field. */
  checklists?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `visits` field. */
  visits?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `sales` field. */
  sales?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Deepdive` values. */
export type DeepdivesConnection = {
  /** A list of `Deepdive` objects. */
  nodes: Array<Maybe<Deepdive>>;
  /** A list of edges which contains the `Deepdive` and cursor to aid in pagination. */
  edges: Array<DeepdivesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Deepdive` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Deepdive = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  attendees?: Maybe<Scalars['String']>;
  login?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  whid?: Maybe<Scalars['String']>;
};

/** A `Deepdive` edge in the connection. */
export type DeepdivesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Deepdive` at the end of the edge. */
  node?: Maybe<Deepdive>;
};

/** Methods to use when ordering `Deepdive`. */
export type DeepdivesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'ATTENDEES_ASC'
  | 'ATTENDEES_DESC'
  | 'LOGIN_ASC'
  | 'LOGIN_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'WHID_ASC'
  | 'WHID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Deepdive` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type DeepdiveCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `attendees` field. */
  attendees?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `login` field. */
  login?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `whid` field. */
  whid?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Digiboard` values. */
export type DigiboardsConnection = {
  /** A list of `Digiboard` objects. */
  nodes: Array<Maybe<Digiboard>>;
  /** A list of edges which contains the `Digiboard` and cursor to aid in pagination. */
  edges: Array<DigiboardsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Digiboard` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Digiboard = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  board?: Maybe<Scalars['String']>;
  createdAt: Scalars['Datetime'];
  student?: Maybe<Scalars['String']>;
  course?: Maybe<Scalars['String']>;
};

/** A `Digiboard` edge in the connection. */
export type DigiboardsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Digiboard` at the end of the edge. */
  node?: Maybe<Digiboard>;
};

/** Methods to use when ordering `Digiboard`. */
export type DigiboardsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'BOARD_ASC'
  | 'BOARD_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'STUDENT_ASC'
  | 'STUDENT_DESC'
  | 'COURSE_ASC'
  | 'COURSE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Digiboard` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type DigiboardCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `board` field. */
  board?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `student` field. */
  student?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `course` field. */
  course?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Email` values. */
export type EmailsConnection = {
  /** A list of `Email` objects. */
  nodes: Array<Maybe<Email>>;
  /** A list of edges which contains the `Email` and cursor to aid in pagination. */
  edges: Array<EmailsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Email` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Email = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  createdAt?: Maybe<Scalars['Datetime']>;
  subject?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  bcc?: Maybe<Scalars['String']>;
  cc?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  staffId?: Maybe<Scalars['Int']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Email` edge in the connection. */
export type EmailsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Email` at the end of the edge. */
  node?: Maybe<Email>;
};

/** Methods to use when ordering `Email`. */
export type EmailsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'BCC_ASC'
  | 'BCC_DESC'
  | 'CC_ASC'
  | 'CC_DESC'
  | 'FROM_ASC'
  | 'FROM_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'STAFF_ID_ASC'
  | 'STAFF_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Email` object types. All fields are tested for equality and combined with a logical and. */
export type EmailCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `bcc` field. */
  bcc?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `cc` field. */
  cc?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `from` field. */
  from?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `staffId` field. */
  staffId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Endofshift` values. */
export type EndofshiftsConnection = {
  /** A list of `Endofshift` objects. */
  nodes: Array<Maybe<Endofshift>>;
  /** A list of edges which contains the `Endofshift` and cursor to aid in pagination. */
  edges: Array<EndofshiftsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Endofshift` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Endofshift = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  content?: Maybe<Scalars['String']>;
  login?: Maybe<Scalars['String']>;
  mcms?: Maybe<Scalars['String']>;
  nextShift?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  tickets?: Maybe<Scalars['String']>;
  whid?: Maybe<Scalars['String']>;
};

/** A `Endofshift` edge in the connection. */
export type EndofshiftsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Endofshift` at the end of the edge. */
  node?: Maybe<Endofshift>;
};

/** Methods to use when ordering `Endofshift`. */
export type EndofshiftsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'LOGIN_ASC'
  | 'LOGIN_DESC'
  | 'MCMS_ASC'
  | 'MCMS_DESC'
  | 'NEXT_SHIFT_ASC'
  | 'NEXT_SHIFT_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'TICKETS_ASC'
  | 'TICKETS_DESC'
  | 'WHID_ASC'
  | 'WHID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Endofshift` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type EndofshiftCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `login` field. */
  login?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mcms` field. */
  mcms?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `nextShift` field. */
  nextShift?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tickets` field. */
  tickets?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `whid` field. */
  whid?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Event` values. */
export type EventsConnection = {
  /** A list of `Event` objects. */
  nodes: Array<Maybe<Event>>;
  /** A list of edges which contains the `Event` and cursor to aid in pagination. */
  edges: Array<EventsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Event` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Event = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  tickets?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  start?: Maybe<Scalars['String']>;
  end?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  postalcode?: Maybe<Scalars['String']>;
};

/** A `Event` edge in the connection. */
export type EventsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Event` at the end of the edge. */
  node?: Maybe<Event>;
};

/** Methods to use when ordering `Event`. */
export type EventsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'TICKETS_ASC'
  | 'TICKETS_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'START_ASC'
  | 'START_DESC'
  | 'END_ASC'
  | 'END_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'POSTALCODE_ASC'
  | 'POSTALCODE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical and. */
export type EventCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tickets` field. */
  tickets?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `start` field. */
  start?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `end` field. */
  end?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `postalcode` field. */
  postalcode?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Fullfillment` values. */
export type FullfillmentsConnection = {
  /** A list of `Fullfillment` objects. */
  nodes: Array<Maybe<Fullfillment>>;
  /** A list of edges which contains the `Fullfillment` and cursor to aid in pagination. */
  edges: Array<FullfillmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Fullfillment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Fullfillment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  shippingZones?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  addressTwo?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  zipcode?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  countryArea?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  pickup?: Maybe<Scalars['String']>;
  stock?: Maybe<Scalars['String']>;
};

/** A `Fullfillment` edge in the connection. */
export type FullfillmentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Fullfillment` at the end of the edge. */
  node?: Maybe<Fullfillment>;
};

/** Methods to use when ordering `Fullfillment`. */
export type FullfillmentsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'SHIPPING_ZONES_ASC'
  | 'SHIPPING_ZONES_DESC'
  | 'COMPANY_ASC'
  | 'COMPANY_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'ADDRESS_TWO_ASC'
  | 'ADDRESS_TWO_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'ZIPCODE_ASC'
  | 'ZIPCODE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'COUNTRY_AREA_ASC'
  | 'COUNTRY_AREA_DESC'
  | 'PHONE_ASC'
  | 'PHONE_DESC'
  | 'PICKUP_ASC'
  | 'PICKUP_DESC'
  | 'STOCK_ASC'
  | 'STOCK_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Fullfillment` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type FullfillmentCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingZones` field. */
  shippingZones?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `company` field. */
  company?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `addressTwo` field. */
  addressTwo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `zipcode` field. */
  zipcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `countryArea` field. */
  countryArea?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `phone` field. */
  phone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `pickup` field. */
  pickup?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `stock` field. */
  stock?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `GiftCertificate` values. */
export type GiftCertificatesConnection = {
  /** A list of `GiftCertificate` objects. */
  nodes: Array<Maybe<GiftCertificate>>;
  /** A list of edges which contains the `GiftCertificate` and cursor to aid in pagination. */
  edges: Array<GiftCertificatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GiftCertificate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type GiftCertificate = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  specialOffers?: Maybe<Scalars['String']>;
  rewards?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  expiration?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** A `GiftCertificate` edge in the connection. */
export type GiftCertificatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `GiftCertificate` at the end of the edge. */
  node?: Maybe<GiftCertificate>;
};

/** Methods to use when ordering `GiftCertificate`. */
export type GiftCertificatesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'SPECIAL_OFFERS_ASC'
  | 'SPECIAL_OFFERS_DESC'
  | 'REWARDS_ASC'
  | 'REWARDS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `GiftCertificate` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type GiftCertificateCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `discount` field. */
  discount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `specialOffers` field. */
  specialOffers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `rewards` field. */
  rewards?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `expiration` field. */
  expiration?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Glossary` values. */
export type GlossariesConnection = {
  /** A list of `Glossary` objects. */
  nodes: Array<Maybe<Glossary>>;
  /** A list of edges which contains the `Glossary` and cursor to aid in pagination. */
  edges: Array<GlossariesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Glossary` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Glossary = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  content?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
};

/** A `Glossary` edge in the connection. */
export type GlossariesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Glossary` at the end of the edge. */
  node?: Maybe<Glossary>;
};

/** Methods to use when ordering `Glossary`. */
export type GlossariesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Glossary` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type GlossaryCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Importm` values. */
export type ImportmsConnection = {
  /** A list of `Importm` objects. */
  nodes: Array<Maybe<Importm>>;
  /** A list of edges which contains the `Importm` and cursor to aid in pagination. */
  edges: Array<ImportmsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Importm` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Importm = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
};

/** A `Importm` edge in the connection. */
export type ImportmsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Importm` at the end of the edge. */
  node?: Maybe<Importm>;
};

/** Methods to use when ordering `Importm`. */
export type ImportmsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'FILE_ASC'
  | 'FILE_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Importm` object types. All fields are tested for equality and combined with a logical and. */
export type ImportmCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `file` field. */
  file?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Integration` values. */
export type IntegrationsConnection = {
  /** A list of `Integration` objects. */
  nodes: Array<Maybe<Integration>>;
  /** A list of edges which contains the `Integration` and cursor to aid in pagination. */
  edges: Array<IntegrationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Integration` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Integration = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
};

/** A `Integration` edge in the connection. */
export type IntegrationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Integration` at the end of the edge. */
  node?: Maybe<Integration>;
};

/** Methods to use when ordering `Integration`. */
export type IntegrationsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Integration` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type IntegrationCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `category` field. */
  category?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Internalization` values. */
export type InternalizationsConnection = {
  /** A list of `Internalization` objects. */
  nodes: Array<Maybe<Internalization>>;
  /** A list of edges which contains the `Internalization` and cursor to aid in pagination. */
  edges: Array<InternalizationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Internalization` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Internalization = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  default?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
};

/** A `Internalization` edge in the connection. */
export type InternalizationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Internalization` at the end of the edge. */
  node?: Maybe<Internalization>;
};

/** Methods to use when ordering `Internalization`. */
export type InternalizationsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'DEFAULT_ASC'
  | 'DEFAULT_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Internalization` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type InternalizationCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `region` field. */
  region?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `default` field. */
  default?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Invitation` values. */
export type InvitationsConnection = {
  /** A list of `Invitation` objects. */
  nodes: Array<Maybe<Invitation>>;
  /** A list of edges which contains the `Invitation` and cursor to aid in pagination. */
  edges: Array<InvitationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Invitation` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Invitation = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  invoiceDate?: Maybe<Scalars['Datetime']>;
  email?: Maybe<Scalars['String']>;
  billingAddress?: Maybe<Scalars['String']>;
  shippingAddress?: Maybe<Scalars['String']>;
  orderNumber?: Maybe<Scalars['String']>;
  grandTotalPurchased?: Maybe<Scalars['String']>;
  paymentMethod?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
};

/** A `Invitation` edge in the connection. */
export type InvitationsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Invitation` at the end of the edge. */
  node?: Maybe<Invitation>;
};

/** Methods to use when ordering `Invitation`. */
export type InvitationsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'INVOICE_DATE_ASC'
  | 'INVOICE_DATE_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'BILLING_ADDRESS_ASC'
  | 'BILLING_ADDRESS_DESC'
  | 'SHIPPING_ADDRESS_ASC'
  | 'SHIPPING_ADDRESS_DESC'
  | 'ORDER_NUMBER_ASC'
  | 'ORDER_NUMBER_DESC'
  | 'GRAND_TOTAL_PURCHASED_ASC'
  | 'GRAND_TOTAL_PURCHASED_DESC'
  | 'PAYMENT_METHOD_ASC'
  | 'PAYMENT_METHOD_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Invitation` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type InvitationCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `invoiceDate` field. */
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `billingAddress` field. */
  billingAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingAddress` field. */
  shippingAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `orderNumber` field. */
  orderNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `grandTotalPurchased` field. */
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `paymentMethod` field. */
  paymentMethod?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Invoice` values. */
export type InvoicesConnection = {
  /** A list of `Invoice` objects. */
  nodes: Array<Maybe<Invoice>>;
  /** A list of edges which contains the `Invoice` and cursor to aid in pagination. */
  edges: Array<InvoicesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Invoice` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Invoice = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  invoice: Scalars['Int'];
  orderNumber: Scalars['BigInt'];
  invoiceDate?: Maybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  billingAddress?: Maybe<Scalars['String']>;
  grandTotalBase?: Maybe<Scalars['String']>;
  grandTotalPurchased?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  shippingAddress?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  customerGroup?: Maybe<Scalars['String']>;
  paymentMethod?: Maybe<Scalars['String']>;
  shippingInformation?: Maybe<Scalars['String']>;
  subtotal?: Maybe<Scalars['String']>;
  shippingAndHandling?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** A `Invoice` edge in the connection. */
export type InvoicesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Invoice` at the end of the edge. */
  node?: Maybe<Invoice>;
};

/** Methods to use when ordering `Invoice`. */
export type InvoicesOrderBy =
  | 'NATURAL'
  | 'INVOICE_ASC'
  | 'INVOICE_DESC'
  | 'ORDER_NUMBER_ASC'
  | 'ORDER_NUMBER_DESC'
  | 'INVOICE_DATE_ASC'
  | 'INVOICE_DATE_DESC'
  | 'BILL_TO_NAME_ASC'
  | 'BILL_TO_NAME_DESC'
  | 'BILLING_ADDRESS_ASC'
  | 'BILLING_ADDRESS_DESC'
  | 'GRAND_TOTAL_BASE_ASC'
  | 'GRAND_TOTAL_BASE_DESC'
  | 'GRAND_TOTAL_PURCHASED_ASC'
  | 'GRAND_TOTAL_PURCHASED_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'SHIPPING_ADDRESS_ASC'
  | 'SHIPPING_ADDRESS_DESC'
  | 'CUSTOMER_NAME_ASC'
  | 'CUSTOMER_NAME_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'CUSTOMER_GROUP_ASC'
  | 'CUSTOMER_GROUP_DESC'
  | 'PAYMENT_METHOD_ASC'
  | 'PAYMENT_METHOD_DESC'
  | 'SHIPPING_INFORMATION_ASC'
  | 'SHIPPING_INFORMATION_DESC'
  | 'SUBTOTAL_ASC'
  | 'SUBTOTAL_DESC'
  | 'SHIPPING_AND_HANDLING_ASC'
  | 'SHIPPING_AND_HANDLING_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Invoice` object types. All fields are tested for equality and combined with a logical and. */
export type InvoiceCondition = {
  /** Checks for equality with the objects `invoice` field. */
  invoice?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `orderNumber` field. */
  orderNumber?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `invoiceDate` field. */
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `billToName` field. */
  billToName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `billingAddress` field. */
  billingAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `grandTotalBase` field. */
  grandTotalBase?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `grandTotalPurchased` field. */
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingAddress` field. */
  shippingAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerName` field. */
  customerName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerGroup` field. */
  customerGroup?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `paymentMethod` field. */
  paymentMethod?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingInformation` field. */
  shippingInformation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `subtotal` field. */
  subtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingAndHandling` field. */
  shippingAndHandling?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
};

/** A connection to a list of `Lead` values. */
export type LeadsConnection = {
  /** A list of `Lead` objects. */
  nodes: Array<Maybe<Lead>>;
  /** A list of edges which contains the `Lead` and cursor to aid in pagination. */
  edges: Array<LeadsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Lead` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Lead = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  prefix?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  department?: Maybe<Scalars['String']>;
  accountName?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  postalcode?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  fax?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  mobile?: Maybe<Scalars['String']>;
  jobTitle?: Maybe<Scalars['String']>;
  altAddress?: Maybe<Scalars['String']>;
  altPostalcode?: Maybe<Scalars['String']>;
  altCity?: Maybe<Scalars['String']>;
  altState?: Maybe<Scalars['String']>;
  altCountry?: Maybe<Scalars['String']>;
  officePhone?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  statusDescription?: Maybe<Scalars['String']>;
  opportunityAmount?: Maybe<Scalars['String']>;
  campaign?: Maybe<Scalars['String']>;
  leadSource?: Maybe<Scalars['String']>;
  leadSourceDescription?: Maybe<Scalars['String']>;
  referredBy?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
};

/** A `Lead` edge in the connection. */
export type LeadsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Lead` at the end of the edge. */
  node?: Maybe<Lead>;
};

/** Methods to use when ordering `Lead`. */
export type LeadsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'PREFIX_ASC'
  | 'PREFIX_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'DEPARTMENT_ASC'
  | 'DEPARTMENT_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'POSTALCODE_ASC'
  | 'POSTALCODE_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'FAX_ASC'
  | 'FAX_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'MOBILE_ASC'
  | 'MOBILE_DESC'
  | 'JOB_TITLE_ASC'
  | 'JOB_TITLE_DESC'
  | 'ALT_ADDRESS_ASC'
  | 'ALT_ADDRESS_DESC'
  | 'ALT_POSTALCODE_ASC'
  | 'ALT_POSTALCODE_DESC'
  | 'ALT_CITY_ASC'
  | 'ALT_CITY_DESC'
  | 'ALT_STATE_ASC'
  | 'ALT_STATE_DESC'
  | 'ALT_COUNTRY_ASC'
  | 'ALT_COUNTRY_DESC'
  | 'OFFICE_PHONE_ASC'
  | 'OFFICE_PHONE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'STATUS_DESCRIPTION_ASC'
  | 'STATUS_DESCRIPTION_DESC'
  | 'OPPORTUNITY_AMOUNT_ASC'
  | 'OPPORTUNITY_AMOUNT_DESC'
  | 'CAMPAIGN_ASC'
  | 'CAMPAIGN_DESC'
  | 'LEAD_SOURCE_ASC'
  | 'LEAD_SOURCE_DESC'
  | 'LEAD_SOURCE_DESCRIPTION_ASC'
  | 'LEAD_SOURCE_DESCRIPTION_DESC'
  | 'REFERRED_BY_ASC'
  | 'REFERRED_BY_DESC'
  | 'CUSTOMER_NAME_ASC'
  | 'CUSTOMER_NAME_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Lead` object types. All fields are tested for equality and combined with a logical and. */
export type LeadCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `prefix` field. */
  prefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `department` field. */
  department?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `postalcode` field. */
  postalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `fax` field. */
  fax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mobile` field. */
  mobile?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `jobTitle` field. */
  jobTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altAddress` field. */
  altAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altPostalcode` field. */
  altPostalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altCity` field. */
  altCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altState` field. */
  altState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altCountry` field. */
  altCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `officePhone` field. */
  officePhone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `statusDescription` field. */
  statusDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `opportunityAmount` field. */
  opportunityAmount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `campaign` field. */
  campaign?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `leadSource` field. */
  leadSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `leadSourceDescription` field. */
  leadSourceDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `referredBy` field. */
  referredBy?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerName` field. */
  customerName?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Manufacturer` values. */
export type ManufacturersConnection = {
  /** A list of `Manufacturer` objects. */
  nodes: Array<Maybe<Manufacturer>>;
  /** A list of edges which contains the `Manufacturer` and cursor to aid in pagination. */
  edges: Array<ManufacturersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Manufacturer` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Manufacturer = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['BigInt']>;
  description?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
};

/** A `Manufacturer` edge in the connection. */
export type ManufacturersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Manufacturer` at the end of the edge. */
  node?: Maybe<Manufacturer>;
};

/** Methods to use when ordering `Manufacturer`. */
export type ManufacturersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Manufacturer` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type ManufacturerCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `product` field. */
  product?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Mediamanager` values. */
export type MediamanagersConnection = {
  /** A list of `Mediamanager` objects. */
  nodes: Array<Maybe<Mediamanager>>;
  /** A list of edges which contains the `Mediamanager` and cursor to aid in pagination. */
  edges: Array<MediamanagersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Mediamanager` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Mediamanager = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  keywords?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  brands?: Maybe<Scalars['BigInt']>;
  status?: Maybe<Scalars['String']>;
  expirationDate?: Maybe<Scalars['String']>;
  copyright?: Maybe<Scalars['String']>;
  dimensions?: Maybe<Scalars['String']>;
  author?: Maybe<Scalars['Int']>;
  contentType?: Maybe<Scalars['String']>;
  versions?: Maybe<Scalars['String']>;
  watermarkName?: Maybe<Scalars['String']>;
  watermarkDescription?: Maybe<Scalars['String']>;
  watermarkMedia?: Maybe<Scalars['String']>;
  agreements?: Maybe<Scalars['Int']>;
  albums?: Maybe<Scalars['String']>;
  comment?: Maybe<Scalars['Int']>;
  workspace?: Maybe<Scalars['String']>;
  taskName?: Maybe<Scalars['BigInt']>;
  taskDescription?: Maybe<Scalars['String']>;
  taskType?: Maybe<Scalars['String']>;
  members?: Maybe<Scalars['Int']>;
  products?: Maybe<Scalars['BigInt']>;
  agreementsAgreementsTomediamanager?: Maybe<Scalars['String']>;
  brandsBrandsTomediamanager?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  productsMediamanagerToproducts?: Maybe<Scalars['String']>;
  tasks?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Mediamanager` edge in the connection. */
export type MediamanagersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Mediamanager` at the end of the edge. */
  node?: Maybe<Mediamanager>;
};

/** Methods to use when ordering `Mediamanager`. */
export type MediamanagersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'KEYWORDS_ASC'
  | 'KEYWORDS_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'BRANDS_ASC'
  | 'BRANDS_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'EXPIRATION_DATE_ASC'
  | 'EXPIRATION_DATE_DESC'
  | 'COPYRIGHT_ASC'
  | 'COPYRIGHT_DESC'
  | 'DIMENSIONS_ASC'
  | 'DIMENSIONS_DESC'
  | 'AUTHOR_ASC'
  | 'AUTHOR_DESC'
  | 'CONTENT_TYPE_ASC'
  | 'CONTENT_TYPE_DESC'
  | 'VERSIONS_ASC'
  | 'VERSIONS_DESC'
  | 'WATERMARK_NAME_ASC'
  | 'WATERMARK_NAME_DESC'
  | 'WATERMARK_DESCRIPTION_ASC'
  | 'WATERMARK_DESCRIPTION_DESC'
  | 'WATERMARK_MEDIA_ASC'
  | 'WATERMARK_MEDIA_DESC'
  | 'AGREEMENTS_ASC'
  | 'AGREEMENTS_DESC'
  | 'ALBUMS_ASC'
  | 'ALBUMS_DESC'
  | 'COMMENT_ASC'
  | 'COMMENT_DESC'
  | 'WORKSPACE_ASC'
  | 'WORKSPACE_DESC'
  | 'TASK_NAME_ASC'
  | 'TASK_NAME_DESC'
  | 'TASK_DESCRIPTION_ASC'
  | 'TASK_DESCRIPTION_DESC'
  | 'TASK_TYPE_ASC'
  | 'TASK_TYPE_DESC'
  | 'MEMBERS_ASC'
  | 'MEMBERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'AGREEMENTS_AGREEMENTS_TOMEDIAMANAGER_ASC'
  | 'AGREEMENTS_AGREEMENTS_TOMEDIAMANAGER_DESC'
  | 'BRANDS_BRANDS_TOMEDIAMANAGER_ASC'
  | 'BRANDS_BRANDS_TOMEDIAMANAGER_DESC'
  | 'COMMENTS_ASC'
  | 'COMMENTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRODUCTS_MEDIAMANAGER_TOPRODUCTS_ASC'
  | 'PRODUCTS_MEDIAMANAGER_TOPRODUCTS_DESC'
  | 'TASKS_ASC'
  | 'TASKS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Mediamanager` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type MediamanagerCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `keywords` field. */
  keywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `brands` field. */
  brands?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `expirationDate` field. */
  expirationDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `copyright` field. */
  copyright?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `dimensions` field. */
  dimensions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `author` field. */
  author?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `contentType` field. */
  contentType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `versions` field. */
  versions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `watermarkName` field. */
  watermarkName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `watermarkDescription` field. */
  watermarkDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `watermarkMedia` field. */
  watermarkMedia?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `agreements` field. */
  agreements?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `albums` field. */
  albums?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `comment` field. */
  comment?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `workspace` field. */
  workspace?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taskName` field. */
  taskName?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `taskDescription` field. */
  taskDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taskType` field. */
  taskType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `members` field. */
  members?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `agreementsAgreementsTomediamanager` field. */
  agreementsAgreementsTomediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `brandsBrandsTomediamanager` field. */
  brandsBrandsTomediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `comments` field. */
  comments?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `productsMediamanagerToproducts` field. */
  productsMediamanagerToproducts?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tasks` field. */
  tasks?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Meeting` values. */
export type MeetingsConnection = {
  /** A list of `Meeting` objects. */
  nodes: Array<Maybe<Meeting>>;
  /** A list of edges which contains the `Meeting` and cursor to aid in pagination. */
  edges: Array<MeetingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Meeting` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Meeting = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  subject?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  relatedTo?: Maybe<Scalars['String']>;
  reminders?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  invitees?: Maybe<Scalars['String']>;
  scheduling?: Maybe<Scalars['String']>;
};

/** A `Meeting` edge in the connection. */
export type MeetingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Meeting` at the end of the edge. */
  node?: Maybe<Meeting>;
};

/** Methods to use when ordering `Meeting`. */
export type MeetingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'DURATION_ASC'
  | 'DURATION_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'RELATED_TO_ASC'
  | 'RELATED_TO_DESC'
  | 'REMINDERS_ASC'
  | 'REMINDERS_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'INVITEES_ASC'
  | 'INVITEES_DESC'
  | 'SCHEDULING_ASC'
  | 'SCHEDULING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Meeting` object types. All fields are tested for equality and combined with a logical and. */
export type MeetingCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `duration` field. */
  duration?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `relatedTo` field. */
  relatedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `reminders` field. */
  reminders?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `invitees` field. */
  invitees?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `scheduling` field. */
  scheduling?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Message` values. */
export type MessagesConnection = {
  /** A list of `Message` objects. */
  nodes: Array<Maybe<Message>>;
  /** A list of edges which contains the `Message` and cursor to aid in pagination. */
  edges: Array<MessagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Message` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Message = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  from?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  subject?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  sender?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  media?: Maybe<Scalars['String']>;
  staffId?: Maybe<Scalars['Int']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Message` edge in the connection. */
export type MessagesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Message` at the end of the edge. */
  node?: Maybe<Message>;
};

/** Methods to use when ordering `Message`. */
export type MessagesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'FROM_ASC'
  | 'FROM_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'SENDER_ASC'
  | 'SENDER_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'STAFF_ID_ASC'
  | 'STAFF_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical and. */
export type MessageCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `from` field. */
  from?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `sender` field. */
  sender?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `staffId` field. */
  staffId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Newsletter` values. */
export type NewslettersConnection = {
  /** A list of `Newsletter` objects. */
  nodes: Array<Maybe<Newsletter>>;
  /** A list of edges which contains the `Newsletter` and cursor to aid in pagination. */
  edges: Array<NewslettersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Newsletter` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Newsletter = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  email: Scalars['String'];
  customerFirstName?: Maybe<Scalars['String']>;
  customerLastName?: Maybe<Scalars['String']>;
  store?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  websites?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  custId: Scalars['Int'];
  customers?: Maybe<Scalars['String']>;
};

/** A `Newsletter` edge in the connection. */
export type NewslettersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Newsletter` at the end of the edge. */
  node?: Maybe<Newsletter>;
};

/** Methods to use when ordering `Newsletter`. */
export type NewslettersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'CUSTOMER_FIRST_NAME_ASC'
  | 'CUSTOMER_FIRST_NAME_DESC'
  | 'CUSTOMER_LAST_NAME_ASC'
  | 'CUSTOMER_LAST_NAME_DESC'
  | 'STORE_ASC'
  | 'STORE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Newsletter` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type NewsletterCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerFirstName` field. */
  customerFirstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerLastName` field. */
  customerLastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `store` field. */
  store?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Ooto` values. */
export type OotosConnection = {
  /** A list of `Ooto` objects. */
  nodes: Array<Maybe<Ooto>>;
  /** A list of edges which contains the `Ooto` and cursor to aid in pagination. */
  edges: Array<OotosEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Ooto` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Ooto = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  login?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  usingTime?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
};

/** A `Ooto` edge in the connection. */
export type OotosEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Ooto` at the end of the edge. */
  node?: Maybe<Ooto>;
};

/** Methods to use when ordering `Ooto`. */
export type OotosOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'LOGIN_ASC'
  | 'LOGIN_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'NOTE_ASC'
  | 'NOTE_DESC'
  | 'USING_TIME_ASC'
  | 'USING_TIME_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Ooto` object types. All fields are tested for equality and combined with a logical and. */
export type OotoCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `login` field. */
  login?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `note` field. */
  note?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `usingTime` field. */
  usingTime?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `location` field. */
  location?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Opportunity` values. */
export type OpportunitiesConnection = {
  /** A list of `Opportunity` objects. */
  nodes: Array<Maybe<Opportunity>>;
  /** A list of edges which contains the `Opportunity` and cursor to aid in pagination. */
  edges: Array<OpportunitiesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Opportunity` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Opportunity = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  amount?: Maybe<Scalars['String']>;
  salesStage?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  probability?: Maybe<Scalars['String']>;
  nextStep?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  leadSource?: Maybe<Scalars['String']>;
  campaign?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  accountName?: Maybe<Scalars['String']>;
  expectedCloseDate?: Maybe<Scalars['String']>;
};

/** A `Opportunity` edge in the connection. */
export type OpportunitiesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Opportunity` at the end of the edge. */
  node?: Maybe<Opportunity>;
};

/** Methods to use when ordering `Opportunity`. */
export type OpportunitiesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'AMOUNT_ASC'
  | 'AMOUNT_DESC'
  | 'SALES_STAGE_ASC'
  | 'SALES_STAGE_DESC'
  | 'CURRENCY_ASC'
  | 'CURRENCY_DESC'
  | 'PROBABILITY_ASC'
  | 'PROBABILITY_DESC'
  | 'NEXT_STEP_ASC'
  | 'NEXT_STEP_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'LEAD_SOURCE_ASC'
  | 'LEAD_SOURCE_DESC'
  | 'CAMPAIGN_ASC'
  | 'CAMPAIGN_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'EXPECTED_CLOSE_DATE_ASC'
  | 'EXPECTED_CLOSE_DATE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Opportunity` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type OpportunityCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `amount` field. */
  amount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `salesStage` field. */
  salesStage?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `currency` field. */
  currency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `probability` field. */
  probability?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `nextStep` field. */
  nextStep?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `leadSource` field. */
  leadSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `campaign` field. */
  campaign?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `expectedCloseDate` field. */
  expectedCloseDate?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Order` values. */
export type OrdersConnection = {
  /** A list of `Order` objects. */
  nodes: Array<Maybe<Order>>;
  /** A list of edges which contains the `Order` and cursor to aid in pagination. */
  edges: Array<OrdersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Order` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Order = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  purchasePoint?: Maybe<Scalars['Int']>;
  purchaseDate?: Maybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  shipToName?: Maybe<Scalars['String']>;
  grandTotalBase?: Maybe<Scalars['Int']>;
  grandTotalPurchased?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['Boolean']>;
  action?: Maybe<Scalars['Boolean']>;
  allocatedSources?: Maybe<Scalars['String']>;
  braintreeTransactionSource?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  customers?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  quotes?: Maybe<Scalars['String']>;
  transactions?: Maybe<Scalars['String']>;
};

/** A `Order` edge in the connection. */
export type OrdersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Order` at the end of the edge. */
  node?: Maybe<Order>;
};

/** Methods to use when ordering `Order`. */
export type OrdersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'PURCHASE_POINT_ASC'
  | 'PURCHASE_POINT_DESC'
  | 'PURCHASE_DATE_ASC'
  | 'PURCHASE_DATE_DESC'
  | 'BILL_TO_NAME_ASC'
  | 'BILL_TO_NAME_DESC'
  | 'SHIP_TO_NAME_ASC'
  | 'SHIP_TO_NAME_DESC'
  | 'GRAND_TOTAL_BASE_ASC'
  | 'GRAND_TOTAL_BASE_DESC'
  | 'GRAND_TOTAL_PURCHASED_ASC'
  | 'GRAND_TOTAL_PURCHASED_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'ACTION_ASC'
  | 'ACTION_DESC'
  | 'ALLOCATED_SOURCES_ASC'
  | 'ALLOCATED_SOURCES_DESC'
  | 'BRAINTREE_TRANSACTION_SOURCE_ASC'
  | 'BRAINTREE_TRANSACTION_SOURCE_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'QUOTES_ASC'
  | 'QUOTES_DESC'
  | 'TRANSACTIONS_ASC'
  | 'TRANSACTIONS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Order` object types. All fields are tested for equality and combined with a logical and. */
export type OrderCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `purchasePoint` field. */
  purchasePoint?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `purchaseDate` field. */
  purchaseDate?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `billToName` field. */
  billToName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shipToName` field. */
  shipToName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `grandTotalBase` field. */
  grandTotalBase?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `grandTotalPurchased` field. */
  grandTotalPurchased?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `action` field. */
  action?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `allocatedSources` field. */
  allocatedSources?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `braintreeTransactionSource` field. */
  braintreeTransactionSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `quotes` field. */
  quotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `transactions` field. */
  transactions?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Page` values. */
export type PagesConnection = {
  /** A list of `Page` objects. */
  nodes: Array<Maybe<Page>>;
  /** A list of edges which contains the `Page` and cursor to aid in pagination. */
  edges: Array<PagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Page` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Page = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  enablePage?: Maybe<Scalars['Boolean']>;
  title: Scalars['String'];
  contentTitle?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  urlKey?: Maybe<Scalars['String']>;
  metaTitle?: Maybe<Scalars['String']>;
  metaKeywords?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
};

/** A `Page` edge in the connection. */
export type PagesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Page` at the end of the edge. */
  node?: Maybe<Page>;
};

/** Methods to use when ordering `Page`. */
export type PagesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'ENABLE_PAGE_ASC'
  | 'ENABLE_PAGE_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'CONTENT_TITLE_ASC'
  | 'CONTENT_TITLE_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'URL_KEY_ASC'
  | 'URL_KEY_DESC'
  | 'META_TITLE_ASC'
  | 'META_TITLE_DESC'
  | 'META_KEYWORDS_ASC'
  | 'META_KEYWORDS_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical and. */
export type PageCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `enablePage` field. */
  enablePage?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `contentTitle` field. */
  contentTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `urlKey` field. */
  urlKey?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaTitle` field. */
  metaTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaKeywords` field. */
  metaKeywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Partner` values. */
export type PartnersConnection = {
  /** A list of `Partner` objects. */
  nodes: Array<Maybe<Partner>>;
  /** A list of edges which contains the `Partner` and cursor to aid in pagination. */
  edges: Array<PartnersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Partner` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Partner = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  businessType?: Maybe<Scalars['String']>;
};

/** A `Partner` edge in the connection. */
export type PartnersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Partner` at the end of the edge. */
  node?: Maybe<Partner>;
};

/** Methods to use when ordering `Partner`. */
export type PartnersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'BUSINESS_TYPE_ASC'
  | 'BUSINESS_TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Partner` object types. All fields are tested for equality and combined with a logical and. */
export type PartnerCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `businessType` field. */
  businessType?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Payment` values. */
export type PaymentsConnection = {
  /** A list of `Payment` objects. */
  nodes: Array<Maybe<Payment>>;
  /** A list of edges which contains the `Payment` and cursor to aid in pagination. */
  edges: Array<PaymentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Payment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Payment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  hostUri?: Maybe<Scalars['String']>;
  redirectUrl?: Maybe<Scalars['String']>;
  redirectUrlApp?: Maybe<Scalars['String']>;
  icon?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  active?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
};

/** A `Payment` edge in the connection. */
export type PaymentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Payment` at the end of the edge. */
  node?: Maybe<Payment>;
};

/** Methods to use when ordering `Payment`. */
export type PaymentsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'HOST_URI_ASC'
  | 'HOST_URI_DESC'
  | 'REDIRECT_URL_ASC'
  | 'REDIRECT_URL_DESC'
  | 'REDIRECT_URL_APP_ASC'
  | 'REDIRECT_URL_APP_DESC'
  | 'ICON_ASC'
  | 'ICON_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Payment` object types. All fields are tested for equality and combined with a logical and. */
export type PaymentCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `hostUri` field. */
  hostUri?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `redirectUrl` field. */
  redirectUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `redirectUrlApp` field. */
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `icon` field. */
  icon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `active` field. */
  active?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Permission` values. */
export type PermissionsConnection = {
  /** A list of `Permission` objects. */
  nodes: Array<Maybe<Permission>>;
  /** A list of edges which contains the `Permission` and cursor to aid in pagination. */
  edges: Array<PermissionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Permission` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Permission = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  create?: Maybe<Scalars['String']>;
  delete?: Maybe<Scalars['String']>;
  read?: Maybe<Scalars['String']>;
  role?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Permission` edge in the connection. */
export type PermissionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Permission` at the end of the edge. */
  node?: Maybe<Permission>;
};

/** Methods to use when ordering `Permission`. */
export type PermissionsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATE_ASC'
  | 'CREATE_DESC'
  | 'DELETE_ASC'
  | 'DELETE_DESC'
  | 'READ_ASC'
  | 'READ_DESC'
  | 'ROLE_ASC'
  | 'ROLE_DESC'
  | 'UPDATE_ASC'
  | 'UPDATE_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Permission` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type PermissionCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `create` field. */
  create?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `delete` field. */
  delete?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `read` field. */
  read?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `role` field. */
  role?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `update` field. */
  update?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Plugin` values. */
export type PluginsConnection = {
  /** A list of `Plugin` objects. */
  nodes: Array<Maybe<Plugin>>;
  /** A list of edges which contains the `Plugin` and cursor to aid in pagination. */
  edges: Array<PluginsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Plugin` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Plugin = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  githubLink?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  logo?: Maybe<Scalars['String']>;
  screenshots?: Maybe<Scalars['String']>;
  lastUpdated?: Maybe<Scalars['Datetime']>;
  publisherName?: Maybe<Scalars['String']>;
  agreeTerms?: Maybe<Scalars['Boolean']>;
  publisherEmail?: Maybe<Scalars['String']>;
};

/** A `Plugin` edge in the connection. */
export type PluginsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Plugin` at the end of the edge. */
  node?: Maybe<Plugin>;
};

/** Methods to use when ordering `Plugin`. */
export type PluginsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'GITHUB_LINK_ASC'
  | 'GITHUB_LINK_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'LOGO_ASC'
  | 'LOGO_DESC'
  | 'SCREENSHOTS_ASC'
  | 'SCREENSHOTS_DESC'
  | 'LAST_UPDATED_ASC'
  | 'LAST_UPDATED_DESC'
  | 'PUBLISHER_NAME_ASC'
  | 'PUBLISHER_NAME_DESC'
  | 'AGREE_TERMS_ASC'
  | 'AGREE_TERMS_DESC'
  | 'PUBLISHER_EMAIL_ASC'
  | 'PUBLISHER_EMAIL_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Plugin` object types. All fields are tested for equality and combined with a logical and. */
export type PluginCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `githubLink` field. */
  githubLink?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `logo` field. */
  logo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `screenshots` field. */
  screenshots?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lastUpdated` field. */
  lastUpdated?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `publisherName` field. */
  publisherName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `agreeTerms` field. */
  agreeTerms?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `publisherEmail` field. */
  publisherEmail?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Poll` values. */
export type PollsConnection = {
  /** A list of `Poll` objects. */
  nodes: Array<Maybe<Poll>>;
  /** A list of edges which contains the `Poll` and cursor to aid in pagination. */
  edges: Array<PollsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Poll` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Poll = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  question?: Maybe<Scalars['String']>;
  response?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Poll` edge in the connection. */
export type PollsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Poll` at the end of the edge. */
  node?: Maybe<Poll>;
};

/** Methods to use when ordering `Poll`. */
export type PollsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'QUESTION_ASC'
  | 'QUESTION_DESC'
  | 'RESPONSE_ASC'
  | 'RESPONSE_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Poll` object types. All fields are tested for equality and combined with a logical and. */
export type PollCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `question` field. */
  question?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `response` field. */
  response?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `ProductType` values. */
export type ProductTypesConnection = {
  /** A list of `ProductType` objects. */
  nodes: Array<Maybe<ProductType>>;
  /** A list of edges which contains the `ProductType` and cursor to aid in pagination. */
  edges: Array<ProductTypesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ProductType` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ProductType = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  typeName?: Maybe<Scalars['String']>;
  taxes?: Maybe<Scalars['String']>;
  isShippable?: Maybe<Scalars['String']>;
  metaUrl?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  filterOptions?: Maybe<Scalars['String']>;
  productType?: Maybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: Maybe<Scalars['String']>;
};

/** A `ProductType` edge in the connection. */
export type ProductTypesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ProductType` at the end of the edge. */
  node?: Maybe<ProductType>;
};

/** Methods to use when ordering `ProductType`. */
export type ProductTypesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'TYPE_NAME_ASC'
  | 'TYPE_NAME_DESC'
  | 'TAXES_ASC'
  | 'TAXES_DESC'
  | 'IS_SHIPPABLE_ASC'
  | 'IS_SHIPPABLE_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'FILTER_OPTIONS_ASC'
  | 'FILTER_OPTIONS_DESC'
  | 'PRODUCT_TYPE_ASC'
  | 'PRODUCT_TYPE_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `ProductType` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type ProductTypeCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `typeName` field. */
  typeName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taxes` field. */
  taxes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isShippable` field. */
  isShippable?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `filterOptions` field. */
  filterOptions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `productType` field. */
  productType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Product` values. */
export type ProductsConnection = {
  /** A list of `Product` objects. */
  nodes: Array<Maybe<Product>>;
  /** A list of edges which contains the `Product` and cursor to aid in pagination. */
  edges: Array<ProductsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Product` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Product = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  sku: Scalars['BigInt'];
  thumbnail?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  price?: Maybe<Scalars['String']>;
  quantityPerSource?: Maybe<Scalars['String']>;
  salableQuantity?: Maybe<Scalars['String']>;
  visibility?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Boolean']>;
  websites?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  taxClass?: Maybe<Scalars['String']>;
  stockStatus?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  country?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['String']>;
  format?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  shortDescription?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  metaTitle?: Maybe<Scalars['String']>;
  metaKeywords?: Maybe<Scalars['String']>;
  metaDescription?: Maybe<Scalars['String']>;
  metaUrl?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
  manufacture?: Maybe<Scalars['String']>;
  attributes?: Maybe<Scalars['String']>;
  brand?: Maybe<Scalars['String']>;
  contract?: Maybe<Scalars['String']>;
  costString?: Maybe<Scalars['String']>;
  customerType?: Maybe<Scalars['String']>;
  family?: Maybe<Scalars['String']>;
  manufacturerPartNumber?: Maybe<Scalars['String']>;
  occassions?: Maybe<Scalars['String']>;
  partNumber?: Maybe<Scalars['String']>;
  relatedProduct?: Maybe<Scalars['BigInt']>;
  tags?: Maybe<Scalars['String']>;
  types?: Maybe<Scalars['String']>;
  variants?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
  brands?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  creditMemos?: Maybe<Scalars['String']>;
  manufacturer?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  occassionsOccassionsToproducts?: Maybe<Scalars['String']>;
  orders?: Maybe<Scalars['String']>;
  otherProducts?: Maybe<Scalars['String']>;
  productAttribute?: Maybe<Scalars['String']>;
  productTypes?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  quotes?: Maybe<Scalars['String']>;
  rating?: Maybe<Scalars['String']>;
  returns?: Maybe<Scalars['String']>;
  taxRate?: Maybe<Scalars['String']>;
  taxRule?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Product` edge in the connection. */
export type ProductsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Product` at the end of the edge. */
  node?: Maybe<Product>;
};

/** Methods to use when ordering `Product`. */
export type ProductsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'SKU_ASC'
  | 'SKU_DESC'
  | 'THUMBNAIL_ASC'
  | 'THUMBNAIL_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'PRICE_ASC'
  | 'PRICE_DESC'
  | 'QUANTITY_PER_SOURCE_ASC'
  | 'QUANTITY_PER_SOURCE_DESC'
  | 'SALABLE_QUANTITY_ASC'
  | 'SALABLE_QUANTITY_DESC'
  | 'VISIBILITY_ASC'
  | 'VISIBILITY_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'TAX_CLASS_ASC'
  | 'TAX_CLASS_DESC'
  | 'STOCK_STATUS_ASC'
  | 'STOCK_STATUS_DESC'
  | 'WEIGHT_ASC'
  | 'WEIGHT_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'SIZE_ASC'
  | 'SIZE_DESC'
  | 'FORMAT_ASC'
  | 'FORMAT_DESC'
  | 'HEIGHT_ASC'
  | 'HEIGHT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'SHORT_DESCRIPTION_ASC'
  | 'SHORT_DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'META_TITLE_ASC'
  | 'META_TITLE_DESC'
  | 'META_KEYWORDS_ASC'
  | 'META_KEYWORDS_DESC'
  | 'META_DESCRIPTION_ASC'
  | 'META_DESCRIPTION_DESC'
  | 'META_URL_ASC'
  | 'META_URL_DESC'
  | 'FILE_ASC'
  | 'FILE_DESC'
  | 'MANUFACTURE_ASC'
  | 'MANUFACTURE_DESC'
  | 'ATTRIBUTES_ASC'
  | 'ATTRIBUTES_DESC'
  | 'BRAND_ASC'
  | 'BRAND_DESC'
  | 'CONTRACT_ASC'
  | 'CONTRACT_DESC'
  | 'COST_STRING_ASC'
  | 'COST_STRING_DESC'
  | 'CUSTOMER_TYPE_ASC'
  | 'CUSTOMER_TYPE_DESC'
  | 'FAMILY_ASC'
  | 'FAMILY_DESC'
  | 'MANUFACTURER_PART_NUMBER_ASC'
  | 'MANUFACTURER_PART_NUMBER_DESC'
  | 'OCCASSIONS_ASC'
  | 'OCCASSIONS_DESC'
  | 'PART_NUMBER_ASC'
  | 'PART_NUMBER_DESC'
  | 'RELATED_PRODUCT_ASC'
  | 'RELATED_PRODUCT_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'TYPES_ASC'
  | 'TYPES_DESC'
  | 'VARIANTS_ASC'
  | 'VARIANTS_DESC'
  | 'ZONE_ASC'
  | 'ZONE_DESC'
  | 'BRANDS_ASC'
  | 'BRANDS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'CREDIT_MEMOS_ASC'
  | 'CREDIT_MEMOS_DESC'
  | 'MANUFACTURER_ASC'
  | 'MANUFACTURER_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'OCCASSIONS_OCCASSIONS_TOPRODUCTS_ASC'
  | 'OCCASSIONS_OCCASSIONS_TOPRODUCTS_DESC'
  | 'ORDERS_ASC'
  | 'ORDERS_DESC'
  | 'OTHER_PRODUCTS_ASC'
  | 'OTHER_PRODUCTS_DESC'
  | 'PRODUCT_ATTRIBUTE_ASC'
  | 'PRODUCT_ATTRIBUTE_DESC'
  | 'PRODUCT_TYPES_ASC'
  | 'PRODUCT_TYPES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'QUOTES_ASC'
  | 'QUOTES_DESC'
  | 'RATING_ASC'
  | 'RATING_DESC'
  | 'RETURNS_ASC'
  | 'RETURNS_DESC'
  | 'TAX_RATE_ASC'
  | 'TAX_RATE_DESC'
  | 'TAX_RULE_ASC'
  | 'TAX_RULE_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Product` object types. All fields are tested for equality and combined with a logical and. */
export type ProductCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `sku` field. */
  sku?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `thumbnail` field. */
  thumbnail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `price` field. */
  price?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `quantityPerSource` field. */
  quantityPerSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `salableQuantity` field. */
  salableQuantity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `visibility` field. */
  visibility?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taxClass` field. */
  taxClass?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `stockStatus` field. */
  stockStatus?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `weight` field. */
  weight?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `size` field. */
  size?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `format` field. */
  format?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `height` field. */
  height?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaTitle` field. */
  metaTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaKeywords` field. */
  metaKeywords?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaDescription` field. */
  metaDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `metaUrl` field. */
  metaUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `file` field. */
  file?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `manufacture` field. */
  manufacture?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `attributes` field. */
  attributes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `brand` field. */
  brand?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `contract` field. */
  contract?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `costString` field. */
  costString?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerType` field. */
  customerType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `family` field. */
  family?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `manufacturerPartNumber` field. */
  manufacturerPartNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `occassions` field. */
  occassions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `partNumber` field. */
  partNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `relatedProduct` field. */
  relatedProduct?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `types` field. */
  types?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `variants` field. */
  variants?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `zone` field. */
  zone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `brands` field. */
  brands?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `creditMemos` field. */
  creditMemos?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `manufacturer` field. */
  manufacturer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `occassionsOccassionsToproducts` field. */
  occassionsOccassionsToproducts?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `orders` field. */
  orders?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `otherProducts` field. */
  otherProducts?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `productAttribute` field. */
  productAttribute?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `productTypes` field. */
  productTypes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `quotes` field. */
  quotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `rating` field. */
  rating?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `returns` field. */
  returns?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taxRate` field. */
  taxRate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taxRule` field. */
  taxRule?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Project` values. */
export type ProjectsConnection = {
  /** A list of `Project` objects. */
  nodes: Array<Maybe<Project>>;
  /** A list of edges which contains the `Project` and cursor to aid in pagination. */
  edges: Array<ProjectsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Project` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Project = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  name?: Maybe<Scalars['String']>;
  projectManager?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  resource?: Maybe<Scalars['String']>;
  considerworkingdays?: Maybe<Scalars['String']>;
  projectTemplate?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  assignee?: Maybe<Scalars['String']>;
  custId?: Maybe<Scalars['Int']>;
  doing?: Maybe<Scalars['String']>;
  done?: Maybe<Scalars['String']>;
  goalCollaborators?: Maybe<Scalars['String']>;
  goalMeasurement?: Maybe<Scalars['String']>;
  goalName?: Maybe<Scalars['String']>;
  goalPrivacy?: Maybe<Scalars['String']>;
  goalProgressSource?: Maybe<Scalars['String']>;
  goalTimeperiod?: Maybe<Scalars['String']>;
  goalUpdatemethod?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  sectionRule?: Maybe<Scalars['String']>;
  staffId?: Maybe<Scalars['Int']>;
  taskId?: Maybe<Scalars['BigInt']>;
  ticketId?: Maybe<Scalars['BigInt']>;
  customers?: Maybe<Scalars['String']>;
  tasks?: Maybe<Scalars['String']>;
  ticketing?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  product?: Maybe<Scalars['String']>;
  websites?: Maybe<Scalars['String']>;
  method?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  team?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  company?: Maybe<Scalars['String']>;
  file?: Maybe<Scalars['String']>;
};

/** A `Project` edge in the connection. */
export type ProjectsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Project` at the end of the edge. */
  node?: Maybe<Project>;
};

/** Methods to use when ordering `Project`. */
export type ProjectsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'PROJECT_MANAGER_ASC'
  | 'PROJECT_MANAGER_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'RESOURCE_ASC'
  | 'RESOURCE_DESC'
  | 'CONSIDERWORKINGDAYS_ASC'
  | 'CONSIDERWORKINGDAYS_DESC'
  | 'PROJECT_TEMPLATE_ASC'
  | 'PROJECT_TEMPLATE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'ASSIGNEE_ASC'
  | 'ASSIGNEE_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'DOING_ASC'
  | 'DOING_DESC'
  | 'DONE_ASC'
  | 'DONE_DESC'
  | 'GOAL_COLLABORATORS_ASC'
  | 'GOAL_COLLABORATORS_DESC'
  | 'GOAL_MEASUREMENT_ASC'
  | 'GOAL_MEASUREMENT_DESC'
  | 'GOAL_NAME_ASC'
  | 'GOAL_NAME_DESC'
  | 'GOAL_PRIVACY_ASC'
  | 'GOAL_PRIVACY_DESC'
  | 'GOAL_PROGRESS_SOURCE_ASC'
  | 'GOAL_PROGRESS_SOURCE_DESC'
  | 'GOAL_TIMEPERIOD_ASC'
  | 'GOAL_TIMEPERIOD_DESC'
  | 'GOAL_UPDATEMETHOD_ASC'
  | 'GOAL_UPDATEMETHOD_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'SECTION_RULE_ASC'
  | 'SECTION_RULE_DESC'
  | 'STAFF_ID_ASC'
  | 'STAFF_ID_DESC'
  | 'TASK_ID_ASC'
  | 'TASK_ID_DESC'
  | 'TICKET_ID_ASC'
  | 'TICKET_ID_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'TASKS_ASC'
  | 'TASKS_DESC'
  | 'TICKETING_ASC'
  | 'TICKETING_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'METHOD_ASC'
  | 'METHOD_DESC'
  | 'ZONE_ASC'
  | 'ZONE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'TEAM_ASC'
  | 'TEAM_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'COMPANY_ASC'
  | 'COMPANY_DESC'
  | 'FILE_ASC'
  | 'FILE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical and. */
export type ProjectCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projectManager` field. */
  projectManager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `resource` field. */
  resource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `considerworkingdays` field. */
  considerworkingdays?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projectTemplate` field. */
  projectTemplate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `assignee` field. */
  assignee?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `doing` field. */
  doing?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `done` field. */
  done?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `goalCollaborators` field. */
  goalCollaborators?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `goalMeasurement` field. */
  goalMeasurement?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `goalName` field. */
  goalName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `goalPrivacy` field. */
  goalPrivacy?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `goalProgressSource` field. */
  goalProgressSource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `goalTimeperiod` field. */
  goalTimeperiod?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `goalUpdatemethod` field. */
  goalUpdatemethod?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `sectionRule` field. */
  sectionRule?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `staffId` field. */
  staffId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `taskId` field. */
  taskId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `ticketId` field. */
  ticketId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tasks` field. */
  tasks?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `ticketing` field. */
  ticketing?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `method` field. */
  method?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `zone` field. */
  zone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `team` field. */
  team?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `company` field. */
  company?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `file` field. */
  file?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Provider` values. */
export type ProvidersConnection = {
  /** A list of `Provider` objects. */
  nodes: Array<Maybe<Provider>>;
  /** A list of edges which contains the `Provider` and cursor to aid in pagination. */
  edges: Array<ProvidersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Provider` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Provider = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  hostUri?: Maybe<Scalars['String']>;
  redirectUrl?: Maybe<Scalars['String']>;
  redirectUrlApp?: Maybe<Scalars['String']>;
  icon?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  active?: Maybe<Scalars['String']>;
};

/** A `Provider` edge in the connection. */
export type ProvidersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Provider` at the end of the edge. */
  node?: Maybe<Provider>;
};

/** Methods to use when ordering `Provider`. */
export type ProvidersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'HOST_URI_ASC'
  | 'HOST_URI_DESC'
  | 'REDIRECT_URL_ASC'
  | 'REDIRECT_URL_DESC'
  | 'REDIRECT_URL_APP_ASC'
  | 'REDIRECT_URL_APP_DESC'
  | 'ICON_ASC'
  | 'ICON_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Provider` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type ProviderCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `hostUri` field. */
  hostUri?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `redirectUrl` field. */
  redirectUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `redirectUrlApp` field. */
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `icon` field. */
  icon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `active` field. */
  active?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Quote` values. */
export type QuotesConnection = {
  /** A list of `Quote` objects. */
  nodes: Array<Maybe<Quote>>;
  /** A list of edges which contains the `Quote` and cursor to aid in pagination. */
  edges: Array<QuotesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Quote` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Quote = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  grandTotal?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  categories?: Maybe<Scalars['String']>;
  validUntil?: Maybe<Scalars['String']>;
  quoteStage?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  orderId: Scalars['Int'];
  account?: Maybe<Scalars['String']>;
  approvalIssues?: Maybe<Scalars['String']>;
  approvalStatus?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  billingCity?: Maybe<Scalars['String']>;
  billingCountry?: Maybe<Scalars['String']>;
  billingPostal?: Maybe<Scalars['String']>;
  billingState?: Maybe<Scalars['String']>;
  billingStreet?: Maybe<Scalars['String']>;
  contact?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['String']>;
  invoiceStatus?: Maybe<Scalars['String']>;
  lineItemDiscount?: Maybe<Scalars['String']>;
  lineItemGroupTotal?: Maybe<Scalars['String']>;
  lineItemName?: Maybe<Scalars['String']>;
  lineItemSubtotal?: Maybe<Scalars['String']>;
  lineItemTax?: Maybe<Scalars['String']>;
  lineItemTotal?: Maybe<Scalars['String']>;
  paymentTerms?: Maybe<Scalars['String']>;
  shipping?: Maybe<Scalars['String']>;
  shippingCity?: Maybe<Scalars['String']>;
  shippingCountry?: Maybe<Scalars['String']>;
  shippingPostal?: Maybe<Scalars['String']>;
  shippingState?: Maybe<Scalars['String']>;
  shippingStreet?: Maybe<Scalars['String']>;
  shippingTax?: Maybe<Scalars['String']>;
  subtotal?: Maybe<Scalars['String']>;
  tax?: Maybe<Scalars['String']>;
  total?: Maybe<Scalars['String']>;
  customersCustomersToquotes?: Maybe<Scalars['String']>;
  orders?: Maybe<Scalars['String']>;
  productsProductsToquotes?: Maybe<Scalars['String']>;
};

/** A `Quote` edge in the connection. */
export type QuotesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Quote` at the end of the edge. */
  node?: Maybe<Quote>;
};

/** Methods to use when ordering `Quote`. */
export type QuotesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'GRAND_TOTAL_ASC'
  | 'GRAND_TOTAL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'VALID_UNTIL_ASC'
  | 'VALID_UNTIL_DESC'
  | 'QUOTE_STAGE_ASC'
  | 'QUOTE_STAGE_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'CUST_ID_ASC'
  | 'CUST_ID_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'ORDER_ID_ASC'
  | 'ORDER_ID_DESC'
  | 'ACCOUNT_ASC'
  | 'ACCOUNT_DESC'
  | 'APPROVAL_ISSUES_ASC'
  | 'APPROVAL_ISSUES_DESC'
  | 'APPROVAL_STATUS_ASC'
  | 'APPROVAL_STATUS_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'BILLING_CITY_ASC'
  | 'BILLING_CITY_DESC'
  | 'BILLING_COUNTRY_ASC'
  | 'BILLING_COUNTRY_DESC'
  | 'BILLING_POSTAL_ASC'
  | 'BILLING_POSTAL_DESC'
  | 'BILLING_STATE_ASC'
  | 'BILLING_STATE_DESC'
  | 'BILLING_STREET_ASC'
  | 'BILLING_STREET_DESC'
  | 'CONTACT_ASC'
  | 'CONTACT_DESC'
  | 'CURRENCY_ASC'
  | 'CURRENCY_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'INVOICE_STATUS_ASC'
  | 'INVOICE_STATUS_DESC'
  | 'LINE_ITEM_DISCOUNT_ASC'
  | 'LINE_ITEM_DISCOUNT_DESC'
  | 'LINE_ITEM_GROUP_TOTAL_ASC'
  | 'LINE_ITEM_GROUP_TOTAL_DESC'
  | 'LINE_ITEM_NAME_ASC'
  | 'LINE_ITEM_NAME_DESC'
  | 'LINE_ITEM_SUBTOTAL_ASC'
  | 'LINE_ITEM_SUBTOTAL_DESC'
  | 'LINE_ITEM_TAX_ASC'
  | 'LINE_ITEM_TAX_DESC'
  | 'LINE_ITEM_TOTAL_ASC'
  | 'LINE_ITEM_TOTAL_DESC'
  | 'PAYMENT_TERMS_ASC'
  | 'PAYMENT_TERMS_DESC'
  | 'SHIPPING_ASC'
  | 'SHIPPING_DESC'
  | 'SHIPPING_CITY_ASC'
  | 'SHIPPING_CITY_DESC'
  | 'SHIPPING_COUNTRY_ASC'
  | 'SHIPPING_COUNTRY_DESC'
  | 'SHIPPING_POSTAL_ASC'
  | 'SHIPPING_POSTAL_DESC'
  | 'SHIPPING_STATE_ASC'
  | 'SHIPPING_STATE_DESC'
  | 'SHIPPING_STREET_ASC'
  | 'SHIPPING_STREET_DESC'
  | 'SHIPPING_TAX_ASC'
  | 'SHIPPING_TAX_DESC'
  | 'SUBTOTAL_ASC'
  | 'SUBTOTAL_DESC'
  | 'TAX_ASC'
  | 'TAX_DESC'
  | 'TOTAL_ASC'
  | 'TOTAL_DESC'
  | 'CUSTOMERS_CUSTOMERS_TOQUOTES_ASC'
  | 'CUSTOMERS_CUSTOMERS_TOQUOTES_DESC'
  | 'ORDERS_ASC'
  | 'ORDERS_DESC'
  | 'PRODUCTS_PRODUCTS_TOQUOTES_ASC'
  | 'PRODUCTS_PRODUCTS_TOQUOTES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Quote` object types. All fields are tested for equality and combined with a logical and. */
export type QuoteCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `grandTotal` field. */
  grandTotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `validUntil` field. */
  validUntil?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `quoteStage` field. */
  quoteStage?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `custId` field. */
  custId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `orderId` field. */
  orderId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `account` field. */
  account?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `approvalIssues` field. */
  approvalIssues?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `approvalStatus` field. */
  approvalStatus?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `billingCity` field. */
  billingCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `billingCountry` field. */
  billingCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `billingPostal` field. */
  billingPostal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `billingState` field. */
  billingState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `billingStreet` field. */
  billingStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `contact` field. */
  contact?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `currency` field. */
  currency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `discount` field. */
  discount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `invoiceStatus` field. */
  invoiceStatus?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lineItemDiscount` field. */
  lineItemDiscount?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lineItemGroupTotal` field. */
  lineItemGroupTotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lineItemName` field. */
  lineItemName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lineItemSubtotal` field. */
  lineItemSubtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lineItemTax` field. */
  lineItemTax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lineItemTotal` field. */
  lineItemTotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `paymentTerms` field. */
  paymentTerms?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shipping` field. */
  shipping?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingCity` field. */
  shippingCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingCountry` field. */
  shippingCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingPostal` field. */
  shippingPostal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingState` field. */
  shippingState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingStreet` field. */
  shippingStreet?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingTax` field. */
  shippingTax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `subtotal` field. */
  subtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tax` field. */
  tax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `total` field. */
  total?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customersCustomersToquotes` field. */
  customersCustomersToquotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `orders` field. */
  orders?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `productsProductsToquotes` field. */
  productsProductsToquotes?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Rating` values. */
export type RatingsConnection = {
  /** A list of `Rating` objects. */
  nodes: Array<Maybe<Rating>>;
  /** A list of edges which contains the `Rating` and cursor to aid in pagination. */
  edges: Array<RatingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Rating` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Rating = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  defaultValue?: Maybe<Scalars['String']>;
  defaultStoreView?: Maybe<Scalars['String']>;
  ratingVisibility?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  sortOrder?: Maybe<Scalars['BigFloat']>;
  prodId: Scalars['BigInt'];
  products?: Maybe<Scalars['String']>;
};

/** A `Rating` edge in the connection. */
export type RatingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Rating` at the end of the edge. */
  node?: Maybe<Rating>;
};

/** Methods to use when ordering `Rating`. */
export type RatingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'DEFAULT_VALUE_ASC'
  | 'DEFAULT_VALUE_DESC'
  | 'DEFAULT_STORE_VIEW_ASC'
  | 'DEFAULT_STORE_VIEW_DESC'
  | 'RATING_VISIBILITY_ASC'
  | 'RATING_VISIBILITY_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'SORT_ORDER_ASC'
  | 'SORT_ORDER_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Rating` object types. All fields are tested for equality and combined with a logical and. */
export type RatingCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `defaultValue` field. */
  defaultValue?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `defaultStoreView` field. */
  defaultStoreView?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `ratingVisibility` field. */
  ratingVisibility?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `active` field. */
  active?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `sortOrder` field. */
  sortOrder?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Report` values. */
export type ReportsConnection = {
  /** A list of `Report` objects. */
  nodes: Array<Maybe<Report>>;
  /** A list of edges which contains the `Report` and cursor to aid in pagination. */
  edges: Array<ReportsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Report` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Report = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  customer?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['BigFloat']>;
  subtotal?: Maybe<Scalars['String']>;
  appliedCoupon?: Maybe<Scalars['String']>;
  created?: Maybe<Scalars['Datetime']>;
  updated?: Maybe<Scalars['Datetime']>;
  ipAddress?: Maybe<Scalars['String']>;
};

/** A `Report` edge in the connection. */
export type ReportsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Report` at the end of the edge. */
  node?: Maybe<Report>;
};

/** Methods to use when ordering `Report`. */
export type ReportsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CUSTOMER_ASC'
  | 'CUSTOMER_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'QUANTITY_ASC'
  | 'QUANTITY_DESC'
  | 'SUBTOTAL_ASC'
  | 'SUBTOTAL_DESC'
  | 'APPLIED_COUPON_ASC'
  | 'APPLIED_COUPON_DESC'
  | 'CREATED_ASC'
  | 'CREATED_DESC'
  | 'UPDATED_ASC'
  | 'UPDATED_DESC'
  | 'IP_ADDRESS_ASC'
  | 'IP_ADDRESS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Report` object types. All fields are tested for equality and combined with a logical and. */
export type ReportCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `customer` field. */
  customer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `quantity` field. */
  quantity?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `subtotal` field. */
  subtotal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `appliedCoupon` field. */
  appliedCoupon?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `updated` field. */
  updated?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `ipAddress` field. */
  ipAddress?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Return` values. */
export type ReturnsConnection = {
  /** A list of `Return` objects. */
  nodes: Array<Maybe<Return>>;
  /** A list of edges which contains the `Return` and cursor to aid in pagination. */
  edges: Array<ReturnsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Return` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Return = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  validity?: Maybe<Scalars['String']>;
  returnPrefix?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  shippingNumber?: Maybe<Scalars['String']>;
  shippingDescription?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  liquidationReason?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  weight?: Maybe<Scalars['String']>;
  height?: Maybe<Scalars['String']>;
  howShipped?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  shipTo?: Maybe<Scalars['String']>;
  caseId?: Maybe<Scalars['String']>;
};

/** A `Return` edge in the connection. */
export type ReturnsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Return` at the end of the edge. */
  node?: Maybe<Return>;
};

/** Methods to use when ordering `Return`. */
export type ReturnsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'VALIDITY_ASC'
  | 'VALIDITY_DESC'
  | 'RETURN_PREFIX_ASC'
  | 'RETURN_PREFIX_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'SHIPPING_NUMBER_ASC'
  | 'SHIPPING_NUMBER_DESC'
  | 'SHIPPING_DESCRIPTION_ASC'
  | 'SHIPPING_DESCRIPTION_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'LIQUIDATION_REASON_ASC'
  | 'LIQUIDATION_REASON_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'WEIGHT_ASC'
  | 'WEIGHT_DESC'
  | 'HEIGHT_ASC'
  | 'HEIGHT_DESC'
  | 'HOW_SHIPPED_ASC'
  | 'HOW_SHIPPED_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'SHIP_TO_ASC'
  | 'SHIP_TO_DESC'
  | 'CASE_ID_ASC'
  | 'CASE_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Return` object types. All fields are tested for equality and combined with a logical and. */
export type ReturnCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `validity` field. */
  validity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `returnPrefix` field. */
  returnPrefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingNumber` field. */
  shippingNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shippingDescription` field. */
  shippingDescription?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `liquidationReason` field. */
  liquidationReason?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `weight` field. */
  weight?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `height` field. */
  height?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `howShipped` field. */
  howShipped?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shipTo` field. */
  shipTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `caseId` field. */
  caseId?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Review` values. */
export type ReviewsConnection = {
  /** A list of `Review` objects. */
  nodes: Array<Maybe<Review>>;
  /** A list of edges which contains the `Review` and cursor to aid in pagination. */
  edges: Array<ReviewsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Review` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Review = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  websites?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  shopId: Scalars['Int'];
  commentId: Scalars['Int'];
};

/** A `Review` edge in the connection. */
export type ReviewsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Review` at the end of the edge. */
  node?: Maybe<Review>;
};

/** Methods to use when ordering `Review`. */
export type ReviewsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'SHOP_ID_ASC'
  | 'SHOP_ID_DESC'
  | 'COMMENT_ID_ASC'
  | 'COMMENT_ID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Review` object types. All fields are tested for equality and combined with a logical and. */
export type ReviewCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `shopId` field. */
  shopId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `commentId` field. */
  commentId?: InputMaybe<Scalars['Int']>;
};

/** A connection to a list of `Reward` values. */
export type RewardsConnection = {
  /** A list of `Reward` objects. */
  nodes: Array<Maybe<Reward>>;
  /** A list of edges which contains the `Reward` and cursor to aid in pagination. */
  edges: Array<RewardsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Reward` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Reward = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  slug?: Maybe<Scalars['String']>;
  level?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  coupons?: Maybe<Scalars['String']>;
  expiration?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Reward` edge in the connection. */
export type RewardsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Reward` at the end of the edge. */
  node?: Maybe<Reward>;
};

/** Methods to use when ordering `Reward`. */
export type RewardsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'SLUG_ASC'
  | 'SLUG_DESC'
  | 'LEVEL_ASC'
  | 'LEVEL_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Reward` object types. All fields are tested for equality and combined with a logical and. */
export type RewardCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `slug` field. */
  slug?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `level` field. */
  level?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `expiration` field. */
  expiration?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Role` values. */
export type RolesConnection = {
  /** A list of `Role` objects. */
  nodes: Array<Maybe<Role>>;
  /** A list of edges which contains the `Role` and cursor to aid in pagination. */
  edges: Array<RolesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Role` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Role = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  roleName: Scalars['String'];
  content?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** A `Role` edge in the connection. */
export type RolesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Role` at the end of the edge. */
  node?: Maybe<Role>;
};

/** Methods to use when ordering `Role`. */
export type RolesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'ROLE_NAME_ASC'
  | 'ROLE_NAME_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical and. */
export type RoleCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `roleName` field. */
  roleName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `Scheduler` values. */
export type SchedulersConnection = {
  /** A list of `Scheduler` objects. */
  nodes: Array<Maybe<Scheduler>>;
  /** A list of edges which contains the `Scheduler` and cursor to aid in pagination. */
  edges: Array<SchedulersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Scheduler` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Scheduler = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  endDate?: Maybe<Scalars['String']>;
  level?: Maybe<Scalars['String']>;
  login?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  whid?: Maybe<Scalars['String']>;
};

/** A `Scheduler` edge in the connection. */
export type SchedulersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Scheduler` at the end of the edge. */
  node?: Maybe<Scheduler>;
};

/** Methods to use when ordering `Scheduler`. */
export type SchedulersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'LEVEL_ASC'
  | 'LEVEL_DESC'
  | 'LOGIN_ASC'
  | 'LOGIN_DESC'
  | 'NOTES_ASC'
  | 'NOTES_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'WHID_ASC'
  | 'WHID_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Scheduler` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type SchedulerCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `level` field. */
  level?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `login` field. */
  login?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `notes` field. */
  notes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `whid` field. */
  whid?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Segment` values. */
export type SegmentsConnection = {
  /** A list of `Segment` objects. */
  nodes: Array<Maybe<Segment>>;
  /** A list of edges which contains the `Segment` and cursor to aid in pagination. */
  edges: Array<SegmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Segment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Segment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  applyTo?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
};

/** A `Segment` edge in the connection. */
export type SegmentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Segment` at the end of the edge. */
  node?: Maybe<Segment>;
};

/** Methods to use when ordering `Segment`. */
export type SegmentsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'APPLY_TO_ASC'
  | 'APPLY_TO_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Segment` object types. All fields are tested for equality and combined with a logical and. */
export type SegmentCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `applyTo` field. */
  applyTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Setting` values. */
export type SettingsConnection = {
  /** A list of `Setting` objects. */
  nodes: Array<Maybe<Setting>>;
  /** A list of edges which contains the `Setting` and cursor to aid in pagination. */
  edges: Array<SettingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Setting` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Setting = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  storeName?: Maybe<Scalars['String']>;
  storePhone?: Maybe<Scalars['String']>;
  storeHours?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  zipcode?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  addressTwo?: Maybe<Scalars['String']>;
  vatNumber?: Maybe<Scalars['String']>;
  allowState?: Maybe<Scalars['String']>;
  stateRequiredFor?: Maybe<Scalars['String']>;
  allowCountries?: Maybe<Scalars['String']>;
  defaultCountry?: Maybe<Scalars['String']>;
  optionalZip?: Maybe<Scalars['String']>;
  europeanUnionCountries?: Maybe<Scalars['String']>;
  topDestinations?: Maybe<Scalars['String']>;
  baseCurrency?: Maybe<Scalars['String']>;
  defaultCurrency?: Maybe<Scalars['String']>;
  allowedCurrency?: Maybe<Scalars['String']>;
  siteName?: Maybe<Scalars['String']>;
  siteWebsite?: Maybe<Scalars['String']>;
  sentryDsn?: Maybe<Scalars['String']>;
  awsS3?: Maybe<Scalars['String']>;
  databaseUrl?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  googleAnalytics?: Maybe<Scalars['String']>;
  searchSetting?: Maybe<Scalars['String']>;
  mailServer?: Maybe<Scalars['String']>;
  youtubeVideos?: Maybe<Scalars['String']>;
  siteTagline?: Maybe<Scalars['String']>;
  googleDrive?: Maybe<Scalars['String']>;
  disqusKey?: Maybe<Scalars['String']>;
};

/** A `Setting` edge in the connection. */
export type SettingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Setting` at the end of the edge. */
  node?: Maybe<Setting>;
};

/** Methods to use when ordering `Setting`. */
export type SettingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'STORE_NAME_ASC'
  | 'STORE_NAME_DESC'
  | 'STORE_PHONE_ASC'
  | 'STORE_PHONE_DESC'
  | 'STORE_HOURS_ASC'
  | 'STORE_HOURS_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'REGION_ASC'
  | 'REGION_DESC'
  | 'ZIPCODE_ASC'
  | 'ZIPCODE_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'ADDRESS_TWO_ASC'
  | 'ADDRESS_TWO_DESC'
  | 'VAT_NUMBER_ASC'
  | 'VAT_NUMBER_DESC'
  | 'ALLOW_STATE_ASC'
  | 'ALLOW_STATE_DESC'
  | 'STATE_REQUIRED_FOR_ASC'
  | 'STATE_REQUIRED_FOR_DESC'
  | 'ALLOW_COUNTRIES_ASC'
  | 'ALLOW_COUNTRIES_DESC'
  | 'DEFAULT_COUNTRY_ASC'
  | 'DEFAULT_COUNTRY_DESC'
  | 'OPTIONAL_ZIP_ASC'
  | 'OPTIONAL_ZIP_DESC'
  | 'EUROPEAN_UNION_COUNTRIES_ASC'
  | 'EUROPEAN_UNION_COUNTRIES_DESC'
  | 'TOP_DESTINATIONS_ASC'
  | 'TOP_DESTINATIONS_DESC'
  | 'BASE_CURRENCY_ASC'
  | 'BASE_CURRENCY_DESC'
  | 'DEFAULT_CURRENCY_ASC'
  | 'DEFAULT_CURRENCY_DESC'
  | 'ALLOWED_CURRENCY_ASC'
  | 'ALLOWED_CURRENCY_DESC'
  | 'SITE_NAME_ASC'
  | 'SITE_NAME_DESC'
  | 'SITE_WEBSITE_ASC'
  | 'SITE_WEBSITE_DESC'
  | 'SENTRY_DSN_ASC'
  | 'SENTRY_DSN_DESC'
  | 'AWS_S3_ASC'
  | 'AWS_S3_DESC'
  | 'DATABASE_URL_ASC'
  | 'DATABASE_URL_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'GOOGLE_ANALYTICS_ASC'
  | 'GOOGLE_ANALYTICS_DESC'
  | 'SEARCH_SETTING_ASC'
  | 'SEARCH_SETTING_DESC'
  | 'MAIL_SERVER_ASC'
  | 'MAIL_SERVER_DESC'
  | 'YOUTUBE_VIDEOS_ASC'
  | 'YOUTUBE_VIDEOS_DESC'
  | 'SITE_TAGLINE_ASC'
  | 'SITE_TAGLINE_DESC'
  | 'GOOGLE_DRIVE_ASC'
  | 'GOOGLE_DRIVE_DESC'
  | 'DISQUS_KEY_ASC'
  | 'DISQUS_KEY_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical and. */
export type SettingCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `storeName` field. */
  storeName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `storePhone` field. */
  storePhone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `storeHours` field. */
  storeHours?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `region` field. */
  region?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `zipcode` field. */
  zipcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `addressTwo` field. */
  addressTwo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `vatNumber` field. */
  vatNumber?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `allowState` field. */
  allowState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `stateRequiredFor` field. */
  stateRequiredFor?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `allowCountries` field. */
  allowCountries?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `defaultCountry` field. */
  defaultCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `optionalZip` field. */
  optionalZip?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `europeanUnionCountries` field. */
  europeanUnionCountries?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `topDestinations` field. */
  topDestinations?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `baseCurrency` field. */
  baseCurrency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `defaultCurrency` field. */
  defaultCurrency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `allowedCurrency` field. */
  allowedCurrency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `siteName` field. */
  siteName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `siteWebsite` field. */
  siteWebsite?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `sentryDsn` field. */
  sentryDsn?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `awsS3` field. */
  awsS3?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `databaseUrl` field. */
  databaseUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `googleAnalytics` field. */
  googleAnalytics?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `searchSetting` field. */
  searchSetting?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mailServer` field. */
  mailServer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `youtubeVideos` field. */
  youtubeVideos?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `siteTagline` field. */
  siteTagline?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `googleDrive` field. */
  googleDrive?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `disqusKey` field. */
  disqusKey?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Shipment` values. */
export type ShipmentsConnection = {
  /** A list of `Shipment` objects. */
  nodes: Array<Maybe<Shipment>>;
  /** A list of edges which contains the `Shipment` and cursor to aid in pagination. */
  edges: Array<ShipmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Shipment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Shipment = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  product?: Maybe<Scalars['String']>;
  speedGrade?: Maybe<Scalars['String']>;
  shipDate?: Maybe<Scalars['Datetime']>;
  carrierName: Scalars['String'];
  transitTime?: Maybe<Scalars['String']>;
  trackingUrl?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  id: Scalars['BigInt'];
  clientId?: Maybe<Scalars['String']>;
  clientSecret?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
};

/** A `Shipment` edge in the connection. */
export type ShipmentsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Shipment` at the end of the edge. */
  node?: Maybe<Shipment>;
};

/** Methods to use when ordering `Shipment`. */
export type ShipmentsOrderBy =
  | 'NATURAL'
  | 'PRODUCT_ASC'
  | 'PRODUCT_DESC'
  | 'SPEED_GRADE_ASC'
  | 'SPEED_GRADE_DESC'
  | 'SHIP_DATE_ASC'
  | 'SHIP_DATE_DESC'
  | 'CARRIER_NAME_ASC'
  | 'CARRIER_NAME_DESC'
  | 'TRANSIT_TIME_ASC'
  | 'TRANSIT_TIME_DESC'
  | 'TRACKING_URL_ASC'
  | 'TRACKING_URL_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CLIENT_ID_ASC'
  | 'CLIENT_ID_DESC'
  | 'CLIENT_SECRET_ASC'
  | 'CLIENT_SECRET_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Shipment` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type ShipmentCondition = {
  /** Checks for equality with the objects `product` field. */
  product?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `speedGrade` field. */
  speedGrade?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shipDate` field. */
  shipDate?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `carrierName` field. */
  carrierName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `transitTime` field. */
  transitTime?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `trackingUrl` field. */
  trackingUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `clientId` field. */
  clientId?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `clientSecret` field. */
  clientSecret?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `SpecialDiscount` values. */
export type SpecialDiscountsConnection = {
  /** A list of `SpecialDiscount` objects. */
  nodes: Array<Maybe<SpecialDiscount>>;
  /** A list of edges which contains the `SpecialDiscount` and cursor to aid in pagination. */
  edges: Array<SpecialDiscountsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SpecialDiscount` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type SpecialDiscount = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  discount?: Maybe<Scalars['BigFloat']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  rewards?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  expiration?: Maybe<Scalars['Date']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `SpecialDiscount` edge in the connection. */
export type SpecialDiscountsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `SpecialDiscount` at the end of the edge. */
  node?: Maybe<SpecialDiscount>;
};

/** Methods to use when ordering `SpecialDiscount`. */
export type SpecialDiscountsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DISCOUNT_ASC'
  | 'DISCOUNT_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'REWARDS_ASC'
  | 'REWARDS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `SpecialDiscount` object types. All fields are
 * tested for equality and combined with a logical and.
 */
export type SpecialDiscountCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `discount` field. */
  discount?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `rewards` field. */
  rewards?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `expiration` field. */
  expiration?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `State` values. */
export type StatesConnection = {
  /** A list of `State` objects. */
  nodes: Array<Maybe<State>>;
  /** A list of edges which contains the `State` and cursor to aid in pagination. */
  edges: Array<StatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `State` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type State = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  trainings?: Maybe<Scalars['String']>;
};

/** A `State` edge in the connection. */
export type StatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `State` at the end of the edge. */
  node?: Maybe<State>;
};

/** Methods to use when ordering `State`. */
export type StatesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'TRAININGS_ASC'
  | 'TRAININGS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `State` object types. All fields are tested for equality and combined with a logical and. */
export type StateCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `trainings` field. */
  trainings?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Statistic` values. */
export type StatisticsConnection = {
  /** A list of `Statistic` objects. */
  nodes: Array<Maybe<Statistic>>;
  /** A list of edges which contains the `Statistic` and cursor to aid in pagination. */
  edges: Array<StatisticsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Statistic` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Statistic = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  published?: Maybe<Scalars['Datetime']>;
  specialOffers?: Maybe<Scalars['String']>;
  reports?: Maybe<Scalars['String']>;
  rewards?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  expiration?: Maybe<Scalars['Date']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Statistic` edge in the connection. */
export type StatisticsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Statistic` at the end of the edge. */
  node?: Maybe<Statistic>;
};

/** Methods to use when ordering `Statistic`. */
export type StatisticsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PUBLISHED_ASC'
  | 'PUBLISHED_DESC'
  | 'SPECIAL_OFFERS_ASC'
  | 'SPECIAL_OFFERS_DESC'
  | 'REPORTS_ASC'
  | 'REPORTS_DESC'
  | 'REWARDS_ASC'
  | 'REWARDS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'EXPIRATION_ASC'
  | 'EXPIRATION_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Statistic` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type StatisticCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `published` field. */
  published?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `specialOffers` field. */
  specialOffers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `reports` field. */
  reports?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `rewards` field. */
  rewards?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `expiration` field. */
  expiration?: InputMaybe<Scalars['Date']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Stock` values. */
export type StocksConnection = {
  /** A list of `Stock` objects. */
  nodes: Array<Maybe<Stock>>;
  /** A list of edges which contains the `Stock` and cursor to aid in pagination. */
  edges: Array<StocksEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Stock` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Stock = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  enabled?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  sources?: Maybe<Scalars['String']>;
};

/** A `Stock` edge in the connection. */
export type StocksEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Stock` at the end of the edge. */
  node?: Maybe<Stock>;
};

/** Methods to use when ordering `Stock`. */
export type StocksOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ENABLED_ASC'
  | 'ENABLED_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'SOURCES_ASC'
  | 'SOURCES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Stock` object types. All fields are tested for equality and combined with a logical and. */
export type StockCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `enabled` field. */
  enabled?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `sources` field. */
  sources?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Survey` values. */
export type SurveysConnection = {
  /** A list of `Survey` objects. */
  nodes: Array<Maybe<Survey>>;
  /** A list of edges which contains the `Survey` and cursor to aid in pagination. */
  edges: Array<SurveysEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Survey` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Survey = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  question?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  submitText?: Maybe<Scalars['String']>;
  satisfiedText?: Maybe<Scalars['String']>;
  neitherText?: Maybe<Scalars['String']>;
  dissatisfiedText?: Maybe<Scalars['String']>;
};

/** A `Survey` edge in the connection. */
export type SurveysEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Survey` at the end of the edge. */
  node?: Maybe<Survey>;
};

/** Methods to use when ordering `Survey`. */
export type SurveysOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'QUESTION_ASC'
  | 'QUESTION_DESC'
  | 'ANSWER_ASC'
  | 'ANSWER_DESC'
  | 'SUBMIT_TEXT_ASC'
  | 'SUBMIT_TEXT_DESC'
  | 'SATISFIED_TEXT_ASC'
  | 'SATISFIED_TEXT_DESC'
  | 'NEITHER_TEXT_ASC'
  | 'NEITHER_TEXT_DESC'
  | 'DISSATISFIED_TEXT_ASC'
  | 'DISSATISFIED_TEXT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Survey` object types. All fields are tested for equality and combined with a logical and. */
export type SurveyCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `question` field. */
  question?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `answer` field. */
  answer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `submitText` field. */
  submitText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `satisfiedText` field. */
  satisfiedText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `neitherText` field. */
  neitherText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `dissatisfiedText` field. */
  dissatisfiedText?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Tag` values. */
export type TagsConnection = {
  /** A list of `Tag` objects. */
  nodes: Array<Maybe<Tag>>;
  /** A list of edges which contains the `Tag` and cursor to aid in pagination. */
  edges: Array<TagsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Tag` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Tag = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  excerpt?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
};

/** A `Tag` edge in the connection. */
export type TagsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Tag` at the end of the edge. */
  node?: Maybe<Tag>;
};

/** Methods to use when ordering `Tag`. */
export type TagsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'EXCERPT_ASC'
  | 'EXCERPT_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical and. */
export type TagCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `excerpt` field. */
  excerpt?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Target` values. */
export type TargetsConnection = {
  /** A list of `Target` objects. */
  nodes: Array<Maybe<Target>>;
  /** A list of edges which contains the `Target` and cursor to aid in pagination. */
  edges: Array<TargetsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Target` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Target = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  prefix?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  department?: Maybe<Scalars['String']>;
  accountName?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  postalcode?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  fax?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  mobile?: Maybe<Scalars['String']>;
  jobTitle?: Maybe<Scalars['String']>;
  altAddress?: Maybe<Scalars['String']>;
  altPostalcode?: Maybe<Scalars['String']>;
  altCity?: Maybe<Scalars['String']>;
  altState?: Maybe<Scalars['String']>;
  altCountry?: Maybe<Scalars['String']>;
  officePhone?: Maybe<Scalars['String']>;
  customerName?: Maybe<Scalars['String']>;
  emailOptOut?: Maybe<Scalars['String']>;
  donotcall?: Maybe<Scalars['String']>;
};

/** A `Target` edge in the connection. */
export type TargetsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Target` at the end of the edge. */
  node?: Maybe<Target>;
};

/** Methods to use when ordering `Target`. */
export type TargetsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'PREFIX_ASC'
  | 'PREFIX_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'DEPARTMENT_ASC'
  | 'DEPARTMENT_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'POSTALCODE_ASC'
  | 'POSTALCODE_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'FAX_ASC'
  | 'FAX_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'MOBILE_ASC'
  | 'MOBILE_DESC'
  | 'JOB_TITLE_ASC'
  | 'JOB_TITLE_DESC'
  | 'ALT_ADDRESS_ASC'
  | 'ALT_ADDRESS_DESC'
  | 'ALT_POSTALCODE_ASC'
  | 'ALT_POSTALCODE_DESC'
  | 'ALT_CITY_ASC'
  | 'ALT_CITY_DESC'
  | 'ALT_STATE_ASC'
  | 'ALT_STATE_DESC'
  | 'ALT_COUNTRY_ASC'
  | 'ALT_COUNTRY_DESC'
  | 'OFFICE_PHONE_ASC'
  | 'OFFICE_PHONE_DESC'
  | 'CUSTOMER_NAME_ASC'
  | 'CUSTOMER_NAME_DESC'
  | 'EMAIL_OPT_OUT_ASC'
  | 'EMAIL_OPT_OUT_DESC'
  | 'DONOTCALL_ASC'
  | 'DONOTCALL_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Target` object types. All fields are tested for equality and combined with a logical and. */
export type TargetCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `prefix` field. */
  prefix?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `department` field. */
  department?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `postalcode` field. */
  postalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `fax` field. */
  fax?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mobile` field. */
  mobile?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `jobTitle` field. */
  jobTitle?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altAddress` field. */
  altAddress?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altPostalcode` field. */
  altPostalcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altCity` field. */
  altCity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altState` field. */
  altState?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `altCountry` field. */
  altCountry?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `officePhone` field. */
  officePhone?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerName` field. */
  customerName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `emailOptOut` field. */
  emailOptOut?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `donotcall` field. */
  donotcall?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `TaxCategory` values. */
export type TaxCategoriesConnection = {
  /** A list of `TaxCategory` objects. */
  nodes: Array<Maybe<TaxCategory>>;
  /** A list of edges which contains the `TaxCategory` and cursor to aid in pagination. */
  edges: Array<TaxCategoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TaxCategory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TaxCategory = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  default?: Maybe<Scalars['String']>;
};

/** A `TaxCategory` edge in the connection. */
export type TaxCategoriesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TaxCategory` at the end of the edge. */
  node?: Maybe<TaxCategory>;
};

/** Methods to use when ordering `TaxCategory`. */
export type TaxCategoriesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DEFAULT_ASC'
  | 'DEFAULT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `TaxCategory` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type TaxCategoryCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `default` field. */
  default?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `TaxRate` values. */
export type TaxRatesConnection = {
  /** A list of `TaxRate` objects. */
  nodes: Array<Maybe<TaxRate>>;
  /** A list of edges which contains the `TaxRate` and cursor to aid in pagination. */
  edges: Array<TaxRatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TaxRate` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TaxRate = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  taxIdentifier: Scalars['String'];
  zipPostIsRange?: Maybe<Scalars['Boolean']>;
  postcode?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  ratePercent?: Maybe<Scalars['String']>;
  defaultStoreView?: Maybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: Maybe<Scalars['String']>;
};

/** A `TaxRate` edge in the connection. */
export type TaxRatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TaxRate` at the end of the edge. */
  node?: Maybe<TaxRate>;
};

/** Methods to use when ordering `TaxRate`. */
export type TaxRatesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'TAX_IDENTIFIER_ASC'
  | 'TAX_IDENTIFIER_DESC'
  | 'ZIP_POST_IS_RANGE_ASC'
  | 'ZIP_POST_IS_RANGE_DESC'
  | 'POSTCODE_ASC'
  | 'POSTCODE_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'RATE_PERCENT_ASC'
  | 'RATE_PERCENT_DESC'
  | 'DEFAULT_STORE_VIEW_ASC'
  | 'DEFAULT_STORE_VIEW_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `TaxRate` object types. All fields are tested for equality and combined with a logical and. */
export type TaxRateCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `taxIdentifier` field. */
  taxIdentifier?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `zipPostIsRange` field. */
  zipPostIsRange?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `postcode` field. */
  postcode?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `ratePercent` field. */
  ratePercent?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `defaultStoreView` field. */
  defaultStoreView?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `TaxRule` values. */
export type TaxRulesConnection = {
  /** A list of `TaxRule` objects. */
  nodes: Array<Maybe<TaxRule>>;
  /** A list of edges which contains the `TaxRule` and cursor to aid in pagination. */
  edges: Array<TaxRulesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TaxRule` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TaxRule = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  taxRate?: Maybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: Maybe<Scalars['String']>;
};

/** A `TaxRule` edge in the connection. */
export type TaxRulesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TaxRule` at the end of the edge. */
  node?: Maybe<TaxRule>;
};

/** Methods to use when ordering `TaxRule`. */
export type TaxRulesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'TAX_RATE_ASC'
  | 'TAX_RATE_DESC'
  | 'PROD_ID_ASC'
  | 'PROD_ID_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `TaxRule` object types. All fields are tested for equality and combined with a logical and. */
export type TaxRuleCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `taxRate` field. */
  taxRate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `prodId` field. */
  prodId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Template` values. */
export type TemplatesConnection = {
  /** A list of `Template` objects. */
  nodes: Array<Maybe<Template>>;
  /** A list of edges which contains the `Template` and cursor to aid in pagination. */
  edges: Array<TemplatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Template` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Template = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['String']>;
  pageSize?: Maybe<Scalars['String']>;
  orientation?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  header?: Maybe<Scalars['String']>;
  footer?: Maybe<Scalars['String']>;
  marginLeft?: Maybe<Scalars['String']>;
  marginRight?: Maybe<Scalars['String']>;
  marginTop?: Maybe<Scalars['String']>;
  marginBottom?: Maybe<Scalars['String']>;
  marginHeader?: Maybe<Scalars['String']>;
  marginFooter?: Maybe<Scalars['String']>;
};

/** A `Template` edge in the connection. */
export type TemplatesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Template` at the end of the edge. */
  node?: Maybe<Template>;
};

/** Methods to use when ordering `Template`. */
export type TemplatesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'ACTIVE_ASC'
  | 'ACTIVE_DESC'
  | 'PAGE_SIZE_ASC'
  | 'PAGE_SIZE_DESC'
  | 'ORIENTATION_ASC'
  | 'ORIENTATION_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'HEADER_ASC'
  | 'HEADER_DESC'
  | 'FOOTER_ASC'
  | 'FOOTER_DESC'
  | 'MARGIN_LEFT_ASC'
  | 'MARGIN_LEFT_DESC'
  | 'MARGIN_RIGHT_ASC'
  | 'MARGIN_RIGHT_DESC'
  | 'MARGIN_TOP_ASC'
  | 'MARGIN_TOP_DESC'
  | 'MARGIN_BOTTOM_ASC'
  | 'MARGIN_BOTTOM_DESC'
  | 'MARGIN_HEADER_ASC'
  | 'MARGIN_HEADER_DESC'
  | 'MARGIN_FOOTER_ASC'
  | 'MARGIN_FOOTER_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Template` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type TemplateCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `active` field. */
  active?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `pageSize` field. */
  pageSize?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `orientation` field. */
  orientation?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `header` field. */
  header?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `footer` field. */
  footer?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `marginLeft` field. */
  marginLeft?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `marginRight` field. */
  marginRight?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `marginTop` field. */
  marginTop?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `marginBottom` field. */
  marginBottom?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `marginHeader` field. */
  marginHeader?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `marginFooter` field. */
  marginFooter?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Theme` values. */
export type ThemesConnection = {
  /** A list of `Theme` objects. */
  nodes: Array<Maybe<Theme>>;
  /** A list of edges which contains the `Theme` and cursor to aid in pagination. */
  edges: Array<ThemesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Theme` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Theme = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  title?: Maybe<Scalars['String']>;
  parentTheme?: Maybe<Scalars['String']>;
  themePath?: Maybe<Scalars['String']>;
  action?: Maybe<Scalars['String']>;
  websiteId: Scalars['BigInt'];
  websites: Scalars['String'];
};

/** A `Theme` edge in the connection. */
export type ThemesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Theme` at the end of the edge. */
  node?: Maybe<Theme>;
};

/** Methods to use when ordering `Theme`. */
export type ThemesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'TITLE_ASC'
  | 'TITLE_DESC'
  | 'PARENT_THEME_ASC'
  | 'PARENT_THEME_DESC'
  | 'THEME_PATH_ASC'
  | 'THEME_PATH_DESC'
  | 'ACTION_ASC'
  | 'ACTION_DESC'
  | 'WEBSITE_ID_ASC'
  | 'WEBSITE_ID_DESC'
  | 'WEBSITES_ASC'
  | 'WEBSITES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Theme` object types. All fields are tested for equality and combined with a logical and. */
export type ThemeCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `title` field. */
  title?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `parentTheme` field. */
  parentTheme?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `themePath` field. */
  themePath?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `action` field. */
  action?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `websiteId` field. */
  websiteId?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `websites` field. */
  websites?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Ticketing` values. */
export type TicketingsConnection = {
  /** A list of `Ticketing` objects. */
  nodes: Array<Maybe<Ticketing>>;
  /** A list of edges which contains the `Ticketing` and cursor to aid in pagination. */
  edges: Array<TicketingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Ticketing` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Ticketing = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  date?: Maybe<Scalars['String']>;
  severity?: Maybe<Scalars['String']>;
  team?: Maybe<Scalars['String']>;
  requester?: Maybe<Scalars['String']>;
  requesterEmail?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  department?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  ticketType?: Maybe<Scalars['String']>;
  comment?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  priority?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  resolution?: Maybe<Scalars['String']>;
  assignedTo?: Maybe<Scalars['String']>;
  dateModified?: Maybe<Scalars['Datetime']>;
  accountName?: Maybe<Scalars['String']>;
  level?: Maybe<Scalars['String']>;
  projectsProjectsToticketing?: Maybe<Scalars['String']>;
};

/** A `Ticketing` edge in the connection. */
export type TicketingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Ticketing` at the end of the edge. */
  node?: Maybe<Ticketing>;
};

/** Methods to use when ordering `Ticketing`. */
export type TicketingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'DATE_ASC'
  | 'DATE_DESC'
  | 'SEVERITY_ASC'
  | 'SEVERITY_DESC'
  | 'TEAM_ASC'
  | 'TEAM_DESC'
  | 'REQUESTER_ASC'
  | 'REQUESTER_DESC'
  | 'REQUESTER_EMAIL_ASC'
  | 'REQUESTER_EMAIL_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'DEPARTMENT_ASC'
  | 'DEPARTMENT_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'TICKET_TYPE_ASC'
  | 'TICKET_TYPE_DESC'
  | 'COMMENT_ASC'
  | 'COMMENT_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'PRIORITY_ASC'
  | 'PRIORITY_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'RESOLUTION_ASC'
  | 'RESOLUTION_DESC'
  | 'ASSIGNED_TO_ASC'
  | 'ASSIGNED_TO_DESC'
  | 'DATE_MODIFIED_ASC'
  | 'DATE_MODIFIED_DESC'
  | 'ACCOUNT_NAME_ASC'
  | 'ACCOUNT_NAME_DESC'
  | 'LEVEL_ASC'
  | 'LEVEL_DESC'
  | 'PROJECTS_PROJECTS_TOTICKETING_ASC'
  | 'PROJECTS_PROJECTS_TOTICKETING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Ticketing` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type TicketingCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `date` field. */
  date?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `severity` field. */
  severity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `team` field. */
  team?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `requester` field. */
  requester?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `requesterEmail` field. */
  requesterEmail?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `department` field. */
  department?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `ticketType` field. */
  ticketType?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `comment` field. */
  comment?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `priority` field. */
  priority?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `resolution` field. */
  resolution?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignedTo` field. */
  assignedTo?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `dateModified` field. */
  dateModified?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `accountName` field. */
  accountName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `level` field. */
  level?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projectsProjectsToticketing` field. */
  projectsProjectsToticketing?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Training` values. */
export type TrainingsConnection = {
  /** A list of `Training` objects. */
  nodes: Array<Maybe<Training>>;
  /** A list of edges which contains the `Training` and cursor to aid in pagination. */
  edges: Array<TrainingsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Training` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Training = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  subject?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  link?: Maybe<Scalars['String']>;
  steps?: Maybe<Scalars['String']>;
  updated?: Maybe<Scalars['Datetime']>;
  analytics?: Maybe<Scalars['String']>;
  competency?: Maybe<Scalars['String']>;
  course?: Maybe<Scalars['String']>;
  grade?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  comment?: Maybe<Scalars['Int']>;
  address?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['Int']>;
  state?: Maybe<Scalars['Int']>;
  postal?: Maybe<Scalars['String']>;
  teacher?: Maybe<Scalars['String']>;
  student?: Maybe<Scalars['String']>;
  announcement?: Maybe<Scalars['String']>;
  resource?: Maybe<Scalars['String']>;
  badges?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
  isCompleted?: Maybe<Scalars['String']>;
  speakers?: Maybe<Scalars['String']>;
  fieldTrips?: Maybe<Scalars['String']>;
  assignments?: Maybe<Scalars['String']>;
  assignmentsDueDate?: Maybe<Scalars['String']>;
  origanalityReport?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['BigInt']>;
  faqs?: Maybe<Scalars['String']>;
  languages?: Maybe<Scalars['String']>;
  checklists?: Maybe<Scalars['BigInt']>;
  city?: Maybe<Scalars['String']>;
  meetups?: Maybe<Scalars['String']>;
  lab?: Maybe<Scalars['String']>;
  digiboards?: Maybe<Scalars['String']>;
  countries?: Maybe<Scalars['String']>;
  states?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** A `Training` edge in the connection. */
export type TrainingsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Training` at the end of the edge. */
  node?: Maybe<Training>;
};

/** Methods to use when ordering `Training`. */
export type TrainingsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'SUBJECT_ASC'
  | 'SUBJECT_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'LINK_ASC'
  | 'LINK_DESC'
  | 'STEPS_ASC'
  | 'STEPS_DESC'
  | 'UPDATED_ASC'
  | 'UPDATED_DESC'
  | 'ANALYTICS_ASC'
  | 'ANALYTICS_DESC'
  | 'COMPETENCY_ASC'
  | 'COMPETENCY_DESC'
  | 'COURSE_ASC'
  | 'COURSE_DESC'
  | 'GRADE_ASC'
  | 'GRADE_DESC'
  | 'SCHOOL_ASC'
  | 'SCHOOL_DESC'
  | 'COMMENT_ASC'
  | 'COMMENT_DESC'
  | 'ADDRESS_ASC'
  | 'ADDRESS_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'POSTAL_ASC'
  | 'POSTAL_DESC'
  | 'TEACHER_ASC'
  | 'TEACHER_DESC'
  | 'STUDENT_ASC'
  | 'STUDENT_DESC'
  | 'ANNOUNCEMENT_ASC'
  | 'ANNOUNCEMENT_DESC'
  | 'RESOURCE_ASC'
  | 'RESOURCE_DESC'
  | 'BADGES_ASC'
  | 'BADGES_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'IS_COMPLETED_ASC'
  | 'IS_COMPLETED_DESC'
  | 'SPEAKERS_ASC'
  | 'SPEAKERS_DESC'
  | 'FIELD_TRIPS_ASC'
  | 'FIELD_TRIPS_DESC'
  | 'ASSIGNMENTS_ASC'
  | 'ASSIGNMENTS_DESC'
  | 'ASSIGNMENTS_DUE_DATE_ASC'
  | 'ASSIGNMENTS_DUE_DATE_DESC'
  | 'ORIGANALITY_REPORT_ASC'
  | 'ORIGANALITY_REPORT_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'FAQS_ASC'
  | 'FAQS_DESC'
  | 'LANGUAGES_ASC'
  | 'LANGUAGES_DESC'
  | 'CHECKLISTS_ASC'
  | 'CHECKLISTS_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'MEETUPS_ASC'
  | 'MEETUPS_DESC'
  | 'LAB_ASC'
  | 'LAB_DESC'
  | 'DIGIBOARDS_ASC'
  | 'DIGIBOARDS_DESC'
  | 'COUNTRIES_ASC'
  | 'COUNTRIES_DESC'
  | 'STATES_ASC'
  | 'STATES_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Training` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type TrainingCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `subject` field. */
  subject?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `link` field. */
  link?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `steps` field. */
  steps?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `updated` field. */
  updated?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `analytics` field. */
  analytics?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `competency` field. */
  competency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `course` field. */
  course?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `grade` field. */
  grade?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `school` field. */
  school?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `comment` field. */
  comment?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `address` field. */
  address?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `postal` field. */
  postal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `teacher` field. */
  teacher?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `student` field. */
  student?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `announcement` field. */
  announcement?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `resource` field. */
  resource?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `badges` field. */
  badges?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isCompleted` field. */
  isCompleted?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `speakers` field. */
  speakers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `fieldTrips` field. */
  fieldTrips?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignments` field. */
  assignments?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `assignmentsDueDate` field. */
  assignmentsDueDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `origanalityReport` field. */
  origanalityReport?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `faqs` field. */
  faqs?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `languages` field. */
  languages?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `checklists` field. */
  checklists?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `meetups` field. */
  meetups?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lab` field. */
  lab?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `digiboards` field. */
  digiboards?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `countries` field. */
  countries?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `states` field. */
  states?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Transaction` values. */
export type TransactionsConnection = {
  /** A list of `Transaction` objects. */
  nodes: Array<Maybe<Transaction>>;
  /** A list of edges which contains the `Transaction` and cursor to aid in pagination. */
  edges: Array<TransactionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Transaction` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Transaction = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  orderId: Scalars['Int'];
  transactionId: Scalars['Int'];
  parentTransactionId: Scalars['Int'];
  created?: Maybe<Scalars['Datetime']>;
  paymentMethod: Scalars['BigInt'];
  closed?: Maybe<Scalars['String']>;
  customerPayment?: Maybe<Scalars['String']>;
  orders?: Maybe<Scalars['String']>;
};

/** A `Transaction` edge in the connection. */
export type TransactionsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Transaction` at the end of the edge. */
  node?: Maybe<Transaction>;
};

/** Methods to use when ordering `Transaction`. */
export type TransactionsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'ORDER_ID_ASC'
  | 'ORDER_ID_DESC'
  | 'TRANSACTION_ID_ASC'
  | 'TRANSACTION_ID_DESC'
  | 'PARENT_TRANSACTION_ID_ASC'
  | 'PARENT_TRANSACTION_ID_DESC'
  | 'CREATED_ASC'
  | 'CREATED_DESC'
  | 'PAYMENT_METHOD_ASC'
  | 'PAYMENT_METHOD_DESC'
  | 'CLOSED_ASC'
  | 'CLOSED_DESC'
  | 'CUSTOMER_PAYMENT_ASC'
  | 'CUSTOMER_PAYMENT_DESC'
  | 'ORDERS_ASC'
  | 'ORDERS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Transaction` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type TransactionCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `orderId` field. */
  orderId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `transactionId` field. */
  transactionId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `parentTransactionId` field. */
  parentTransactionId?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `created` field. */
  created?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `paymentMethod` field. */
  paymentMethod?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `closed` field. */
  closed?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customerPayment` field. */
  customerPayment?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `orders` field. */
  orders?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `UploadFile` values. */
export type UploadFilesConnection = {
  /** A list of `UploadFile` objects. */
  nodes: Array<Maybe<UploadFile>>;
  /** A list of edges which contains the `UploadFile` and cursor to aid in pagination. */
  edges: Array<UploadFilesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UploadFile` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type UploadFile = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  alternativeText?: Maybe<Scalars['String']>;
  caption?: Maybe<Scalars['String']>;
  width?: Maybe<Scalars['Int']>;
  height?: Maybe<Scalars['Int']>;
  formats?: Maybe<Scalars['JSON']>;
  hash: Scalars['String'];
  ext?: Maybe<Scalars['String']>;
  mime: Scalars['String'];
  size: Scalars['BigFloat'];
  url: Scalars['String'];
  previewUrl?: Maybe<Scalars['String']>;
  provider: Scalars['String'];
  providerMetadata?: Maybe<Scalars['JSON']>;
  createdBy?: Maybe<Scalars['Int']>;
  updatedBy?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
};

/** A `UploadFile` edge in the connection. */
export type UploadFilesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UploadFile` at the end of the edge. */
  node?: Maybe<UploadFile>;
};

/** Methods to use when ordering `UploadFile`. */
export type UploadFilesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'ALTERNATIVE_TEXT_ASC'
  | 'ALTERNATIVE_TEXT_DESC'
  | 'CAPTION_ASC'
  | 'CAPTION_DESC'
  | 'WIDTH_ASC'
  | 'WIDTH_DESC'
  | 'HEIGHT_ASC'
  | 'HEIGHT_DESC'
  | 'FORMATS_ASC'
  | 'FORMATS_DESC'
  | 'HASH_ASC'
  | 'HASH_DESC'
  | 'EXT_ASC'
  | 'EXT_DESC'
  | 'MIME_ASC'
  | 'MIME_DESC'
  | 'SIZE_ASC'
  | 'SIZE_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'PREVIEW_URL_ASC'
  | 'PREVIEW_URL_DESC'
  | 'PROVIDER_ASC'
  | 'PROVIDER_DESC'
  | 'PROVIDER_METADATA_ASC'
  | 'PROVIDER_METADATA_DESC'
  | 'CREATED_BY_ASC'
  | 'CREATED_BY_DESC'
  | 'UPDATED_BY_ASC'
  | 'UPDATED_BY_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `UploadFile` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type UploadFileCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `alternativeText` field. */
  alternativeText?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `caption` field. */
  caption?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `width` field. */
  width?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `height` field. */
  height?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `formats` field. */
  formats?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the objects `hash` field. */
  hash?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `ext` field. */
  ext?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mime` field. */
  mime?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `size` field. */
  size?: InputMaybe<Scalars['BigFloat']>;
  /** Checks for equality with the objects `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `previewUrl` field. */
  previewUrl?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `provider` field. */
  provider?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `providerMetadata` field. */
  providerMetadata?: InputMaybe<Scalars['JSON']>;
  /** Checks for equality with the objects `createdBy` field. */
  createdBy?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `updatedBy` field. */
  updatedBy?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type User = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  username: Scalars['String'];
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
  interfaceLocale?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
  permissions?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
  emails?: Maybe<Scalars['String']>;
  mediamanager?: Maybe<Scalars['String']>;
  messages?: Maybe<Scalars['String']>;
  projects?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export type UsersOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC'
  | 'FIRST_NAME_ASC'
  | 'FIRST_NAME_DESC'
  | 'LAST_NAME_ASC'
  | 'LAST_NAME_DESC'
  | 'EMAIL_ASC'
  | 'EMAIL_DESC'
  | 'PASSWORD_ASC'
  | 'PASSWORD_DESC'
  | 'INTERFACE_LOCALE_ASC'
  | 'INTERFACE_LOCALE_DESC'
  | 'VALUE_ASC'
  | 'VALUE_DESC'
  | 'PERMISSIONS_ASC'
  | 'PERMISSIONS_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'EMAILS_ASC'
  | 'EMAILS_DESC'
  | 'MEDIAMANAGER_ASC'
  | 'MEDIAMANAGER_DESC'
  | 'MESSAGES_ASC'
  | 'MESSAGES_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and. */
export type UserCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `username` field. */
  username?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `firstName` field. */
  firstName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `lastName` field. */
  lastName?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `email` field. */
  email?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `password` field. */
  password?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `interfaceLocale` field. */
  interfaceLocale?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `value` field. */
  value?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `permissions` field. */
  permissions?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `emails` field. */
  emails?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `mediamanager` field. */
  mediamanager?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `messages` field. */
  messages?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projects` field. */
  projects?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Vendor` values. */
export type VendorsConnection = {
  /** A list of `Vendor` objects. */
  nodes: Array<Maybe<Vendor>>;
  /** A list of edges which contains the `Vendor` and cursor to aid in pagination. */
  edges: Array<VendorsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Vendor` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Vendor = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  website?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  articles?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  coupons?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  polls?: Maybe<Scalars['String']>;
  quotes?: Maybe<Scalars['String']>;
  reviews?: Maybe<Scalars['String']>;
  giftCertificates?: Maybe<Scalars['String']>;
  rating?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  users?: Maybe<Scalars['String']>;
  invoices?: Maybe<Scalars['String']>;
  reports?: Maybe<Scalars['String']>;
  rewardPoints?: Maybe<Scalars['String']>;
  specialDiscounts?: Maybe<Scalars['String']>;
  statistics?: Maybe<Scalars['String']>;
  stocks?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  physicalStore?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  workspaces?: Maybe<Scalars['String']>;
};

/** A `Vendor` edge in the connection. */
export type VendorsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Vendor` at the end of the edge. */
  node?: Maybe<Vendor>;
};

/** Methods to use when ordering `Vendor`. */
export type VendorsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'WEBSITE_ASC'
  | 'WEBSITE_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'ARTICLES_ASC'
  | 'ARTICLES_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'COMMENTS_ASC'
  | 'COMMENTS_DESC'
  | 'COUPONS_ASC'
  | 'COUPONS_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'POLLS_ASC'
  | 'POLLS_DESC'
  | 'QUOTES_ASC'
  | 'QUOTES_DESC'
  | 'REVIEWS_ASC'
  | 'REVIEWS_DESC'
  | 'GIFT_CERTIFICATES_ASC'
  | 'GIFT_CERTIFICATES_DESC'
  | 'RATING_ASC'
  | 'RATING_DESC'
  | 'TAGS_ASC'
  | 'TAGS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'INVOICES_ASC'
  | 'INVOICES_DESC'
  | 'REPORTS_ASC'
  | 'REPORTS_DESC'
  | 'REWARD_POINTS_ASC'
  | 'REWARD_POINTS_DESC'
  | 'SPECIAL_DISCOUNTS_ASC'
  | 'SPECIAL_DISCOUNTS_DESC'
  | 'STATISTICS_ASC'
  | 'STATISTICS_DESC'
  | 'STOCKS_ASC'
  | 'STOCKS_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'PHYSICAL_STORE_ASC'
  | 'PHYSICAL_STORE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'WORKSPACES_ASC'
  | 'WORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Vendor` object types. All fields are tested for equality and combined with a logical and. */
export type VendorCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `website` field. */
  website?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `articles` field. */
  articles?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `comments` field. */
  comments?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `coupons` field. */
  coupons?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `polls` field. */
  polls?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `quotes` field. */
  quotes?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `reviews` field. */
  reviews?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `giftCertificates` field. */
  giftCertificates?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `rating` field. */
  rating?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tags` field. */
  tags?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `invoices` field. */
  invoices?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `reports` field. */
  reports?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `rewardPoints` field. */
  rewardPoints?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `specialDiscounts` field. */
  specialDiscounts?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `statistics` field. */
  statistics?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `stocks` field. */
  stocks?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `physicalStore` field. */
  physicalStore?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `workspaces` field. */
  workspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Visit` values. */
export type VisitsConnection = {
  /** A list of `Visit` objects. */
  nodes: Array<Maybe<Visit>>;
  /** A list of edges which contains the `Visit` and cursor to aid in pagination. */
  edges: Array<VisitsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Visit` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Visit = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  location?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  reason?: Maybe<Scalars['String']>;
  content?: Maybe<Scalars['String']>;
  emergency?: Maybe<Scalars['String']>;
  startDate?: Maybe<Scalars['String']>;
  endDate?: Maybe<Scalars['String']>;
  task?: Maybe<Scalars['String']>;
  meeting?: Maybe<Scalars['String']>;
};

/** A `Visit` edge in the connection. */
export type VisitsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Visit` at the end of the edge. */
  node?: Maybe<Visit>;
};

/** Methods to use when ordering `Visit`. */
export type VisitsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'LOCATION_ASC'
  | 'LOCATION_DESC'
  | 'USERNAME_ASC'
  | 'USERNAME_DESC'
  | 'REASON_ASC'
  | 'REASON_DESC'
  | 'CONTENT_ASC'
  | 'CONTENT_DESC'
  | 'EMERGENCY_ASC'
  | 'EMERGENCY_DESC'
  | 'START_DATE_ASC'
  | 'START_DATE_DESC'
  | 'END_DATE_ASC'
  | 'END_DATE_DESC'
  | 'TASK_ASC'
  | 'TASK_DESC'
  | 'MEETING_ASC'
  | 'MEETING_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Visit` object types. All fields are tested for equality and combined with a logical and. */
export type VisitCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `location` field. */
  location?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `username` field. */
  username?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `reason` field. */
  reason?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `content` field. */
  content?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `emergency` field. */
  emergency?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `startDate` field. */
  startDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `endDate` field. */
  endDate?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `task` field. */
  task?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `meeting` field. */
  meeting?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Warehouse` values. */
export type WarehousesConnection = {
  /** A list of `Warehouse` objects. */
  nodes: Array<Maybe<Warehouse>>;
  /** A list of edges which contains the `Warehouse` and cursor to aid in pagination. */
  edges: Array<WarehousesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Warehouse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Warehouse = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  postal?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  image?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  isPublic?: Maybe<Scalars['String']>;
};

/** A `Warehouse` edge in the connection. */
export type WarehousesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Warehouse` at the end of the edge. */
  node?: Maybe<Warehouse>;
};

/** Methods to use when ordering `Warehouse`. */
export type WarehousesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'CITY_ASC'
  | 'CITY_DESC'
  | 'STATE_ASC'
  | 'STATE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'POSTAL_ASC'
  | 'POSTAL_DESC'
  | 'STATUS_ASC'
  | 'STATUS_DESC'
  | 'IMAGE_ASC'
  | 'IMAGE_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Warehouse` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type WarehouseCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `city` field. */
  city?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `state` field. */
  state?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `postal` field. */
  postal?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `status` field. */
  status?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `image` field. */
  image?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Webhook` values. */
export type WebhooksConnection = {
  /** A list of `Webhook` objects. */
  nodes: Array<Maybe<Webhook>>;
  /** A list of edges which contains the `Webhook` and cursor to aid in pagination. */
  edges: Array<WebhooksEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Webhook` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Webhook = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name: Scalars['String'];
  url: Scalars['String'];
  headers?: Maybe<Scalars['String']>;
  create?: Maybe<Scalars['String']>;
  retrieve?: Maybe<Scalars['String']>;
  update?: Maybe<Scalars['String']>;
  delete?: Maybe<Scalars['String']>;
  publish?: Maybe<Scalars['String']>;
  unpublish?: Maybe<Scalars['String']>;
};

/** A `Webhook` edge in the connection. */
export type WebhooksEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Webhook` at the end of the edge. */
  node?: Maybe<Webhook>;
};

/** Methods to use when ordering `Webhook`. */
export type WebhooksOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'HEADERS_ASC'
  | 'HEADERS_DESC'
  | 'CREATE_ASC'
  | 'CREATE_DESC'
  | 'RETRIEVE_ASC'
  | 'RETRIEVE_DESC'
  | 'UPDATE_ASC'
  | 'UPDATE_DESC'
  | 'DELETE_ASC'
  | 'DELETE_DESC'
  | 'PUBLISH_ASC'
  | 'PUBLISH_DESC'
  | 'UNPUBLISH_ASC'
  | 'UNPUBLISH_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Webhook` object types. All fields are tested for equality and combined with a logical and. */
export type WebhookCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `headers` field. */
  headers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `create` field. */
  create?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `retrieve` field. */
  retrieve?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `update` field. */
  update?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `delete` field. */
  delete?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `publish` field. */
  publish?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `unpublish` field. */
  unpublish?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Website` values. */
export type WebsitesConnection = {
  /** A list of `Website` objects. */
  nodes: Array<Maybe<Website>>;
  /** A list of edges which contains the `Website` and cursor to aid in pagination. */
  edges: Array<WebsitesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Website` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Website = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  shop?: Maybe<Scalars['String']>;
  store?: Maybe<Scalars['String']>;
  category?: Maybe<Scalars['String']>;
  themes: Scalars['String'];
};

/** A `Website` edge in the connection. */
export type WebsitesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Website` at the end of the edge. */
  node?: Maybe<Website>;
};

/** Methods to use when ordering `Website`. */
export type WebsitesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'URL_ASC'
  | 'URL_DESC'
  | 'SHOP_ASC'
  | 'SHOP_DESC'
  | 'STORE_ASC'
  | 'STORE_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'THEMES_ASC'
  | 'THEMES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Website` object types. All fields are tested for equality and combined with a logical and. */
export type WebsiteCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `url` field. */
  url?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shop` field. */
  shop?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `store` field. */
  store?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `category` field. */
  category?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `themes` field. */
  themes?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Wishlist` values. */
export type WishlistsConnection = {
  /** A list of `Wishlist` objects. */
  nodes: Array<Maybe<Wishlist>>;
  /** A list of edges which contains the `Wishlist` and cursor to aid in pagination. */
  edges: Array<WishlistsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Wishlist` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Wishlist = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['String']>;
  visibility?: Maybe<Scalars['String']>;
  products?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['String']>;
  occassions?: Maybe<Scalars['String']>;
};

/** A `Wishlist` edge in the connection. */
export type WishlistsEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Wishlist` at the end of the edge. */
  node?: Maybe<Wishlist>;
};

/** Methods to use when ordering `Wishlist`. */
export type WishlistsOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'VISIBILITY_ASC'
  | 'VISIBILITY_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'QUANTITY_ASC'
  | 'QUANTITY_DESC'
  | 'OCCASSIONS_ASC'
  | 'OCCASSIONS_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Wishlist` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type WishlistCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `visibility` field. */
  visibility?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `quantity` field. */
  quantity?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `occassions` field. */
  occassions?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Workspace` values. */
export type WorkspacesConnection = {
  /** A list of `Workspace` objects. */
  nodes: Array<Maybe<Workspace>>;
  /** A list of edges which contains the `Workspace` and cursor to aid in pagination. */
  edges: Array<WorkspacesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Workspace` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Workspace = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  customers?: Maybe<Scalars['Int']>;
  users?: Maybe<Scalars['Int']>;
  products?: Maybe<Scalars['BigInt']>;
  tasks?: Maybe<Scalars['BigInt']>;
  brands?: Maybe<Scalars['BigInt']>;
  shops?: Maybe<Scalars['Int']>;
  category?: Maybe<Scalars['Int']>;
  isPublic?: Maybe<Scalars['Boolean']>;
  projects?: Maybe<Scalars['BigInt']>;
  author?: Maybe<Scalars['String']>;
  media?: Maybe<Scalars['String']>;
  brandsBrandsToworkspaces?: Maybe<Scalars['String']>;
  categories?: Maybe<Scalars['String']>;
  customersCustomersToworkspaces?: Maybe<Scalars['String']>;
  productsProductsToworkspaces?: Maybe<Scalars['String']>;
  projectsProjectsToworkspaces?: Maybe<Scalars['String']>;
  shopsShopsToworkspaces?: Maybe<Scalars['String']>;
  tasksTasksToworkspaces?: Maybe<Scalars['String']>;
  usersUsersToworkspaces?: Maybe<Scalars['String']>;
};

/** A `Workspace` edge in the connection. */
export type WorkspacesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Workspace` at the end of the edge. */
  node?: Maybe<Workspace>;
};

/** Methods to use when ordering `Workspace`. */
export type WorkspacesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'DESCRIPTION_ASC'
  | 'DESCRIPTION_DESC'
  | 'CUSTOMERS_ASC'
  | 'CUSTOMERS_DESC'
  | 'USERS_ASC'
  | 'USERS_DESC'
  | 'PRODUCTS_ASC'
  | 'PRODUCTS_DESC'
  | 'TASKS_ASC'
  | 'TASKS_DESC'
  | 'BRANDS_ASC'
  | 'BRANDS_DESC'
  | 'SHOPS_ASC'
  | 'SHOPS_DESC'
  | 'CATEGORY_ASC'
  | 'CATEGORY_DESC'
  | 'IS_PUBLIC_ASC'
  | 'IS_PUBLIC_DESC'
  | 'PROJECTS_ASC'
  | 'PROJECTS_DESC'
  | 'AUTHOR_ASC'
  | 'AUTHOR_DESC'
  | 'MEDIA_ASC'
  | 'MEDIA_DESC'
  | 'BRANDS_BRANDS_TOWORKSPACES_ASC'
  | 'BRANDS_BRANDS_TOWORKSPACES_DESC'
  | 'CATEGORIES_ASC'
  | 'CATEGORIES_DESC'
  | 'CUSTOMERS_CUSTOMERS_TOWORKSPACES_ASC'
  | 'CUSTOMERS_CUSTOMERS_TOWORKSPACES_DESC'
  | 'PRODUCTS_PRODUCTS_TOWORKSPACES_ASC'
  | 'PRODUCTS_PRODUCTS_TOWORKSPACES_DESC'
  | 'PROJECTS_PROJECTS_TOWORKSPACES_ASC'
  | 'PROJECTS_PROJECTS_TOWORKSPACES_DESC'
  | 'SHOPS_SHOPS_TOWORKSPACES_ASC'
  | 'SHOPS_SHOPS_TOWORKSPACES_DESC'
  | 'TASKS_TASKS_TOWORKSPACES_ASC'
  | 'TASKS_TASKS_TOWORKSPACES_DESC'
  | 'USERS_USERS_TOWORKSPACES_ASC'
  | 'USERS_USERS_TOWORKSPACES_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/**
 * A condition to be used against `Workspace` object types. All fields are tested
 * for equality and combined with a logical and.
 */
export type WorkspaceCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `code` field. */
  code?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `description` field. */
  description?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customers` field. */
  customers?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `users` field. */
  users?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `products` field. */
  products?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `tasks` field. */
  tasks?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `brands` field. */
  brands?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `shops` field. */
  shops?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `category` field. */
  category?: InputMaybe<Scalars['Int']>;
  /** Checks for equality with the objects `isPublic` field. */
  isPublic?: InputMaybe<Scalars['Boolean']>;
  /** Checks for equality with the objects `projects` field. */
  projects?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `author` field. */
  author?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `media` field. */
  media?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `brandsBrandsToworkspaces` field. */
  brandsBrandsToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `categories` field. */
  categories?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `customersCustomersToworkspaces` field. */
  customersCustomersToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `productsProductsToworkspaces` field. */
  productsProductsToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `projectsProjectsToworkspaces` field. */
  projectsProjectsToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `shopsShopsToworkspaces` field. */
  shopsShopsToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `tasksTasksToworkspaces` field. */
  tasksTasksToworkspaces?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `usersUsersToworkspaces` field. */
  usersUsersToworkspaces?: InputMaybe<Scalars['String']>;
};

/** A connection to a list of `Zone` values. */
export type ZonesConnection = {
  /** A list of `Zone` objects. */
  nodes: Array<Maybe<Zone>>;
  /** A list of edges which contains the `Zone` and cursor to aid in pagination. */
  edges: Array<ZonesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Zone` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type Zone = Node & {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['BigInt'];
  createdAt?: Maybe<Scalars['Datetime']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['Datetime']>;
  scope?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
};

/** A `Zone` edge in the connection. */
export type ZonesEdge = {
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Zone` at the end of the edge. */
  node?: Maybe<Zone>;
};

/** Methods to use when ordering `Zone`. */
export type ZonesOrderBy =
  | 'NATURAL'
  | 'ID_ASC'
  | 'ID_DESC'
  | 'CREATED_AT_ASC'
  | 'CREATED_AT_DESC'
  | 'NAME_ASC'
  | 'NAME_DESC'
  | 'UPDATED_AT_ASC'
  | 'UPDATED_AT_DESC'
  | 'SCOPE_ASC'
  | 'SCOPE_DESC'
  | 'TYPE_ASC'
  | 'TYPE_DESC'
  | 'COUNTRY_ASC'
  | 'COUNTRY_DESC'
  | 'CODE_ASC'
  | 'CODE_DESC'
  | 'PRIMARY_KEY_ASC'
  | 'PRIMARY_KEY_DESC';

/** A condition to be used against `Zone` object types. All fields are tested for equality and combined with a logical and. */
export type ZoneCondition = {
  /** Checks for equality with the objects `id` field. */
  id?: InputMaybe<Scalars['BigInt']>;
  /** Checks for equality with the objects `createdAt` field. */
  createdAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `name` field. */
  name?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `updatedAt` field. */
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  /** Checks for equality with the objects `scope` field. */
  scope?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `type` field. */
  type?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `country` field. */
  country?: InputMaybe<Scalars['String']>;
  /** Checks for equality with the objects `code` field. */
  code?: InputMaybe<Scalars['String']>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  /** Creates a single `Account`. */
  createAccount?: Maybe<CreateAccountPayload>;
  /** Creates a single `Agreement`. */
  createAgreement?: Maybe<CreateAgreementPayload>;
  /** Creates a single `Analytic`. */
  createAnalytic?: Maybe<CreateAnalyticPayload>;
  /** Creates a single `Apitoken`. */
  createApitoken?: Maybe<CreateApitokenPayload>;
  /** Creates a single `Article`. */
  createArticle?: Maybe<CreateArticlePayload>;
  /** Creates a single `Attribute`. */
  createAttribute?: Maybe<CreateAttributePayload>;
  /** Creates a single `Brand`. */
  createBrand?: Maybe<CreateBrandPayload>;
  /** Creates a single `CartPriceRule`. */
  createCartPriceRule?: Maybe<CreateCartPriceRulePayload>;
  /** Creates a single `Case`. */
  createCase?: Maybe<CreateCasePayload>;
  /** Creates a single `CatalogPriceRule`. */
  createCatalogPriceRule?: Maybe<CreateCatalogPriceRulePayload>;
  /** Creates a single `Category`. */
  createCategory?: Maybe<CreateCategoryPayload>;
  /** Creates a single `Channel`. */
  createChannel?: Maybe<CreateChannelPayload>;
  /** Creates a single `Checklist`. */
  createChecklist?: Maybe<CreateChecklistPayload>;
  /** Creates a single `City`. */
  createCity?: Maybe<CreateCityPayload>;
  /** Creates a single `Collection`. */
  createCollection?: Maybe<CreateCollectionPayload>;
  /** Creates a single `Comment`. */
  createComment?: Maybe<CreateCommentPayload>;
  /** Creates a single `ContentType`. */
  createContentType?: Maybe<CreateContentTypePayload>;
  /** Creates a single `Contract`. */
  createContract?: Maybe<CreateContractPayload>;
  /** Creates a single `Country`. */
  createCountry?: Maybe<CreateCountryPayload>;
  /** Creates a single `Coupon`. */
  createCoupon?: Maybe<CreateCouponPayload>;
  /** Creates a single `CreditMemo`. */
  createCreditMemo?: Maybe<CreateCreditMemoPayload>;
  /** Creates a single `Currency`. */
  createCurrency?: Maybe<CreateCurrencyPayload>;
  /** Creates a single `CurrencyRate`. */
  createCurrencyRate?: Maybe<CreateCurrencyRatePayload>;
  /** Creates a single `CurrencySymbol`. */
  createCurrencySymbol?: Maybe<CreateCurrencySymbolPayload>;
  /** Creates a single `CustomerGroup`. */
  createCustomerGroup?: Maybe<CreateCustomerGroupPayload>;
  /** Creates a single `Customer`. */
  createCustomer?: Maybe<CreateCustomerPayload>;
  /** Creates a single `Customization`. */
  createCustomization?: Maybe<CreateCustomizationPayload>;
  /** Creates a single `Dashboard`. */
  createDashboard?: Maybe<CreateDashboardPayload>;
  /** Creates a single `Deepdive`. */
  createDeepdive?: Maybe<CreateDeepdivePayload>;
  /** Creates a single `Digiboard`. */
  createDigiboard?: Maybe<CreateDigiboardPayload>;
  /** Creates a single `Email`. */
  createEmail?: Maybe<CreateEmailPayload>;
  /** Creates a single `Endofshift`. */
  createEndofshift?: Maybe<CreateEndofshiftPayload>;
  /** Creates a single `Event`. */
  createEvent?: Maybe<CreateEventPayload>;
  /** Creates a single `Fullfillment`. */
  createFullfillment?: Maybe<CreateFullfillmentPayload>;
  /** Creates a single `GiftCertificate`. */
  createGiftCertificate?: Maybe<CreateGiftCertificatePayload>;
  /** Creates a single `Glossary`. */
  createGlossary?: Maybe<CreateGlossaryPayload>;
  /** Creates a single `Importm`. */
  createImportm?: Maybe<CreateImportmPayload>;
  /** Creates a single `Integration`. */
  createIntegration?: Maybe<CreateIntegrationPayload>;
  /** Creates a single `Internalization`. */
  createInternalization?: Maybe<CreateInternalizationPayload>;
  /** Creates a single `Invitation`. */
  createInvitation?: Maybe<CreateInvitationPayload>;
  /** Creates a single `Invoice`. */
  createInvoice?: Maybe<CreateInvoicePayload>;
  /** Creates a single `Lead`. */
  createLead?: Maybe<CreateLeadPayload>;
  /** Creates a single `Manufacturer`. */
  createManufacturer?: Maybe<CreateManufacturerPayload>;
  /** Creates a single `Mediamanager`. */
  createMediamanager?: Maybe<CreateMediamanagerPayload>;
  /** Creates a single `Meeting`. */
  createMeeting?: Maybe<CreateMeetingPayload>;
  /** Creates a single `Message`. */
  createMessage?: Maybe<CreateMessagePayload>;
  /** Creates a single `Newsletter`. */
  createNewsletter?: Maybe<CreateNewsletterPayload>;
  /** Creates a single `Ooto`. */
  createOoto?: Maybe<CreateOotoPayload>;
  /** Creates a single `Opportunity`. */
  createOpportunity?: Maybe<CreateOpportunityPayload>;
  /** Creates a single `Order`. */
  createOrder?: Maybe<CreateOrderPayload>;
  /** Creates a single `Page`. */
  createPage?: Maybe<CreatePagePayload>;
  /** Creates a single `Partner`. */
  createPartner?: Maybe<CreatePartnerPayload>;
  /** Creates a single `Payment`. */
  createPayment?: Maybe<CreatePaymentPayload>;
  /** Creates a single `Permission`. */
  createPermission?: Maybe<CreatePermissionPayload>;
  /** Creates a single `Plugin`. */
  createPlugin?: Maybe<CreatePluginPayload>;
  /** Creates a single `Poll`. */
  createPoll?: Maybe<CreatePollPayload>;
  /** Creates a single `ProductType`. */
  createProductType?: Maybe<CreateProductTypePayload>;
  /** Creates a single `Product`. */
  createProduct?: Maybe<CreateProductPayload>;
  /** Creates a single `Project`. */
  createProject?: Maybe<CreateProjectPayload>;
  /** Creates a single `Provider`. */
  createProvider?: Maybe<CreateProviderPayload>;
  /** Creates a single `Quote`. */
  createQuote?: Maybe<CreateQuotePayload>;
  /** Creates a single `Rating`. */
  createRating?: Maybe<CreateRatingPayload>;
  /** Creates a single `Report`. */
  createReport?: Maybe<CreateReportPayload>;
  /** Creates a single `Return`. */
  createReturn?: Maybe<CreateReturnPayload>;
  /** Creates a single `Review`. */
  createReview?: Maybe<CreateReviewPayload>;
  /** Creates a single `Reward`. */
  createReward?: Maybe<CreateRewardPayload>;
  /** Creates a single `Role`. */
  createRole?: Maybe<CreateRolePayload>;
  /** Creates a single `Scheduler`. */
  createScheduler?: Maybe<CreateSchedulerPayload>;
  /** Creates a single `Segment`. */
  createSegment?: Maybe<CreateSegmentPayload>;
  /** Creates a single `Setting`. */
  createSetting?: Maybe<CreateSettingPayload>;
  /** Creates a single `Shipment`. */
  createShipment?: Maybe<CreateShipmentPayload>;
  /** Creates a single `SpecialDiscount`. */
  createSpecialDiscount?: Maybe<CreateSpecialDiscountPayload>;
  /** Creates a single `State`. */
  createState?: Maybe<CreateStatePayload>;
  /** Creates a single `Statistic`. */
  createStatistic?: Maybe<CreateStatisticPayload>;
  /** Creates a single `Stock`. */
  createStock?: Maybe<CreateStockPayload>;
  /** Creates a single `Survey`. */
  createSurvey?: Maybe<CreateSurveyPayload>;
  /** Creates a single `Tag`. */
  createTag?: Maybe<CreateTagPayload>;
  /** Creates a single `Target`. */
  createTarget?: Maybe<CreateTargetPayload>;
  /** Creates a single `TaxCategory`. */
  createTaxCategory?: Maybe<CreateTaxCategoryPayload>;
  /** Creates a single `TaxRate`. */
  createTaxRate?: Maybe<CreateTaxRatePayload>;
  /** Creates a single `TaxRule`. */
  createTaxRule?: Maybe<CreateTaxRulePayload>;
  /** Creates a single `Template`. */
  createTemplate?: Maybe<CreateTemplatePayload>;
  /** Creates a single `Theme`. */
  createTheme?: Maybe<CreateThemePayload>;
  /** Creates a single `Ticketing`. */
  createTicketing?: Maybe<CreateTicketingPayload>;
  /** Creates a single `Training`. */
  createTraining?: Maybe<CreateTrainingPayload>;
  /** Creates a single `Transaction`. */
  createTransaction?: Maybe<CreateTransactionPayload>;
  /** Creates a single `UploadFile`. */
  createUploadFile?: Maybe<CreateUploadFilePayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `Vendor`. */
  createVendor?: Maybe<CreateVendorPayload>;
  /** Creates a single `Visit`. */
  createVisit?: Maybe<CreateVisitPayload>;
  /** Creates a single `Warehouse`. */
  createWarehouse?: Maybe<CreateWarehousePayload>;
  /** Creates a single `Webhook`. */
  createWebhook?: Maybe<CreateWebhookPayload>;
  /** Creates a single `Website`. */
  createWebsite?: Maybe<CreateWebsitePayload>;
  /** Creates a single `Wishlist`. */
  createWishlist?: Maybe<CreateWishlistPayload>;
  /** Creates a single `Workspace`. */
  createWorkspace?: Maybe<CreateWorkspacePayload>;
  /** Creates a single `Zone`. */
  createZone?: Maybe<CreateZonePayload>;
  /** Updates a single `Account` using its globally unique id and a patch. */
  updateAccount?: Maybe<UpdateAccountPayload>;
  /** Updates a single `Account` using a unique key and a patch. */
  updateAccountById?: Maybe<UpdateAccountPayload>;
  /** Updates a single `Agreement` using its globally unique id and a patch. */
  updateAgreement?: Maybe<UpdateAgreementPayload>;
  /** Updates a single `Agreement` using a unique key and a patch. */
  updateAgreementById?: Maybe<UpdateAgreementPayload>;
  /** Updates a single `Analytic` using its globally unique id and a patch. */
  updateAnalytic?: Maybe<UpdateAnalyticPayload>;
  /** Updates a single `Analytic` using a unique key and a patch. */
  updateAnalyticById?: Maybe<UpdateAnalyticPayload>;
  /** Updates a single `Apitoken` using its globally unique id and a patch. */
  updateApitoken?: Maybe<UpdateApitokenPayload>;
  /** Updates a single `Apitoken` using a unique key and a patch. */
  updateApitokenById?: Maybe<UpdateApitokenPayload>;
  /** Updates a single `Article` using its globally unique id and a patch. */
  updateArticle?: Maybe<UpdateArticlePayload>;
  /** Updates a single `Article` using a unique key and a patch. */
  updateArticleById?: Maybe<UpdateArticlePayload>;
  /** Updates a single `Attribute` using its globally unique id and a patch. */
  updateAttribute?: Maybe<UpdateAttributePayload>;
  /** Updates a single `Attribute` using a unique key and a patch. */
  updateAttributeById?: Maybe<UpdateAttributePayload>;
  /** Updates a single `Brand` using its globally unique id and a patch. */
  updateBrand?: Maybe<UpdateBrandPayload>;
  /** Updates a single `Brand` using a unique key and a patch. */
  updateBrandById?: Maybe<UpdateBrandPayload>;
  /** Updates a single `CartPriceRule` using its globally unique id and a patch. */
  updateCartPriceRule?: Maybe<UpdateCartPriceRulePayload>;
  /** Updates a single `CartPriceRule` using a unique key and a patch. */
  updateCartPriceRuleById?: Maybe<UpdateCartPriceRulePayload>;
  /** Updates a single `Case` using its globally unique id and a patch. */
  updateCase?: Maybe<UpdateCasePayload>;
  /** Updates a single `Case` using a unique key and a patch. */
  updateCaseById?: Maybe<UpdateCasePayload>;
  /** Updates a single `CatalogPriceRule` using its globally unique id and a patch. */
  updateCatalogPriceRule?: Maybe<UpdateCatalogPriceRulePayload>;
  /** Updates a single `CatalogPriceRule` using a unique key and a patch. */
  updateCatalogPriceRuleById?: Maybe<UpdateCatalogPriceRulePayload>;
  /** Updates a single `Category` using its globally unique id and a patch. */
  updateCategory?: Maybe<UpdateCategoryPayload>;
  /** Updates a single `Category` using a unique key and a patch. */
  updateCategoryById?: Maybe<UpdateCategoryPayload>;
  /** Updates a single `Channel` using its globally unique id and a patch. */
  updateChannel?: Maybe<UpdateChannelPayload>;
  /** Updates a single `Channel` using a unique key and a patch. */
  updateChannelById?: Maybe<UpdateChannelPayload>;
  /** Updates a single `Checklist` using its globally unique id and a patch. */
  updateChecklist?: Maybe<UpdateChecklistPayload>;
  /** Updates a single `Checklist` using a unique key and a patch. */
  updateChecklistById?: Maybe<UpdateChecklistPayload>;
  /** Updates a single `City` using its globally unique id and a patch. */
  updateCity?: Maybe<UpdateCityPayload>;
  /** Updates a single `City` using a unique key and a patch. */
  updateCityById?: Maybe<UpdateCityPayload>;
  /** Updates a single `Collection` using its globally unique id and a patch. */
  updateCollection?: Maybe<UpdateCollectionPayload>;
  /** Updates a single `Collection` using a unique key and a patch. */
  updateCollectionById?: Maybe<UpdateCollectionPayload>;
  /** Updates a single `Comment` using its globally unique id and a patch. */
  updateComment?: Maybe<UpdateCommentPayload>;
  /** Updates a single `Comment` using a unique key and a patch. */
  updateCommentById?: Maybe<UpdateCommentPayload>;
  /** Updates a single `ContentType` using its globally unique id and a patch. */
  updateContentType?: Maybe<UpdateContentTypePayload>;
  /** Updates a single `ContentType` using a unique key and a patch. */
  updateContentTypeById?: Maybe<UpdateContentTypePayload>;
  /** Updates a single `Contract` using its globally unique id and a patch. */
  updateContract?: Maybe<UpdateContractPayload>;
  /** Updates a single `Contract` using a unique key and a patch. */
  updateContractById?: Maybe<UpdateContractPayload>;
  /** Updates a single `Country` using its globally unique id and a patch. */
  updateCountry?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Country` using a unique key and a patch. */
  updateCountryById?: Maybe<UpdateCountryPayload>;
  /** Updates a single `Coupon` using its globally unique id and a patch. */
  updateCoupon?: Maybe<UpdateCouponPayload>;
  /** Updates a single `Coupon` using a unique key and a patch. */
  updateCouponById?: Maybe<UpdateCouponPayload>;
  /** Updates a single `CreditMemo` using its globally unique id and a patch. */
  updateCreditMemo?: Maybe<UpdateCreditMemoPayload>;
  /** Updates a single `CreditMemo` using a unique key and a patch. */
  updateCreditMemoByCreditMemoAndId?: Maybe<UpdateCreditMemoPayload>;
  /** Updates a single `Currency` using its globally unique id and a patch. */
  updateCurrency?: Maybe<UpdateCurrencyPayload>;
  /** Updates a single `Currency` using a unique key and a patch. */
  updateCurrencyById?: Maybe<UpdateCurrencyPayload>;
  /** Updates a single `CurrencyRate` using its globally unique id and a patch. */
  updateCurrencyRate?: Maybe<UpdateCurrencyRatePayload>;
  /** Updates a single `CurrencyRate` using a unique key and a patch. */
  updateCurrencyRateByImportService?: Maybe<UpdateCurrencyRatePayload>;
  /** Updates a single `CurrencySymbol` using its globally unique id and a patch. */
  updateCurrencySymbol?: Maybe<UpdateCurrencySymbolPayload>;
  /** Updates a single `CurrencySymbol` using a unique key and a patch. */
  updateCurrencySymbolBySymbol?: Maybe<UpdateCurrencySymbolPayload>;
  /** Updates a single `CustomerGroup` using its globally unique id and a patch. */
  updateCustomerGroup?: Maybe<UpdateCustomerGroupPayload>;
  /** Updates a single `CustomerGroup` using a unique key and a patch. */
  updateCustomerGroupById?: Maybe<UpdateCustomerGroupPayload>;
  /** Updates a single `Customer` using its globally unique id and a patch. */
  updateCustomer?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `Customer` using a unique key and a patch. */
  updateCustomerById?: Maybe<UpdateCustomerPayload>;
  /** Updates a single `Customization` using its globally unique id and a patch. */
  updateCustomization?: Maybe<UpdateCustomizationPayload>;
  /** Updates a single `Customization` using a unique key and a patch. */
  updateCustomizationById?: Maybe<UpdateCustomizationPayload>;
  /** Updates a single `Dashboard` using its globally unique id and a patch. */
  updateDashboard?: Maybe<UpdateDashboardPayload>;
  /** Updates a single `Dashboard` using a unique key and a patch. */
  updateDashboardById?: Maybe<UpdateDashboardPayload>;
  /** Updates a single `Deepdive` using its globally unique id and a patch. */
  updateDeepdive?: Maybe<UpdateDeepdivePayload>;
  /** Updates a single `Deepdive` using a unique key and a patch. */
  updateDeepdiveById?: Maybe<UpdateDeepdivePayload>;
  /** Updates a single `Digiboard` using its globally unique id and a patch. */
  updateDigiboard?: Maybe<UpdateDigiboardPayload>;
  /** Updates a single `Digiboard` using a unique key and a patch. */
  updateDigiboardById?: Maybe<UpdateDigiboardPayload>;
  /** Updates a single `Email` using its globally unique id and a patch. */
  updateEmail?: Maybe<UpdateEmailPayload>;
  /** Updates a single `Email` using a unique key and a patch. */
  updateEmailById?: Maybe<UpdateEmailPayload>;
  /** Updates a single `Endofshift` using its globally unique id and a patch. */
  updateEndofshift?: Maybe<UpdateEndofshiftPayload>;
  /** Updates a single `Endofshift` using a unique key and a patch. */
  updateEndofshiftById?: Maybe<UpdateEndofshiftPayload>;
  /** Updates a single `Event` using its globally unique id and a patch. */
  updateEvent?: Maybe<UpdateEventPayload>;
  /** Updates a single `Event` using a unique key and a patch. */
  updateEventById?: Maybe<UpdateEventPayload>;
  /** Updates a single `Fullfillment` using its globally unique id and a patch. */
  updateFullfillment?: Maybe<UpdateFullfillmentPayload>;
  /** Updates a single `Fullfillment` using a unique key and a patch. */
  updateFullfillmentById?: Maybe<UpdateFullfillmentPayload>;
  /** Updates a single `GiftCertificate` using its globally unique id and a patch. */
  updateGiftCertificate?: Maybe<UpdateGiftCertificatePayload>;
  /** Updates a single `GiftCertificate` using a unique key and a patch. */
  updateGiftCertificateById?: Maybe<UpdateGiftCertificatePayload>;
  /** Updates a single `Glossary` using its globally unique id and a patch. */
  updateGlossary?: Maybe<UpdateGlossaryPayload>;
  /** Updates a single `Glossary` using a unique key and a patch. */
  updateGlossaryById?: Maybe<UpdateGlossaryPayload>;
  /** Updates a single `Importm` using its globally unique id and a patch. */
  updateImportm?: Maybe<UpdateImportmPayload>;
  /** Updates a single `Importm` using a unique key and a patch. */
  updateImportmById?: Maybe<UpdateImportmPayload>;
  /** Updates a single `Integration` using its globally unique id and a patch. */
  updateIntegration?: Maybe<UpdateIntegrationPayload>;
  /** Updates a single `Integration` using a unique key and a patch. */
  updateIntegrationById?: Maybe<UpdateIntegrationPayload>;
  /** Updates a single `Internalization` using its globally unique id and a patch. */
  updateInternalization?: Maybe<UpdateInternalizationPayload>;
  /** Updates a single `Internalization` using a unique key and a patch. */
  updateInternalizationById?: Maybe<UpdateInternalizationPayload>;
  /** Updates a single `Invitation` using its globally unique id and a patch. */
  updateInvitation?: Maybe<UpdateInvitationPayload>;
  /** Updates a single `Invitation` using a unique key and a patch. */
  updateInvitationById?: Maybe<UpdateInvitationPayload>;
  /** Updates a single `Invoice` using its globally unique id and a patch. */
  updateInvoice?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `Invoice` using a unique key and a patch. */
  updateInvoiceById?: Maybe<UpdateInvoicePayload>;
  /** Updates a single `Lead` using its globally unique id and a patch. */
  updateLead?: Maybe<UpdateLeadPayload>;
  /** Updates a single `Lead` using a unique key and a patch. */
  updateLeadById?: Maybe<UpdateLeadPayload>;
  /** Updates a single `Manufacturer` using its globally unique id and a patch. */
  updateManufacturer?: Maybe<UpdateManufacturerPayload>;
  /** Updates a single `Manufacturer` using a unique key and a patch. */
  updateManufacturerById?: Maybe<UpdateManufacturerPayload>;
  /** Updates a single `Mediamanager` using its globally unique id and a patch. */
  updateMediamanager?: Maybe<UpdateMediamanagerPayload>;
  /** Updates a single `Mediamanager` using a unique key and a patch. */
  updateMediamanagerById?: Maybe<UpdateMediamanagerPayload>;
  /** Updates a single `Meeting` using its globally unique id and a patch. */
  updateMeeting?: Maybe<UpdateMeetingPayload>;
  /** Updates a single `Meeting` using a unique key and a patch. */
  updateMeetingById?: Maybe<UpdateMeetingPayload>;
  /** Updates a single `Message` using its globally unique id and a patch. */
  updateMessage?: Maybe<UpdateMessagePayload>;
  /** Updates a single `Message` using a unique key and a patch. */
  updateMessageById?: Maybe<UpdateMessagePayload>;
  /** Updates a single `Newsletter` using its globally unique id and a patch. */
  updateNewsletter?: Maybe<UpdateNewsletterPayload>;
  /** Updates a single `Newsletter` using a unique key and a patch. */
  updateNewsletterById?: Maybe<UpdateNewsletterPayload>;
  /** Updates a single `Ooto` using its globally unique id and a patch. */
  updateOoto?: Maybe<UpdateOotoPayload>;
  /** Updates a single `Ooto` using a unique key and a patch. */
  updateOotoById?: Maybe<UpdateOotoPayload>;
  /** Updates a single `Opportunity` using its globally unique id and a patch. */
  updateOpportunity?: Maybe<UpdateOpportunityPayload>;
  /** Updates a single `Opportunity` using a unique key and a patch. */
  updateOpportunityById?: Maybe<UpdateOpportunityPayload>;
  /** Updates a single `Order` using its globally unique id and a patch. */
  updateOrder?: Maybe<UpdateOrderPayload>;
  /** Updates a single `Order` using a unique key and a patch. */
  updateOrderById?: Maybe<UpdateOrderPayload>;
  /** Updates a single `Page` using its globally unique id and a patch. */
  updatePage?: Maybe<UpdatePagePayload>;
  /** Updates a single `Page` using a unique key and a patch. */
  updatePageById?: Maybe<UpdatePagePayload>;
  /** Updates a single `Partner` using its globally unique id and a patch. */
  updatePartner?: Maybe<UpdatePartnerPayload>;
  /** Updates a single `Partner` using a unique key and a patch. */
  updatePartnerById?: Maybe<UpdatePartnerPayload>;
  /** Updates a single `Payment` using its globally unique id and a patch. */
  updatePayment?: Maybe<UpdatePaymentPayload>;
  /** Updates a single `Payment` using a unique key and a patch. */
  updatePaymentById?: Maybe<UpdatePaymentPayload>;
  /** Updates a single `Permission` using its globally unique id and a patch. */
  updatePermission?: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Permission` using a unique key and a patch. */
  updatePermissionById?: Maybe<UpdatePermissionPayload>;
  /** Updates a single `Plugin` using its globally unique id and a patch. */
  updatePlugin?: Maybe<UpdatePluginPayload>;
  /** Updates a single `Plugin` using a unique key and a patch. */
  updatePluginById?: Maybe<UpdatePluginPayload>;
  /** Updates a single `Poll` using its globally unique id and a patch. */
  updatePoll?: Maybe<UpdatePollPayload>;
  /** Updates a single `Poll` using a unique key and a patch. */
  updatePollById?: Maybe<UpdatePollPayload>;
  /** Updates a single `ProductType` using its globally unique id and a patch. */
  updateProductType?: Maybe<UpdateProductTypePayload>;
  /** Updates a single `ProductType` using a unique key and a patch. */
  updateProductTypeById?: Maybe<UpdateProductTypePayload>;
  /** Updates a single `Product` using its globally unique id and a patch. */
  updateProduct?: Maybe<UpdateProductPayload>;
  /** Updates a single `Product` using a unique key and a patch. */
  updateProductById?: Maybe<UpdateProductPayload>;
  /** Updates a single `Project` using its globally unique id and a patch. */
  updateProject?: Maybe<UpdateProjectPayload>;
  /** Updates a single `Project` using a unique key and a patch. */
  updateProjectById?: Maybe<UpdateProjectPayload>;
  /** Updates a single `Provider` using its globally unique id and a patch. */
  updateProvider?: Maybe<UpdateProviderPayload>;
  /** Updates a single `Provider` using a unique key and a patch. */
  updateProviderById?: Maybe<UpdateProviderPayload>;
  /** Updates a single `Quote` using its globally unique id and a patch. */
  updateQuote?: Maybe<UpdateQuotePayload>;
  /** Updates a single `Quote` using a unique key and a patch. */
  updateQuoteById?: Maybe<UpdateQuotePayload>;
  /** Updates a single `Rating` using its globally unique id and a patch. */
  updateRating?: Maybe<UpdateRatingPayload>;
  /** Updates a single `Rating` using a unique key and a patch. */
  updateRatingById?: Maybe<UpdateRatingPayload>;
  /** Updates a single `Report` using its globally unique id and a patch. */
  updateReport?: Maybe<UpdateReportPayload>;
  /** Updates a single `Report` using a unique key and a patch. */
  updateReportById?: Maybe<UpdateReportPayload>;
  /** Updates a single `Return` using its globally unique id and a patch. */
  updateReturn?: Maybe<UpdateReturnPayload>;
  /** Updates a single `Return` using a unique key and a patch. */
  updateReturnById?: Maybe<UpdateReturnPayload>;
  /** Updates a single `Review` using its globally unique id and a patch. */
  updateReview?: Maybe<UpdateReviewPayload>;
  /** Updates a single `Review` using a unique key and a patch. */
  updateReviewById?: Maybe<UpdateReviewPayload>;
  /** Updates a single `Reward` using its globally unique id and a patch. */
  updateReward?: Maybe<UpdateRewardPayload>;
  /** Updates a single `Reward` using a unique key and a patch. */
  updateRewardById?: Maybe<UpdateRewardPayload>;
  /** Updates a single `Role` using its globally unique id and a patch. */
  updateRole?: Maybe<UpdateRolePayload>;
  /** Updates a single `Role` using a unique key and a patch. */
  updateRoleById?: Maybe<UpdateRolePayload>;
  /** Updates a single `Scheduler` using its globally unique id and a patch. */
  updateScheduler?: Maybe<UpdateSchedulerPayload>;
  /** Updates a single `Scheduler` using a unique key and a patch. */
  updateSchedulerById?: Maybe<UpdateSchedulerPayload>;
  /** Updates a single `Segment` using its globally unique id and a patch. */
  updateSegment?: Maybe<UpdateSegmentPayload>;
  /** Updates a single `Segment` using a unique key and a patch. */
  updateSegmentById?: Maybe<UpdateSegmentPayload>;
  /** Updates a single `Setting` using its globally unique id and a patch. */
  updateSetting?: Maybe<UpdateSettingPayload>;
  /** Updates a single `Setting` using a unique key and a patch. */
  updateSettingById?: Maybe<UpdateSettingPayload>;
  /** Updates a single `Shipment` using its globally unique id and a patch. */
  updateShipment?: Maybe<UpdateShipmentPayload>;
  /** Updates a single `Shipment` using a unique key and a patch. */
  updateShipmentById?: Maybe<UpdateShipmentPayload>;
  /** Updates a single `SpecialDiscount` using its globally unique id and a patch. */
  updateSpecialDiscount?: Maybe<UpdateSpecialDiscountPayload>;
  /** Updates a single `SpecialDiscount` using a unique key and a patch. */
  updateSpecialDiscountById?: Maybe<UpdateSpecialDiscountPayload>;
  /** Updates a single `State` using its globally unique id and a patch. */
  updateState?: Maybe<UpdateStatePayload>;
  /** Updates a single `State` using a unique key and a patch. */
  updateStateById?: Maybe<UpdateStatePayload>;
  /** Updates a single `Statistic` using its globally unique id and a patch. */
  updateStatistic?: Maybe<UpdateStatisticPayload>;
  /** Updates a single `Statistic` using a unique key and a patch. */
  updateStatisticById?: Maybe<UpdateStatisticPayload>;
  /** Updates a single `Stock` using its globally unique id and a patch. */
  updateStock?: Maybe<UpdateStockPayload>;
  /** Updates a single `Stock` using a unique key and a patch. */
  updateStockById?: Maybe<UpdateStockPayload>;
  /** Updates a single `Survey` using its globally unique id and a patch. */
  updateSurvey?: Maybe<UpdateSurveyPayload>;
  /** Updates a single `Survey` using a unique key and a patch. */
  updateSurveyById?: Maybe<UpdateSurveyPayload>;
  /** Updates a single `Tag` using its globally unique id and a patch. */
  updateTag?: Maybe<UpdateTagPayload>;
  /** Updates a single `Tag` using a unique key and a patch. */
  updateTagById?: Maybe<UpdateTagPayload>;
  /** Updates a single `Target` using its globally unique id and a patch. */
  updateTarget?: Maybe<UpdateTargetPayload>;
  /** Updates a single `Target` using a unique key and a patch. */
  updateTargetById?: Maybe<UpdateTargetPayload>;
  /** Updates a single `TaxCategory` using its globally unique id and a patch. */
  updateTaxCategory?: Maybe<UpdateTaxCategoryPayload>;
  /** Updates a single `TaxCategory` using a unique key and a patch. */
  updateTaxCategoryById?: Maybe<UpdateTaxCategoryPayload>;
  /** Updates a single `TaxRate` using its globally unique id and a patch. */
  updateTaxRate?: Maybe<UpdateTaxRatePayload>;
  /** Updates a single `TaxRate` using a unique key and a patch. */
  updateTaxRateById?: Maybe<UpdateTaxRatePayload>;
  /** Updates a single `TaxRule` using its globally unique id and a patch. */
  updateTaxRule?: Maybe<UpdateTaxRulePayload>;
  /** Updates a single `TaxRule` using a unique key and a patch. */
  updateTaxRuleById?: Maybe<UpdateTaxRulePayload>;
  /** Updates a single `Template` using its globally unique id and a patch. */
  updateTemplate?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `Template` using a unique key and a patch. */
  updateTemplateById?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `Theme` using its globally unique id and a patch. */
  updateTheme?: Maybe<UpdateThemePayload>;
  /** Updates a single `Theme` using a unique key and a patch. */
  updateThemeById?: Maybe<UpdateThemePayload>;
  /** Updates a single `Ticketing` using its globally unique id and a patch. */
  updateTicketing?: Maybe<UpdateTicketingPayload>;
  /** Updates a single `Ticketing` using a unique key and a patch. */
  updateTicketingById?: Maybe<UpdateTicketingPayload>;
  /** Updates a single `Training` using its globally unique id and a patch. */
  updateTraining?: Maybe<UpdateTrainingPayload>;
  /** Updates a single `Training` using a unique key and a patch. */
  updateTrainingById?: Maybe<UpdateTrainingPayload>;
  /** Updates a single `Transaction` using its globally unique id and a patch. */
  updateTransaction?: Maybe<UpdateTransactionPayload>;
  /** Updates a single `Transaction` using a unique key and a patch. */
  updateTransactionById?: Maybe<UpdateTransactionPayload>;
  /** Updates a single `UploadFile` using its globally unique id and a patch. */
  updateUploadFile?: Maybe<UpdateUploadFilePayload>;
  /** Updates a single `UploadFile` using a unique key and a patch. */
  updateUploadFileById?: Maybe<UpdateUploadFilePayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserById?: Maybe<UpdateUserPayload>;
  /** Updates a single `Vendor` using its globally unique id and a patch. */
  updateVendor?: Maybe<UpdateVendorPayload>;
  /** Updates a single `Vendor` using a unique key and a patch. */
  updateVendorById?: Maybe<UpdateVendorPayload>;
  /** Updates a single `Visit` using its globally unique id and a patch. */
  updateVisit?: Maybe<UpdateVisitPayload>;
  /** Updates a single `Visit` using a unique key and a patch. */
  updateVisitById?: Maybe<UpdateVisitPayload>;
  /** Updates a single `Warehouse` using its globally unique id and a patch. */
  updateWarehouse?: Maybe<UpdateWarehousePayload>;
  /** Updates a single `Warehouse` using a unique key and a patch. */
  updateWarehouseById?: Maybe<UpdateWarehousePayload>;
  /** Updates a single `Webhook` using its globally unique id and a patch. */
  updateWebhook?: Maybe<UpdateWebhookPayload>;
  /** Updates a single `Webhook` using a unique key and a patch. */
  updateWebhookById?: Maybe<UpdateWebhookPayload>;
  /** Updates a single `Website` using its globally unique id and a patch. */
  updateWebsite?: Maybe<UpdateWebsitePayload>;
  /** Updates a single `Website` using a unique key and a patch. */
  updateWebsiteById?: Maybe<UpdateWebsitePayload>;
  /** Updates a single `Wishlist` using its globally unique id and a patch. */
  updateWishlist?: Maybe<UpdateWishlistPayload>;
  /** Updates a single `Wishlist` using a unique key and a patch. */
  updateWishlistById?: Maybe<UpdateWishlistPayload>;
  /** Updates a single `Workspace` using its globally unique id and a patch. */
  updateWorkspace?: Maybe<UpdateWorkspacePayload>;
  /** Updates a single `Workspace` using a unique key and a patch. */
  updateWorkspaceById?: Maybe<UpdateWorkspacePayload>;
  /** Updates a single `Zone` using its globally unique id and a patch. */
  updateZone?: Maybe<UpdateZonePayload>;
  /** Updates a single `Zone` using a unique key and a patch. */
  updateZoneById?: Maybe<UpdateZonePayload>;
  /** Deletes a single `Account` using its globally unique id. */
  deleteAccount?: Maybe<DeleteAccountPayload>;
  /** Deletes a single `Account` using a unique key. */
  deleteAccountById?: Maybe<DeleteAccountPayload>;
  /** Deletes a single `Agreement` using its globally unique id. */
  deleteAgreement?: Maybe<DeleteAgreementPayload>;
  /** Deletes a single `Agreement` using a unique key. */
  deleteAgreementById?: Maybe<DeleteAgreementPayload>;
  /** Deletes a single `Analytic` using its globally unique id. */
  deleteAnalytic?: Maybe<DeleteAnalyticPayload>;
  /** Deletes a single `Analytic` using a unique key. */
  deleteAnalyticById?: Maybe<DeleteAnalyticPayload>;
  /** Deletes a single `Apitoken` using its globally unique id. */
  deleteApitoken?: Maybe<DeleteApitokenPayload>;
  /** Deletes a single `Apitoken` using a unique key. */
  deleteApitokenById?: Maybe<DeleteApitokenPayload>;
  /** Deletes a single `Article` using its globally unique id. */
  deleteArticle?: Maybe<DeleteArticlePayload>;
  /** Deletes a single `Article` using a unique key. */
  deleteArticleById?: Maybe<DeleteArticlePayload>;
  /** Deletes a single `Attribute` using its globally unique id. */
  deleteAttribute?: Maybe<DeleteAttributePayload>;
  /** Deletes a single `Attribute` using a unique key. */
  deleteAttributeById?: Maybe<DeleteAttributePayload>;
  /** Deletes a single `Brand` using its globally unique id. */
  deleteBrand?: Maybe<DeleteBrandPayload>;
  /** Deletes a single `Brand` using a unique key. */
  deleteBrandById?: Maybe<DeleteBrandPayload>;
  /** Deletes a single `CartPriceRule` using its globally unique id. */
  deleteCartPriceRule?: Maybe<DeleteCartPriceRulePayload>;
  /** Deletes a single `CartPriceRule` using a unique key. */
  deleteCartPriceRuleById?: Maybe<DeleteCartPriceRulePayload>;
  /** Deletes a single `Case` using its globally unique id. */
  deleteCase?: Maybe<DeleteCasePayload>;
  /** Deletes a single `Case` using a unique key. */
  deleteCaseById?: Maybe<DeleteCasePayload>;
  /** Deletes a single `CatalogPriceRule` using its globally unique id. */
  deleteCatalogPriceRule?: Maybe<DeleteCatalogPriceRulePayload>;
  /** Deletes a single `CatalogPriceRule` using a unique key. */
  deleteCatalogPriceRuleById?: Maybe<DeleteCatalogPriceRulePayload>;
  /** Deletes a single `Category` using its globally unique id. */
  deleteCategory?: Maybe<DeleteCategoryPayload>;
  /** Deletes a single `Category` using a unique key. */
  deleteCategoryById?: Maybe<DeleteCategoryPayload>;
  /** Deletes a single `Channel` using its globally unique id. */
  deleteChannel?: Maybe<DeleteChannelPayload>;
  /** Deletes a single `Channel` using a unique key. */
  deleteChannelById?: Maybe<DeleteChannelPayload>;
  /** Deletes a single `Checklist` using its globally unique id. */
  deleteChecklist?: Maybe<DeleteChecklistPayload>;
  /** Deletes a single `Checklist` using a unique key. */
  deleteChecklistById?: Maybe<DeleteChecklistPayload>;
  /** Deletes a single `City` using its globally unique id. */
  deleteCity?: Maybe<DeleteCityPayload>;
  /** Deletes a single `City` using a unique key. */
  deleteCityById?: Maybe<DeleteCityPayload>;
  /** Deletes a single `Collection` using its globally unique id. */
  deleteCollection?: Maybe<DeleteCollectionPayload>;
  /** Deletes a single `Collection` using a unique key. */
  deleteCollectionById?: Maybe<DeleteCollectionPayload>;
  /** Deletes a single `Comment` using its globally unique id. */
  deleteComment?: Maybe<DeleteCommentPayload>;
  /** Deletes a single `Comment` using a unique key. */
  deleteCommentById?: Maybe<DeleteCommentPayload>;
  /** Deletes a single `ContentType` using its globally unique id. */
  deleteContentType?: Maybe<DeleteContentTypePayload>;
  /** Deletes a single `ContentType` using a unique key. */
  deleteContentTypeById?: Maybe<DeleteContentTypePayload>;
  /** Deletes a single `Contract` using its globally unique id. */
  deleteContract?: Maybe<DeleteContractPayload>;
  /** Deletes a single `Contract` using a unique key. */
  deleteContractById?: Maybe<DeleteContractPayload>;
  /** Deletes a single `Country` using its globally unique id. */
  deleteCountry?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Country` using a unique key. */
  deleteCountryById?: Maybe<DeleteCountryPayload>;
  /** Deletes a single `Coupon` using its globally unique id. */
  deleteCoupon?: Maybe<DeleteCouponPayload>;
  /** Deletes a single `Coupon` using a unique key. */
  deleteCouponById?: Maybe<DeleteCouponPayload>;
  /** Deletes a single `CreditMemo` using its globally unique id. */
  deleteCreditMemo?: Maybe<DeleteCreditMemoPayload>;
  /** Deletes a single `CreditMemo` using a unique key. */
  deleteCreditMemoByCreditMemoAndId?: Maybe<DeleteCreditMemoPayload>;
  /** Deletes a single `Currency` using its globally unique id. */
  deleteCurrency?: Maybe<DeleteCurrencyPayload>;
  /** Deletes a single `Currency` using a unique key. */
  deleteCurrencyById?: Maybe<DeleteCurrencyPayload>;
  /** Deletes a single `CurrencyRate` using its globally unique id. */
  deleteCurrencyRate?: Maybe<DeleteCurrencyRatePayload>;
  /** Deletes a single `CurrencyRate` using a unique key. */
  deleteCurrencyRateByImportService?: Maybe<DeleteCurrencyRatePayload>;
  /** Deletes a single `CurrencySymbol` using its globally unique id. */
  deleteCurrencySymbol?: Maybe<DeleteCurrencySymbolPayload>;
  /** Deletes a single `CurrencySymbol` using a unique key. */
  deleteCurrencySymbolBySymbol?: Maybe<DeleteCurrencySymbolPayload>;
  /** Deletes a single `CustomerGroup` using its globally unique id. */
  deleteCustomerGroup?: Maybe<DeleteCustomerGroupPayload>;
  /** Deletes a single `CustomerGroup` using a unique key. */
  deleteCustomerGroupById?: Maybe<DeleteCustomerGroupPayload>;
  /** Deletes a single `Customer` using its globally unique id. */
  deleteCustomer?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `Customer` using a unique key. */
  deleteCustomerById?: Maybe<DeleteCustomerPayload>;
  /** Deletes a single `Customization` using its globally unique id. */
  deleteCustomization?: Maybe<DeleteCustomizationPayload>;
  /** Deletes a single `Customization` using a unique key. */
  deleteCustomizationById?: Maybe<DeleteCustomizationPayload>;
  /** Deletes a single `Dashboard` using its globally unique id. */
  deleteDashboard?: Maybe<DeleteDashboardPayload>;
  /** Deletes a single `Dashboard` using a unique key. */
  deleteDashboardById?: Maybe<DeleteDashboardPayload>;
  /** Deletes a single `Deepdive` using its globally unique id. */
  deleteDeepdive?: Maybe<DeleteDeepdivePayload>;
  /** Deletes a single `Deepdive` using a unique key. */
  deleteDeepdiveById?: Maybe<DeleteDeepdivePayload>;
  /** Deletes a single `Digiboard` using its globally unique id. */
  deleteDigiboard?: Maybe<DeleteDigiboardPayload>;
  /** Deletes a single `Digiboard` using a unique key. */
  deleteDigiboardById?: Maybe<DeleteDigiboardPayload>;
  /** Deletes a single `Email` using its globally unique id. */
  deleteEmail?: Maybe<DeleteEmailPayload>;
  /** Deletes a single `Email` using a unique key. */
  deleteEmailById?: Maybe<DeleteEmailPayload>;
  /** Deletes a single `Endofshift` using its globally unique id. */
  deleteEndofshift?: Maybe<DeleteEndofshiftPayload>;
  /** Deletes a single `Endofshift` using a unique key. */
  deleteEndofshiftById?: Maybe<DeleteEndofshiftPayload>;
  /** Deletes a single `Event` using its globally unique id. */
  deleteEvent?: Maybe<DeleteEventPayload>;
  /** Deletes a single `Event` using a unique key. */
  deleteEventById?: Maybe<DeleteEventPayload>;
  /** Deletes a single `Fullfillment` using its globally unique id. */
  deleteFullfillment?: Maybe<DeleteFullfillmentPayload>;
  /** Deletes a single `Fullfillment` using a unique key. */
  deleteFullfillmentById?: Maybe<DeleteFullfillmentPayload>;
  /** Deletes a single `GiftCertificate` using its globally unique id. */
  deleteGiftCertificate?: Maybe<DeleteGiftCertificatePayload>;
  /** Deletes a single `GiftCertificate` using a unique key. */
  deleteGiftCertificateById?: Maybe<DeleteGiftCertificatePayload>;
  /** Deletes a single `Glossary` using its globally unique id. */
  deleteGlossary?: Maybe<DeleteGlossaryPayload>;
  /** Deletes a single `Glossary` using a unique key. */
  deleteGlossaryById?: Maybe<DeleteGlossaryPayload>;
  /** Deletes a single `Importm` using its globally unique id. */
  deleteImportm?: Maybe<DeleteImportmPayload>;
  /** Deletes a single `Importm` using a unique key. */
  deleteImportmById?: Maybe<DeleteImportmPayload>;
  /** Deletes a single `Integration` using its globally unique id. */
  deleteIntegration?: Maybe<DeleteIntegrationPayload>;
  /** Deletes a single `Integration` using a unique key. */
  deleteIntegrationById?: Maybe<DeleteIntegrationPayload>;
  /** Deletes a single `Internalization` using its globally unique id. */
  deleteInternalization?: Maybe<DeleteInternalizationPayload>;
  /** Deletes a single `Internalization` using a unique key. */
  deleteInternalizationById?: Maybe<DeleteInternalizationPayload>;
  /** Deletes a single `Invitation` using its globally unique id. */
  deleteInvitation?: Maybe<DeleteInvitationPayload>;
  /** Deletes a single `Invitation` using a unique key. */
  deleteInvitationById?: Maybe<DeleteInvitationPayload>;
  /** Deletes a single `Invoice` using its globally unique id. */
  deleteInvoice?: Maybe<DeleteInvoicePayload>;
  /** Deletes a single `Invoice` using a unique key. */
  deleteInvoiceById?: Maybe<DeleteInvoicePayload>;
  /** Deletes a single `Lead` using its globally unique id. */
  deleteLead?: Maybe<DeleteLeadPayload>;
  /** Deletes a single `Lead` using a unique key. */
  deleteLeadById?: Maybe<DeleteLeadPayload>;
  /** Deletes a single `Manufacturer` using its globally unique id. */
  deleteManufacturer?: Maybe<DeleteManufacturerPayload>;
  /** Deletes a single `Manufacturer` using a unique key. */
  deleteManufacturerById?: Maybe<DeleteManufacturerPayload>;
  /** Deletes a single `Mediamanager` using its globally unique id. */
  deleteMediamanager?: Maybe<DeleteMediamanagerPayload>;
  /** Deletes a single `Mediamanager` using a unique key. */
  deleteMediamanagerById?: Maybe<DeleteMediamanagerPayload>;
  /** Deletes a single `Meeting` using its globally unique id. */
  deleteMeeting?: Maybe<DeleteMeetingPayload>;
  /** Deletes a single `Meeting` using a unique key. */
  deleteMeetingById?: Maybe<DeleteMeetingPayload>;
  /** Deletes a single `Message` using its globally unique id. */
  deleteMessage?: Maybe<DeleteMessagePayload>;
  /** Deletes a single `Message` using a unique key. */
  deleteMessageById?: Maybe<DeleteMessagePayload>;
  /** Deletes a single `Newsletter` using its globally unique id. */
  deleteNewsletter?: Maybe<DeleteNewsletterPayload>;
  /** Deletes a single `Newsletter` using a unique key. */
  deleteNewsletterById?: Maybe<DeleteNewsletterPayload>;
  /** Deletes a single `Ooto` using its globally unique id. */
  deleteOoto?: Maybe<DeleteOotoPayload>;
  /** Deletes a single `Ooto` using a unique key. */
  deleteOotoById?: Maybe<DeleteOotoPayload>;
  /** Deletes a single `Opportunity` using its globally unique id. */
  deleteOpportunity?: Maybe<DeleteOpportunityPayload>;
  /** Deletes a single `Opportunity` using a unique key. */
  deleteOpportunityById?: Maybe<DeleteOpportunityPayload>;
  /** Deletes a single `Order` using its globally unique id. */
  deleteOrder?: Maybe<DeleteOrderPayload>;
  /** Deletes a single `Order` using a unique key. */
  deleteOrderById?: Maybe<DeleteOrderPayload>;
  /** Deletes a single `Page` using its globally unique id. */
  deletePage?: Maybe<DeletePagePayload>;
  /** Deletes a single `Page` using a unique key. */
  deletePageById?: Maybe<DeletePagePayload>;
  /** Deletes a single `Partner` using its globally unique id. */
  deletePartner?: Maybe<DeletePartnerPayload>;
  /** Deletes a single `Partner` using a unique key. */
  deletePartnerById?: Maybe<DeletePartnerPayload>;
  /** Deletes a single `Payment` using its globally unique id. */
  deletePayment?: Maybe<DeletePaymentPayload>;
  /** Deletes a single `Payment` using a unique key. */
  deletePaymentById?: Maybe<DeletePaymentPayload>;
  /** Deletes a single `Permission` using its globally unique id. */
  deletePermission?: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Permission` using a unique key. */
  deletePermissionById?: Maybe<DeletePermissionPayload>;
  /** Deletes a single `Plugin` using its globally unique id. */
  deletePlugin?: Maybe<DeletePluginPayload>;
  /** Deletes a single `Plugin` using a unique key. */
  deletePluginById?: Maybe<DeletePluginPayload>;
  /** Deletes a single `Poll` using its globally unique id. */
  deletePoll?: Maybe<DeletePollPayload>;
  /** Deletes a single `Poll` using a unique key. */
  deletePollById?: Maybe<DeletePollPayload>;
  /** Deletes a single `ProductType` using its globally unique id. */
  deleteProductType?: Maybe<DeleteProductTypePayload>;
  /** Deletes a single `ProductType` using a unique key. */
  deleteProductTypeById?: Maybe<DeleteProductTypePayload>;
  /** Deletes a single `Product` using its globally unique id. */
  deleteProduct?: Maybe<DeleteProductPayload>;
  /** Deletes a single `Product` using a unique key. */
  deleteProductById?: Maybe<DeleteProductPayload>;
  /** Deletes a single `Project` using its globally unique id. */
  deleteProject?: Maybe<DeleteProjectPayload>;
  /** Deletes a single `Project` using a unique key. */
  deleteProjectById?: Maybe<DeleteProjectPayload>;
  /** Deletes a single `Provider` using its globally unique id. */
  deleteProvider?: Maybe<DeleteProviderPayload>;
  /** Deletes a single `Provider` using a unique key. */
  deleteProviderById?: Maybe<DeleteProviderPayload>;
  /** Deletes a single `Quote` using its globally unique id. */
  deleteQuote?: Maybe<DeleteQuotePayload>;
  /** Deletes a single `Quote` using a unique key. */
  deleteQuoteById?: Maybe<DeleteQuotePayload>;
  /** Deletes a single `Rating` using its globally unique id. */
  deleteRating?: Maybe<DeleteRatingPayload>;
  /** Deletes a single `Rating` using a unique key. */
  deleteRatingById?: Maybe<DeleteRatingPayload>;
  /** Deletes a single `Report` using its globally unique id. */
  deleteReport?: Maybe<DeleteReportPayload>;
  /** Deletes a single `Report` using a unique key. */
  deleteReportById?: Maybe<DeleteReportPayload>;
  /** Deletes a single `Return` using its globally unique id. */
  deleteReturn?: Maybe<DeleteReturnPayload>;
  /** Deletes a single `Return` using a unique key. */
  deleteReturnById?: Maybe<DeleteReturnPayload>;
  /** Deletes a single `Review` using its globally unique id. */
  deleteReview?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `Review` using a unique key. */
  deleteReviewById?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `Reward` using its globally unique id. */
  deleteReward?: Maybe<DeleteRewardPayload>;
  /** Deletes a single `Reward` using a unique key. */
  deleteRewardById?: Maybe<DeleteRewardPayload>;
  /** Deletes a single `Role` using its globally unique id. */
  deleteRole?: Maybe<DeleteRolePayload>;
  /** Deletes a single `Role` using a unique key. */
  deleteRoleById?: Maybe<DeleteRolePayload>;
  /** Deletes a single `Scheduler` using its globally unique id. */
  deleteScheduler?: Maybe<DeleteSchedulerPayload>;
  /** Deletes a single `Scheduler` using a unique key. */
  deleteSchedulerById?: Maybe<DeleteSchedulerPayload>;
  /** Deletes a single `Segment` using its globally unique id. */
  deleteSegment?: Maybe<DeleteSegmentPayload>;
  /** Deletes a single `Segment` using a unique key. */
  deleteSegmentById?: Maybe<DeleteSegmentPayload>;
  /** Deletes a single `Setting` using its globally unique id. */
  deleteSetting?: Maybe<DeleteSettingPayload>;
  /** Deletes a single `Setting` using a unique key. */
  deleteSettingById?: Maybe<DeleteSettingPayload>;
  /** Deletes a single `Shipment` using its globally unique id. */
  deleteShipment?: Maybe<DeleteShipmentPayload>;
  /** Deletes a single `Shipment` using a unique key. */
  deleteShipmentById?: Maybe<DeleteShipmentPayload>;
  /** Deletes a single `SpecialDiscount` using its globally unique id. */
  deleteSpecialDiscount?: Maybe<DeleteSpecialDiscountPayload>;
  /** Deletes a single `SpecialDiscount` using a unique key. */
  deleteSpecialDiscountById?: Maybe<DeleteSpecialDiscountPayload>;
  /** Deletes a single `State` using its globally unique id. */
  deleteState?: Maybe<DeleteStatePayload>;
  /** Deletes a single `State` using a unique key. */
  deleteStateById?: Maybe<DeleteStatePayload>;
  /** Deletes a single `Statistic` using its globally unique id. */
  deleteStatistic?: Maybe<DeleteStatisticPayload>;
  /** Deletes a single `Statistic` using a unique key. */
  deleteStatisticById?: Maybe<DeleteStatisticPayload>;
  /** Deletes a single `Stock` using its globally unique id. */
  deleteStock?: Maybe<DeleteStockPayload>;
  /** Deletes a single `Stock` using a unique key. */
  deleteStockById?: Maybe<DeleteStockPayload>;
  /** Deletes a single `Survey` using its globally unique id. */
  deleteSurvey?: Maybe<DeleteSurveyPayload>;
  /** Deletes a single `Survey` using a unique key. */
  deleteSurveyById?: Maybe<DeleteSurveyPayload>;
  /** Deletes a single `Tag` using its globally unique id. */
  deleteTag?: Maybe<DeleteTagPayload>;
  /** Deletes a single `Tag` using a unique key. */
  deleteTagById?: Maybe<DeleteTagPayload>;
  /** Deletes a single `Target` using its globally unique id. */
  deleteTarget?: Maybe<DeleteTargetPayload>;
  /** Deletes a single `Target` using a unique key. */
  deleteTargetById?: Maybe<DeleteTargetPayload>;
  /** Deletes a single `TaxCategory` using its globally unique id. */
  deleteTaxCategory?: Maybe<DeleteTaxCategoryPayload>;
  /** Deletes a single `TaxCategory` using a unique key. */
  deleteTaxCategoryById?: Maybe<DeleteTaxCategoryPayload>;
  /** Deletes a single `TaxRate` using its globally unique id. */
  deleteTaxRate?: Maybe<DeleteTaxRatePayload>;
  /** Deletes a single `TaxRate` using a unique key. */
  deleteTaxRateById?: Maybe<DeleteTaxRatePayload>;
  /** Deletes a single `TaxRule` using its globally unique id. */
  deleteTaxRule?: Maybe<DeleteTaxRulePayload>;
  /** Deletes a single `TaxRule` using a unique key. */
  deleteTaxRuleById?: Maybe<DeleteTaxRulePayload>;
  /** Deletes a single `Template` using its globally unique id. */
  deleteTemplate?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `Template` using a unique key. */
  deleteTemplateById?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `Theme` using its globally unique id. */
  deleteTheme?: Maybe<DeleteThemePayload>;
  /** Deletes a single `Theme` using a unique key. */
  deleteThemeById?: Maybe<DeleteThemePayload>;
  /** Deletes a single `Ticketing` using its globally unique id. */
  deleteTicketing?: Maybe<DeleteTicketingPayload>;
  /** Deletes a single `Ticketing` using a unique key. */
  deleteTicketingById?: Maybe<DeleteTicketingPayload>;
  /** Deletes a single `Training` using its globally unique id. */
  deleteTraining?: Maybe<DeleteTrainingPayload>;
  /** Deletes a single `Training` using a unique key. */
  deleteTrainingById?: Maybe<DeleteTrainingPayload>;
  /** Deletes a single `Transaction` using its globally unique id. */
  deleteTransaction?: Maybe<DeleteTransactionPayload>;
  /** Deletes a single `Transaction` using a unique key. */
  deleteTransactionById?: Maybe<DeleteTransactionPayload>;
  /** Deletes a single `UploadFile` using its globally unique id. */
  deleteUploadFile?: Maybe<DeleteUploadFilePayload>;
  /** Deletes a single `UploadFile` using a unique key. */
  deleteUploadFileById?: Maybe<DeleteUploadFilePayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserById?: Maybe<DeleteUserPayload>;
  /** Deletes a single `Vendor` using its globally unique id. */
  deleteVendor?: Maybe<DeleteVendorPayload>;
  /** Deletes a single `Vendor` using a unique key. */
  deleteVendorById?: Maybe<DeleteVendorPayload>;
  /** Deletes a single `Visit` using its globally unique id. */
  deleteVisit?: Maybe<DeleteVisitPayload>;
  /** Deletes a single `Visit` using a unique key. */
  deleteVisitById?: Maybe<DeleteVisitPayload>;
  /** Deletes a single `Warehouse` using its globally unique id. */
  deleteWarehouse?: Maybe<DeleteWarehousePayload>;
  /** Deletes a single `Warehouse` using a unique key. */
  deleteWarehouseById?: Maybe<DeleteWarehousePayload>;
  /** Deletes a single `Webhook` using its globally unique id. */
  deleteWebhook?: Maybe<DeleteWebhookPayload>;
  /** Deletes a single `Webhook` using a unique key. */
  deleteWebhookById?: Maybe<DeleteWebhookPayload>;
  /** Deletes a single `Website` using its globally unique id. */
  deleteWebsite?: Maybe<DeleteWebsitePayload>;
  /** Deletes a single `Website` using a unique key. */
  deleteWebsiteById?: Maybe<DeleteWebsitePayload>;
  /** Deletes a single `Wishlist` using its globally unique id. */
  deleteWishlist?: Maybe<DeleteWishlistPayload>;
  /** Deletes a single `Wishlist` using a unique key. */
  deleteWishlistById?: Maybe<DeleteWishlistPayload>;
  /** Deletes a single `Workspace` using its globally unique id. */
  deleteWorkspace?: Maybe<DeleteWorkspacePayload>;
  /** Deletes a single `Workspace` using a unique key. */
  deleteWorkspaceById?: Maybe<DeleteWorkspacePayload>;
  /** Deletes a single `Zone` using its globally unique id. */
  deleteZone?: Maybe<DeleteZonePayload>;
  /** Deletes a single `Zone` using a unique key. */
  deleteZoneById?: Maybe<DeleteZonePayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateAccountArgs = {
  input: CreateAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateAgreementArgs = {
  input: CreateAgreementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateAnalyticArgs = {
  input: CreateAnalyticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateApitokenArgs = {
  input: CreateApitokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateArticleArgs = {
  input: CreateArticleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateAttributeArgs = {
  input: CreateAttributeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateBrandArgs = {
  input: CreateBrandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCartPriceRuleArgs = {
  input: CreateCartPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCaseArgs = {
  input: CreateCaseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCatalogPriceRuleArgs = {
  input: CreateCatalogPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCategoryArgs = {
  input: CreateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateChannelArgs = {
  input: CreateChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateChecklistArgs = {
  input: CreateChecklistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCityArgs = {
  input: CreateCityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCollectionArgs = {
  input: CreateCollectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCommentArgs = {
  input: CreateCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateContentTypeArgs = {
  input: CreateContentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateContractArgs = {
  input: CreateContractInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCountryArgs = {
  input: CreateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCouponArgs = {
  input: CreateCouponInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCreditMemoArgs = {
  input: CreateCreditMemoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCurrencyArgs = {
  input: CreateCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCurrencyRateArgs = {
  input: CreateCurrencyRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCurrencySymbolArgs = {
  input: CreateCurrencySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCustomerGroupArgs = {
  input: CreateCustomerGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCustomerArgs = {
  input: CreateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateCustomizationArgs = {
  input: CreateCustomizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateDashboardArgs = {
  input: CreateDashboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateDeepdiveArgs = {
  input: CreateDeepdiveInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateDigiboardArgs = {
  input: CreateDigiboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateEmailArgs = {
  input: CreateEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateEndofshiftArgs = {
  input: CreateEndofshiftInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateEventArgs = {
  input: CreateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateFullfillmentArgs = {
  input: CreateFullfillmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateGiftCertificateArgs = {
  input: CreateGiftCertificateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateGlossaryArgs = {
  input: CreateGlossaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateImportmArgs = {
  input: CreateImportmInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateIntegrationArgs = {
  input: CreateIntegrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateInternalizationArgs = {
  input: CreateInternalizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateInvitationArgs = {
  input: CreateInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateInvoiceArgs = {
  input: CreateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateLeadArgs = {
  input: CreateLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateManufacturerArgs = {
  input: CreateManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMediamanagerArgs = {
  input: CreateMediamanagerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMeetingArgs = {
  input: CreateMeetingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateMessageArgs = {
  input: CreateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateNewsletterArgs = {
  input: CreateNewsletterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateOotoArgs = {
  input: CreateOotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateOpportunityArgs = {
  input: CreateOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateOrderArgs = {
  input: CreateOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePageArgs = {
  input: CreatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePartnerArgs = {
  input: CreatePartnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePaymentArgs = {
  input: CreatePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePermissionArgs = {
  input: CreatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePluginArgs = {
  input: CreatePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreatePollArgs = {
  input: CreatePollInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProductTypeArgs = {
  input: CreateProductTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProductArgs = {
  input: CreateProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProjectArgs = {
  input: CreateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateProviderArgs = {
  input: CreateProviderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateQuoteArgs = {
  input: CreateQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateRatingArgs = {
  input: CreateRatingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateReportArgs = {
  input: CreateReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateReturnArgs = {
  input: CreateReturnInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateReviewArgs = {
  input: CreateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateRewardArgs = {
  input: CreateRewardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateRoleArgs = {
  input: CreateRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSchedulerArgs = {
  input: CreateSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSegmentArgs = {
  input: CreateSegmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSettingArgs = {
  input: CreateSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateShipmentArgs = {
  input: CreateShipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSpecialDiscountArgs = {
  input: CreateSpecialDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateStateArgs = {
  input: CreateStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateStatisticArgs = {
  input: CreateStatisticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateStockArgs = {
  input: CreateStockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateSurveyArgs = {
  input: CreateSurveyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTagArgs = {
  input: CreateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTargetArgs = {
  input: CreateTargetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTaxCategoryArgs = {
  input: CreateTaxCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTaxRateArgs = {
  input: CreateTaxRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTaxRuleArgs = {
  input: CreateTaxRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTemplateArgs = {
  input: CreateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateThemeArgs = {
  input: CreateThemeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTicketingArgs = {
  input: CreateTicketingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTrainingArgs = {
  input: CreateTrainingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateTransactionArgs = {
  input: CreateTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateUploadFileArgs = {
  input: CreateUploadFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateVendorArgs = {
  input: CreateVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateVisitArgs = {
  input: CreateVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWarehouseArgs = {
  input: CreateWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWebhookArgs = {
  input: CreateWebhookInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWebsiteArgs = {
  input: CreateWebsiteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWishlistArgs = {
  input: CreateWishlistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateWorkspaceArgs = {
  input: CreateWorkspaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationcreateZoneArgs = {
  input: CreateZoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAccountArgs = {
  input: UpdateAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAccountByIdArgs = {
  input: UpdateAccountByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAgreementArgs = {
  input: UpdateAgreementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAgreementByIdArgs = {
  input: UpdateAgreementByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAnalyticArgs = {
  input: UpdateAnalyticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAnalyticByIdArgs = {
  input: UpdateAnalyticByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateApitokenArgs = {
  input: UpdateApitokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateApitokenByIdArgs = {
  input: UpdateApitokenByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateArticleArgs = {
  input: UpdateArticleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateArticleByIdArgs = {
  input: UpdateArticleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAttributeArgs = {
  input: UpdateAttributeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateAttributeByIdArgs = {
  input: UpdateAttributeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateBrandArgs = {
  input: UpdateBrandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateBrandByIdArgs = {
  input: UpdateBrandByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCartPriceRuleArgs = {
  input: UpdateCartPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCartPriceRuleByIdArgs = {
  input: UpdateCartPriceRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCaseArgs = {
  input: UpdateCaseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCaseByIdArgs = {
  input: UpdateCaseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCatalogPriceRuleArgs = {
  input: UpdateCatalogPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCatalogPriceRuleByIdArgs = {
  input: UpdateCatalogPriceRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCategoryArgs = {
  input: UpdateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCategoryByIdArgs = {
  input: UpdateCategoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateChannelArgs = {
  input: UpdateChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateChannelByIdArgs = {
  input: UpdateChannelByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateChecklistArgs = {
  input: UpdateChecklistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateChecklistByIdArgs = {
  input: UpdateChecklistByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCityArgs = {
  input: UpdateCityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCityByIdArgs = {
  input: UpdateCityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCollectionArgs = {
  input: UpdateCollectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCollectionByIdArgs = {
  input: UpdateCollectionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCommentArgs = {
  input: UpdateCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCommentByIdArgs = {
  input: UpdateCommentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateContentTypeArgs = {
  input: UpdateContentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateContentTypeByIdArgs = {
  input: UpdateContentTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateContractArgs = {
  input: UpdateContractInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateContractByIdArgs = {
  input: UpdateContractByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCountryArgs = {
  input: UpdateCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCountryByIdArgs = {
  input: UpdateCountryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCouponArgs = {
  input: UpdateCouponInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCouponByIdArgs = {
  input: UpdateCouponByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCreditMemoArgs = {
  input: UpdateCreditMemoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCreditMemoByCreditMemoAndIdArgs = {
  input: UpdateCreditMemoByCreditMemoAndIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencyArgs = {
  input: UpdateCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencyByIdArgs = {
  input: UpdateCurrencyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencyRateArgs = {
  input: UpdateCurrencyRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencyRateByImportServiceArgs = {
  input: UpdateCurrencyRateByImportServiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencySymbolArgs = {
  input: UpdateCurrencySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCurrencySymbolBySymbolArgs = {
  input: UpdateCurrencySymbolBySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomerGroupArgs = {
  input: UpdateCustomerGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomerGroupByIdArgs = {
  input: UpdateCustomerGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomerArgs = {
  input: UpdateCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomerByIdArgs = {
  input: UpdateCustomerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomizationArgs = {
  input: UpdateCustomizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateCustomizationByIdArgs = {
  input: UpdateCustomizationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDashboardArgs = {
  input: UpdateDashboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDashboardByIdArgs = {
  input: UpdateDashboardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDeepdiveArgs = {
  input: UpdateDeepdiveInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDeepdiveByIdArgs = {
  input: UpdateDeepdiveByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDigiboardArgs = {
  input: UpdateDigiboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateDigiboardByIdArgs = {
  input: UpdateDigiboardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEmailArgs = {
  input: UpdateEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEmailByIdArgs = {
  input: UpdateEmailByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEndofshiftArgs = {
  input: UpdateEndofshiftInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEndofshiftByIdArgs = {
  input: UpdateEndofshiftByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEventArgs = {
  input: UpdateEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateEventByIdArgs = {
  input: UpdateEventByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateFullfillmentArgs = {
  input: UpdateFullfillmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateFullfillmentByIdArgs = {
  input: UpdateFullfillmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateGiftCertificateArgs = {
  input: UpdateGiftCertificateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateGiftCertificateByIdArgs = {
  input: UpdateGiftCertificateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateGlossaryArgs = {
  input: UpdateGlossaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateGlossaryByIdArgs = {
  input: UpdateGlossaryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateImportmArgs = {
  input: UpdateImportmInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateImportmByIdArgs = {
  input: UpdateImportmByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateIntegrationArgs = {
  input: UpdateIntegrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateIntegrationByIdArgs = {
  input: UpdateIntegrationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInternalizationArgs = {
  input: UpdateInternalizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInternalizationByIdArgs = {
  input: UpdateInternalizationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInvitationArgs = {
  input: UpdateInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInvitationByIdArgs = {
  input: UpdateInvitationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInvoiceArgs = {
  input: UpdateInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateInvoiceByIdArgs = {
  input: UpdateInvoiceByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateLeadArgs = {
  input: UpdateLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateLeadByIdArgs = {
  input: UpdateLeadByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateManufacturerArgs = {
  input: UpdateManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateManufacturerByIdArgs = {
  input: UpdateManufacturerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMediamanagerArgs = {
  input: UpdateMediamanagerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMediamanagerByIdArgs = {
  input: UpdateMediamanagerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMeetingArgs = {
  input: UpdateMeetingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMeetingByIdArgs = {
  input: UpdateMeetingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMessageArgs = {
  input: UpdateMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateMessageByIdArgs = {
  input: UpdateMessageByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateNewsletterArgs = {
  input: UpdateNewsletterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateNewsletterByIdArgs = {
  input: UpdateNewsletterByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOotoArgs = {
  input: UpdateOotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOotoByIdArgs = {
  input: UpdateOotoByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOpportunityArgs = {
  input: UpdateOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOpportunityByIdArgs = {
  input: UpdateOpportunityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOrderArgs = {
  input: UpdateOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateOrderByIdArgs = {
  input: UpdateOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePageArgs = {
  input: UpdatePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePageByIdArgs = {
  input: UpdatePageByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePartnerArgs = {
  input: UpdatePartnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePartnerByIdArgs = {
  input: UpdatePartnerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePaymentArgs = {
  input: UpdatePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePaymentByIdArgs = {
  input: UpdatePaymentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePermissionArgs = {
  input: UpdatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePermissionByIdArgs = {
  input: UpdatePermissionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePluginArgs = {
  input: UpdatePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePluginByIdArgs = {
  input: UpdatePluginByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePollArgs = {
  input: UpdatePollInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdatePollByIdArgs = {
  input: UpdatePollByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProductTypeArgs = {
  input: UpdateProductTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProductTypeByIdArgs = {
  input: UpdateProductTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProductArgs = {
  input: UpdateProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProductByIdArgs = {
  input: UpdateProductByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProjectArgs = {
  input: UpdateProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProjectByIdArgs = {
  input: UpdateProjectByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProviderArgs = {
  input: UpdateProviderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateProviderByIdArgs = {
  input: UpdateProviderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateQuoteArgs = {
  input: UpdateQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateQuoteByIdArgs = {
  input: UpdateQuoteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRatingArgs = {
  input: UpdateRatingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRatingByIdArgs = {
  input: UpdateRatingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReportArgs = {
  input: UpdateReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReportByIdArgs = {
  input: UpdateReportByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReturnArgs = {
  input: UpdateReturnInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReturnByIdArgs = {
  input: UpdateReturnByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReviewArgs = {
  input: UpdateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateReviewByIdArgs = {
  input: UpdateReviewByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRewardArgs = {
  input: UpdateRewardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRewardByIdArgs = {
  input: UpdateRewardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRoleArgs = {
  input: UpdateRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateRoleByIdArgs = {
  input: UpdateRoleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSchedulerArgs = {
  input: UpdateSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSchedulerByIdArgs = {
  input: UpdateSchedulerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSegmentArgs = {
  input: UpdateSegmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSegmentByIdArgs = {
  input: UpdateSegmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSettingArgs = {
  input: UpdateSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSettingByIdArgs = {
  input: UpdateSettingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateShipmentArgs = {
  input: UpdateShipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateShipmentByIdArgs = {
  input: UpdateShipmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSpecialDiscountArgs = {
  input: UpdateSpecialDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSpecialDiscountByIdArgs = {
  input: UpdateSpecialDiscountByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStateArgs = {
  input: UpdateStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStateByIdArgs = {
  input: UpdateStateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStatisticArgs = {
  input: UpdateStatisticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStatisticByIdArgs = {
  input: UpdateStatisticByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStockArgs = {
  input: UpdateStockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateStockByIdArgs = {
  input: UpdateStockByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSurveyArgs = {
  input: UpdateSurveyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateSurveyByIdArgs = {
  input: UpdateSurveyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTagArgs = {
  input: UpdateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTagByIdArgs = {
  input: UpdateTagByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTargetArgs = {
  input: UpdateTargetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTargetByIdArgs = {
  input: UpdateTargetByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxCategoryArgs = {
  input: UpdateTaxCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxCategoryByIdArgs = {
  input: UpdateTaxCategoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxRateArgs = {
  input: UpdateTaxRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxRateByIdArgs = {
  input: UpdateTaxRateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxRuleArgs = {
  input: UpdateTaxRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTaxRuleByIdArgs = {
  input: UpdateTaxRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTemplateArgs = {
  input: UpdateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTemplateByIdArgs = {
  input: UpdateTemplateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateThemeArgs = {
  input: UpdateThemeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateThemeByIdArgs = {
  input: UpdateThemeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTicketingArgs = {
  input: UpdateTicketingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTicketingByIdArgs = {
  input: UpdateTicketingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTrainingArgs = {
  input: UpdateTrainingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTrainingByIdArgs = {
  input: UpdateTrainingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTransactionArgs = {
  input: UpdateTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateTransactionByIdArgs = {
  input: UpdateTransactionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUploadFileArgs = {
  input: UpdateUploadFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUploadFileByIdArgs = {
  input: UpdateUploadFileByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateUserByIdArgs = {
  input: UpdateUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateVendorArgs = {
  input: UpdateVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateVendorByIdArgs = {
  input: UpdateVendorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateVisitArgs = {
  input: UpdateVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateVisitByIdArgs = {
  input: UpdateVisitByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWarehouseArgs = {
  input: UpdateWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWarehouseByIdArgs = {
  input: UpdateWarehouseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWebhookArgs = {
  input: UpdateWebhookInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWebhookByIdArgs = {
  input: UpdateWebhookByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWebsiteArgs = {
  input: UpdateWebsiteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWebsiteByIdArgs = {
  input: UpdateWebsiteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWishlistArgs = {
  input: UpdateWishlistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWishlistByIdArgs = {
  input: UpdateWishlistByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWorkspaceArgs = {
  input: UpdateWorkspaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateWorkspaceByIdArgs = {
  input: UpdateWorkspaceByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateZoneArgs = {
  input: UpdateZoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationupdateZoneByIdArgs = {
  input: UpdateZoneByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAccountArgs = {
  input: DeleteAccountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAccountByIdArgs = {
  input: DeleteAccountByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAgreementArgs = {
  input: DeleteAgreementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAgreementByIdArgs = {
  input: DeleteAgreementByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAnalyticArgs = {
  input: DeleteAnalyticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAnalyticByIdArgs = {
  input: DeleteAnalyticByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteApitokenArgs = {
  input: DeleteApitokenInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteApitokenByIdArgs = {
  input: DeleteApitokenByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteArticleArgs = {
  input: DeleteArticleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteArticleByIdArgs = {
  input: DeleteArticleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAttributeArgs = {
  input: DeleteAttributeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteAttributeByIdArgs = {
  input: DeleteAttributeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteBrandArgs = {
  input: DeleteBrandInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteBrandByIdArgs = {
  input: DeleteBrandByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCartPriceRuleArgs = {
  input: DeleteCartPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCartPriceRuleByIdArgs = {
  input: DeleteCartPriceRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCaseArgs = {
  input: DeleteCaseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCaseByIdArgs = {
  input: DeleteCaseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCatalogPriceRuleArgs = {
  input: DeleteCatalogPriceRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCatalogPriceRuleByIdArgs = {
  input: DeleteCatalogPriceRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCategoryArgs = {
  input: DeleteCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCategoryByIdArgs = {
  input: DeleteCategoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteChannelArgs = {
  input: DeleteChannelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteChannelByIdArgs = {
  input: DeleteChannelByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteChecklistArgs = {
  input: DeleteChecklistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteChecklistByIdArgs = {
  input: DeleteChecklistByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCityArgs = {
  input: DeleteCityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCityByIdArgs = {
  input: DeleteCityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCollectionArgs = {
  input: DeleteCollectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCollectionByIdArgs = {
  input: DeleteCollectionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCommentArgs = {
  input: DeleteCommentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCommentByIdArgs = {
  input: DeleteCommentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteContentTypeArgs = {
  input: DeleteContentTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteContentTypeByIdArgs = {
  input: DeleteContentTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteContractArgs = {
  input: DeleteContractInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteContractByIdArgs = {
  input: DeleteContractByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCountryArgs = {
  input: DeleteCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCountryByIdArgs = {
  input: DeleteCountryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCouponArgs = {
  input: DeleteCouponInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCouponByIdArgs = {
  input: DeleteCouponByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCreditMemoArgs = {
  input: DeleteCreditMemoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCreditMemoByCreditMemoAndIdArgs = {
  input: DeleteCreditMemoByCreditMemoAndIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencyArgs = {
  input: DeleteCurrencyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencyByIdArgs = {
  input: DeleteCurrencyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencyRateArgs = {
  input: DeleteCurrencyRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencyRateByImportServiceArgs = {
  input: DeleteCurrencyRateByImportServiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencySymbolArgs = {
  input: DeleteCurrencySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCurrencySymbolBySymbolArgs = {
  input: DeleteCurrencySymbolBySymbolInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomerGroupArgs = {
  input: DeleteCustomerGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomerGroupByIdArgs = {
  input: DeleteCustomerGroupByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomerArgs = {
  input: DeleteCustomerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomerByIdArgs = {
  input: DeleteCustomerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomizationArgs = {
  input: DeleteCustomizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteCustomizationByIdArgs = {
  input: DeleteCustomizationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDashboardArgs = {
  input: DeleteDashboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDashboardByIdArgs = {
  input: DeleteDashboardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDeepdiveArgs = {
  input: DeleteDeepdiveInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDeepdiveByIdArgs = {
  input: DeleteDeepdiveByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDigiboardArgs = {
  input: DeleteDigiboardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteDigiboardByIdArgs = {
  input: DeleteDigiboardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEmailArgs = {
  input: DeleteEmailInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEmailByIdArgs = {
  input: DeleteEmailByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEndofshiftArgs = {
  input: DeleteEndofshiftInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEndofshiftByIdArgs = {
  input: DeleteEndofshiftByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEventArgs = {
  input: DeleteEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteEventByIdArgs = {
  input: DeleteEventByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteFullfillmentArgs = {
  input: DeleteFullfillmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteFullfillmentByIdArgs = {
  input: DeleteFullfillmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteGiftCertificateArgs = {
  input: DeleteGiftCertificateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteGiftCertificateByIdArgs = {
  input: DeleteGiftCertificateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteGlossaryArgs = {
  input: DeleteGlossaryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteGlossaryByIdArgs = {
  input: DeleteGlossaryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteImportmArgs = {
  input: DeleteImportmInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteImportmByIdArgs = {
  input: DeleteImportmByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteIntegrationArgs = {
  input: DeleteIntegrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteIntegrationByIdArgs = {
  input: DeleteIntegrationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInternalizationArgs = {
  input: DeleteInternalizationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInternalizationByIdArgs = {
  input: DeleteInternalizationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInvitationArgs = {
  input: DeleteInvitationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInvitationByIdArgs = {
  input: DeleteInvitationByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInvoiceArgs = {
  input: DeleteInvoiceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteInvoiceByIdArgs = {
  input: DeleteInvoiceByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteLeadArgs = {
  input: DeleteLeadInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteLeadByIdArgs = {
  input: DeleteLeadByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteManufacturerArgs = {
  input: DeleteManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteManufacturerByIdArgs = {
  input: DeleteManufacturerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMediamanagerArgs = {
  input: DeleteMediamanagerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMediamanagerByIdArgs = {
  input: DeleteMediamanagerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMeetingArgs = {
  input: DeleteMeetingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMeetingByIdArgs = {
  input: DeleteMeetingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMessageArgs = {
  input: DeleteMessageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteMessageByIdArgs = {
  input: DeleteMessageByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteNewsletterArgs = {
  input: DeleteNewsletterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteNewsletterByIdArgs = {
  input: DeleteNewsletterByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOotoArgs = {
  input: DeleteOotoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOotoByIdArgs = {
  input: DeleteOotoByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOpportunityArgs = {
  input: DeleteOpportunityInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOpportunityByIdArgs = {
  input: DeleteOpportunityByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOrderArgs = {
  input: DeleteOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteOrderByIdArgs = {
  input: DeleteOrderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePageArgs = {
  input: DeletePageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePageByIdArgs = {
  input: DeletePageByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePartnerArgs = {
  input: DeletePartnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePartnerByIdArgs = {
  input: DeletePartnerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePaymentArgs = {
  input: DeletePaymentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePaymentByIdArgs = {
  input: DeletePaymentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePermissionArgs = {
  input: DeletePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePermissionByIdArgs = {
  input: DeletePermissionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePluginArgs = {
  input: DeletePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePluginByIdArgs = {
  input: DeletePluginByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePollArgs = {
  input: DeletePollInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeletePollByIdArgs = {
  input: DeletePollByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProductTypeArgs = {
  input: DeleteProductTypeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProductTypeByIdArgs = {
  input: DeleteProductTypeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProductArgs = {
  input: DeleteProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProductByIdArgs = {
  input: DeleteProductByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProjectArgs = {
  input: DeleteProjectInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProjectByIdArgs = {
  input: DeleteProjectByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProviderArgs = {
  input: DeleteProviderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteProviderByIdArgs = {
  input: DeleteProviderByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteQuoteArgs = {
  input: DeleteQuoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteQuoteByIdArgs = {
  input: DeleteQuoteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRatingArgs = {
  input: DeleteRatingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRatingByIdArgs = {
  input: DeleteRatingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReportArgs = {
  input: DeleteReportInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReportByIdArgs = {
  input: DeleteReportByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReturnArgs = {
  input: DeleteReturnInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReturnByIdArgs = {
  input: DeleteReturnByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReviewArgs = {
  input: DeleteReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteReviewByIdArgs = {
  input: DeleteReviewByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRewardArgs = {
  input: DeleteRewardInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRewardByIdArgs = {
  input: DeleteRewardByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRoleArgs = {
  input: DeleteRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteRoleByIdArgs = {
  input: DeleteRoleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSchedulerArgs = {
  input: DeleteSchedulerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSchedulerByIdArgs = {
  input: DeleteSchedulerByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSegmentArgs = {
  input: DeleteSegmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSegmentByIdArgs = {
  input: DeleteSegmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSettingArgs = {
  input: DeleteSettingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSettingByIdArgs = {
  input: DeleteSettingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteShipmentArgs = {
  input: DeleteShipmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteShipmentByIdArgs = {
  input: DeleteShipmentByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSpecialDiscountArgs = {
  input: DeleteSpecialDiscountInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSpecialDiscountByIdArgs = {
  input: DeleteSpecialDiscountByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStateArgs = {
  input: DeleteStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStateByIdArgs = {
  input: DeleteStateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStatisticArgs = {
  input: DeleteStatisticInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStatisticByIdArgs = {
  input: DeleteStatisticByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStockArgs = {
  input: DeleteStockInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteStockByIdArgs = {
  input: DeleteStockByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSurveyArgs = {
  input: DeleteSurveyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteSurveyByIdArgs = {
  input: DeleteSurveyByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTagArgs = {
  input: DeleteTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTagByIdArgs = {
  input: DeleteTagByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTargetArgs = {
  input: DeleteTargetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTargetByIdArgs = {
  input: DeleteTargetByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxCategoryArgs = {
  input: DeleteTaxCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxCategoryByIdArgs = {
  input: DeleteTaxCategoryByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxRateArgs = {
  input: DeleteTaxRateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxRateByIdArgs = {
  input: DeleteTaxRateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxRuleArgs = {
  input: DeleteTaxRuleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTaxRuleByIdArgs = {
  input: DeleteTaxRuleByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTemplateArgs = {
  input: DeleteTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTemplateByIdArgs = {
  input: DeleteTemplateByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteThemeArgs = {
  input: DeleteThemeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteThemeByIdArgs = {
  input: DeleteThemeByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTicketingArgs = {
  input: DeleteTicketingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTicketingByIdArgs = {
  input: DeleteTicketingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTrainingArgs = {
  input: DeleteTrainingInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTrainingByIdArgs = {
  input: DeleteTrainingByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTransactionArgs = {
  input: DeleteTransactionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteTransactionByIdArgs = {
  input: DeleteTransactionByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteUploadFileArgs = {
  input: DeleteUploadFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteUploadFileByIdArgs = {
  input: DeleteUploadFileByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteUserByIdArgs = {
  input: DeleteUserByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteVendorArgs = {
  input: DeleteVendorInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteVendorByIdArgs = {
  input: DeleteVendorByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteVisitArgs = {
  input: DeleteVisitInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteVisitByIdArgs = {
  input: DeleteVisitByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWarehouseArgs = {
  input: DeleteWarehouseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWarehouseByIdArgs = {
  input: DeleteWarehouseByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWebhookArgs = {
  input: DeleteWebhookInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWebhookByIdArgs = {
  input: DeleteWebhookByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWebsiteArgs = {
  input: DeleteWebsiteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWebsiteByIdArgs = {
  input: DeleteWebsiteByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWishlistArgs = {
  input: DeleteWishlistInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWishlistByIdArgs = {
  input: DeleteWishlistByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWorkspaceArgs = {
  input: DeleteWorkspaceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteWorkspaceByIdArgs = {
  input: DeleteWorkspaceByIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteZoneArgs = {
  input: DeleteZoneInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationdeleteZoneByIdArgs = {
  input: DeleteZoneByIdInput;
};

/** The output of our create `Account` mutation. */
export type CreateAccountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was created by this mutation. */
  account?: Maybe<Account>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our create `Account` mutation. */
export type CreateAccountPayloadaccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the create `Account` mutation. */
export type CreateAccountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Account` to be created by this mutation. */
  account: AccountInput;
};

/** An input for mutations affecting `Account` */
export type AccountInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  industry?: InputMaybe<Scalars['String']>;
  employees?: InputMaybe<Scalars['String']>;
  annualRevenue?: InputMaybe<Scalars['String']>;
  memberOf?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Agreement` mutation. */
export type CreateAgreementPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agreement` that was created by this mutation. */
  agreement?: Maybe<Agreement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Agreement`. May be used by Relay 1. */
  agreementEdge?: Maybe<AgreementsEdge>;
};


/** The output of our create `Agreement` mutation. */
export type CreateAgreementPayloadagreementEdgeArgs = {
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
};

/** All input for the create `Agreement` mutation. */
export type CreateAgreementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Agreement` to be created by this mutation. */
  agreement: AgreementInput;
};

/** An input for mutations affecting `Agreement` */
export type AgreementInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  referenceId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  content?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['String']>;
  shopId?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Analytic` mutation. */
export type CreateAnalyticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Analytic` that was created by this mutation. */
  analytic?: Maybe<Analytic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Analytic`. May be used by Relay 1. */
  analyticEdge?: Maybe<AnalyticsEdge>;
};


/** The output of our create `Analytic` mutation. */
export type CreateAnalyticPayloadanalyticEdgeArgs = {
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
};

/** All input for the create `Analytic` mutation. */
export type CreateAnalyticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Analytic` to be created by this mutation. */
  analytic: AnalyticInput;
};

/** An input for mutations affecting `Analytic` */
export type AnalyticInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  shareData?: InputMaybe<Scalars['String']>;
  websiteName?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  trackingId?: InputMaybe<Scalars['String']>;
  propertyName?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  defaultView?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  propertyHit?: InputMaybe<Scalars['String']>;
  trackingCode?: InputMaybe<Scalars['String']>;
  dataCollection?: InputMaybe<Scalars['Boolean']>;
  dataRetention?: InputMaybe<Scalars['Boolean']>;
  searchAnalytics?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Apitoken` mutation. */
export type CreateApitokenPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Apitoken` that was created by this mutation. */
  apitoken?: Maybe<Apitoken>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Apitoken`. May be used by Relay 1. */
  apitokenEdge?: Maybe<ApitokensEdge>;
};


/** The output of our create `Apitoken` mutation. */
export type CreateApitokenPayloadapitokenEdgeArgs = {
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
};

/** All input for the create `Apitoken` mutation. */
export type CreateApitokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Apitoken` to be created by this mutation. */
  apitoken: ApitokenInput;
};

/** An input for mutations affecting `Apitoken` */
export type ApitokenInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name: Scalars['String'];
  tokenType?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  token: Scalars['BigInt'];
};

/** The output of our create `Article` mutation. */
export type CreateArticlePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Article` that was created by this mutation. */
  article?: Maybe<Article>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Article`. May be used by Relay 1. */
  articleEdge?: Maybe<ArticlesEdge>;
};


/** The output of our create `Article` mutation. */
export type CreateArticlePayloadarticleEdgeArgs = {
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
};

/** All input for the create `Article` mutation. */
export type CreateArticleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Article` to be created by this mutation. */
  article: ArticleInput;
};

/** An input for mutations affecting `Article` */
export type ArticleInput = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaName?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Attribute` mutation. */
export type CreateAttributePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Attribute` that was created by this mutation. */
  attribute?: Maybe<Attribute>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Attribute`. May be used by Relay 1. */
  attributeEdge?: Maybe<AttributesEdge>;
};


/** The output of our create `Attribute` mutation. */
export type CreateAttributePayloadattributeEdgeArgs = {
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
};

/** All input for the create `Attribute` mutation. */
export type CreateAttributeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Attribute` to be created by this mutation. */
  attribute: AttributeInput;
};

/** An input for mutations affecting `Attribute` */
export type AttributeInput = {
  id?: InputMaybe<Scalars['Int']>;
  defaultLabel?: InputMaybe<Scalars['String']>;
  attributeCode?: InputMaybe<Scalars['String']>;
  filterOptions?: InputMaybe<Scalars['String']>;
  useSearch?: InputMaybe<Scalars['String']>;
  layeredNavigation?: InputMaybe<Scalars['Boolean']>;
  searchResultsLayeredNavigation?: InputMaybe<Scalars['Boolean']>;
  position?: InputMaybe<Scalars['String']>;
  promoRuleConditions?: InputMaybe<Scalars['Boolean']>;
  allowHtmlTagsStorefront?: InputMaybe<Scalars['Boolean']>;
  visibleCatalogPagesStorefront?: InputMaybe<Scalars['Boolean']>;
  usedProductListing?: InputMaybe<Scalars['Boolean']>;
  usedSortingProductListing?: InputMaybe<Scalars['Boolean']>;
  prodId: Scalars['BigInt'];
  attributeClass?: InputMaybe<Scalars['String']>;
  attributeValue?: InputMaybe<Scalars['String']>;
  columnOptions?: InputMaybe<Scalars['String']>;
  facetedNavigation?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaName?: InputMaybe<Scalars['Boolean']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  productAttributeSet?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Brand` mutation. */
export type CreateBrandPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Brand` that was created by this mutation. */
  brand?: Maybe<Brand>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<BrandsEdge>;
};


/** The output of our create `Brand` mutation. */
export type CreateBrandPayloadbrandEdgeArgs = {
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
};

/** All input for the create `Brand` mutation. */
export type CreateBrandInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Brand` to be created by this mutation. */
  brand: BrandInput;
};

/** An input for mutations affecting `Brand` */
export type BrandInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `CartPriceRule` mutation. */
export type CreateCartPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CartPriceRule` that was created by this mutation. */
  cartPriceRule?: Maybe<CartPriceRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CartPriceRule`. May be used by Relay 1. */
  cartPriceRuleEdge?: Maybe<CartPriceRulesEdge>;
};


/** The output of our create `CartPriceRule` mutation. */
export type CreateCartPriceRulePayloadcartPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
};

/** All input for the create `CartPriceRule` mutation. */
export type CreateCartPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CartPriceRule` to be created by this mutation. */
  cartPriceRule: CartPriceRuleInput;
};

/** An input for mutations affecting `CartPriceRule` */
export type CartPriceRuleInput = {
  id?: InputMaybe<Scalars['Int']>;
  rule?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  coupon?: InputMaybe<Scalars['String']>;
  usesPerCustomer?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  actionsApply?: InputMaybe<Scalars['String']>;
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
  actionsMaxQtyDiscountIsAppliedTo?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscountQtyStep?: InputMaybe<Scalars['BigFloat']>;
  actionsApplyShippingAmount?: InputMaybe<Scalars['Boolean']>;
};

/** The output of our create `Case` mutation. */
export type CreateCasePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Case` that was created by this mutation. */
  case?: Maybe<Case>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Case`. May be used by Relay 1. */
  caseEdge?: Maybe<CasesEdge>;
};


/** The output of our create `Case` mutation. */
export type CreateCasePayloadcaseEdgeArgs = {
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
};

/** All input for the create `Case` mutation. */
export type CreateCaseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Case` to be created by this mutation. */
  case: CaseInput;
};

/** An input for mutations affecting `Case` */
export type CaseInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  caseNumber?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  resolution?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  dateModified?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `CatalogPriceRule` mutation. */
export type CreateCatalogPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CatalogPriceRule` that was created by this mutation. */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CatalogPriceRule`. May be used by Relay 1. */
  catalogPriceRuleEdge?: Maybe<CatalogPriceRulesEdge>;
};


/** The output of our create `CatalogPriceRule` mutation. */
export type CreateCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
};

/** All input for the create `CatalogPriceRule` mutation. */
export type CreateCatalogPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CatalogPriceRule` to be created by this mutation. */
  catalogPriceRule: CatalogPriceRuleInput;
};

/** An input for mutations affecting `CatalogPriceRule` */
export type CatalogPriceRuleInput = {
  id?: InputMaybe<Scalars['Int']>;
  rule?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  customerGroups?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  actionsApply?: InputMaybe<Scalars['String']>;
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
};

/** The output of our create `Category` mutation. */
export type CreateCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Category` that was created by this mutation. */
  category?: Maybe<Category>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<CategoriesEdge>;
};


/** The output of our create `Category` mutation. */
export type CreateCategoryPayloadcategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
};

/** All input for the create `Category` mutation. */
export type CreateCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Category` to be created by this mutation. */
  category: CategoryInput;
};

/** An input for mutations affecting `Category` */
export type CategoryInput = {
  id?: InputMaybe<Scalars['Int']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  visibility?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['Boolean']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Channel` mutation. */
export type CreateChannelPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Channel` that was created by this mutation. */
  channel?: Maybe<Channel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Channel`. May be used by Relay 1. */
  channelEdge?: Maybe<ChannelsEdge>;
};


/** The output of our create `Channel` mutation. */
export type CreateChannelPayloadchannelEdgeArgs = {
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
};

/** All input for the create `Channel` mutation. */
export type CreateChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Channel` to be created by this mutation. */
  channel: ChannelInput;
};

/** An input for mutations affecting `Channel` */
export type ChannelInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  defaultLang?: InputMaybe<Scalars['String']>;
  includeTax?: InputMaybe<Scalars['String']>;
  defaultZone?: InputMaybe<Scalars['String']>;
  defaultShipping?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Checklist` mutation. */
export type CreateChecklistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Checklist` that was created by this mutation. */
  checklist?: Maybe<Checklist>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Checklist`. May be used by Relay 1. */
  checklistEdge?: Maybe<ChecklistsEdge>;
};


/** The output of our create `Checklist` mutation. */
export type CreateChecklistPayloadchecklistEdgeArgs = {
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
};

/** All input for the create `Checklist` mutation. */
export type CreateChecklistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Checklist` to be created by this mutation. */
  checklist: ChecklistInput;
};

/** An input for mutations affecting `Checklist` */
export type ChecklistInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  username?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  regionalManager?: InputMaybe<Scalars['String']>;
  manager?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  ticket?: InputMaybe<Scalars['String']>;
  project?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** The output of our create `City` mutation. */
export type CreateCityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `City` that was created by this mutation. */
  city?: Maybe<City>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `City`. May be used by Relay 1. */
  cityEdge?: Maybe<CitiesEdge>;
};


/** The output of our create `City` mutation. */
export type CreateCityPayloadcityEdgeArgs = {
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
};

/** All input for the create `City` mutation. */
export type CreateCityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `City` to be created by this mutation. */
  city: CityInput;
};

/** An input for mutations affecting `City` */
export type CityInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postalCode?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Collection` mutation. */
export type CreateCollectionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Collection` that was created by this mutation. */
  collection?: Maybe<Collection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Collection`. May be used by Relay 1. */
  collectionEdge?: Maybe<CollectionsEdge>;
};


/** The output of our create `Collection` mutation. */
export type CreateCollectionPayloadcollectionEdgeArgs = {
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
};

/** All input for the create `Collection` mutation. */
export type CreateCollectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Collection` to be created by this mutation. */
  collection: CollectionInput;
};

/** An input for mutations affecting `Collection` */
export type CollectionInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Comment` mutation. */
export type CreateCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Comment` that was created by this mutation. */
  comment?: Maybe<Comment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  commentEdge?: Maybe<CommentsEdge>;
};


/** The output of our create `Comment` mutation. */
export type CreateCommentPayloadcommentEdgeArgs = {
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
};

/** All input for the create `Comment` mutation. */
export type CreateCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Comment` to be created by this mutation. */
  comment: CommentInput;
};

/** An input for mutations affecting `Comment` */
export type CommentInput = {
  id?: InputMaybe<Scalars['Int']>;
  customerName: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  response?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  custId: Scalars['Int'];
  customers?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** The output of our create `ContentType` mutation. */
export type CreateContentTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContentType` that was created by this mutation. */
  contentType?: Maybe<ContentType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ContentType`. May be used by Relay 1. */
  contentTypeEdge?: Maybe<ContentTypesEdge>;
};


/** The output of our create `ContentType` mutation. */
export type CreateContentTypePayloadcontentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
};

/** All input for the create `ContentType` mutation. */
export type CreateContentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ContentType` to be created by this mutation. */
  contentType: ContentTypeInput;
};

/** An input for mutations affecting `ContentType` */
export type ContentTypeInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  text?: InputMaybe<Scalars['String']>;
  number?: InputMaybe<Scalars['BigFloat']>;
  json?: InputMaybe<Scalars['JSON']>;
  link?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  uid?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['Date']>;
  time?: InputMaybe<Scalars['Time']>;
  timestamp?: InputMaybe<Scalars['Datetime']>;
  boolean?: InputMaybe<Scalars['Boolean']>;
  richText?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  databaseName?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Contract` mutation. */
export type CreateContractPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Contract` that was created by this mutation. */
  contract?: Maybe<Contract>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Contract`. May be used by Relay 1. */
  contractEdge?: Maybe<ContractsEdge>;
};


/** The output of our create `Contract` mutation. */
export type CreateContractPayloadcontractEdgeArgs = {
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
};

/** All input for the create `Contract` mutation. */
export type CreateContractInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Contract` to be created by this mutation. */
  contract: ContractInput;
};

/** An input for mutations affecting `Contract` */
export type ContractInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  contractTitle?: InputMaybe<Scalars['String']>;
  contractValue?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  renewalReminder?: InputMaybe<Scalars['String']>;
  customerSignedDate?: InputMaybe<Scalars['String']>;
  companySignedDate?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  contractManager?: InputMaybe<Scalars['String']>;
  account?: InputMaybe<Scalars['String']>;
  contact?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  opportunity?: InputMaybe<Scalars['String']>;
  contractType?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  lineItems?: InputMaybe<Scalars['String']>;
  total?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  shipping?: InputMaybe<Scalars['String']>;
  shippingTax?: InputMaybe<Scalars['String']>;
  tax?: InputMaybe<Scalars['String']>;
  grandTotal?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `Country` mutation. */
export type CreateCountryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was created by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our create `Country` mutation. */
export type CreateCountryPayloadcountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the create `Country` mutation. */
export type CreateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Country` to be created by this mutation. */
  country: CountryInput;
};

/** An input for mutations affecting `Country` */
export type CountryInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Coupon` mutation. */
export type CreateCouponPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Coupon` that was created by this mutation. */
  coupon?: Maybe<Coupon>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Coupon`. May be used by Relay 1. */
  couponEdge?: Maybe<CouponsEdge>;
};


/** The output of our create `Coupon` mutation. */
export type CreateCouponPayloadcouponEdgeArgs = {
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
};

/** All input for the create `Coupon` mutation. */
export type CreateCouponInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Coupon` to be created by this mutation. */
  coupon: CouponInput;
};

/** An input for mutations affecting `Coupon` */
export type CouponInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  productsCouponsToproducts?: InputMaybe<Scalars['String']>;
};

/** The output of our create `CreditMemo` mutation. */
export type CreateCreditMemoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CreditMemo` that was created by this mutation. */
  creditMemo?: Maybe<CreditMemo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CreditMemo`. May be used by Relay 1. */
  creditMemoEdge?: Maybe<CreditMemosEdge>;
};


/** The output of our create `CreditMemo` mutation. */
export type CreateCreditMemoPayloadcreditMemoEdgeArgs = {
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
};

/** All input for the create `CreditMemo` mutation. */
export type CreateCreditMemoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CreditMemo` to be created by this mutation. */
  creditMemo: CreditMemoInput;
};

/** An input for mutations affecting `CreditMemo` */
export type CreditMemoInput = {
  creditMemo: Scalars['String'];
  orderNumber: Scalars['Int'];
  created?: InputMaybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  status?: InputMaybe<Scalars['String']>;
  refunded?: InputMaybe<Scalars['String']>;
  action?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Currency` mutation. */
export type CreateCurrencyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Currency` that was created by this mutation. */
  currency?: Maybe<Currency>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Currency`. May be used by Relay 1. */
  currencyEdge?: Maybe<CurrenciesEdge>;
};


/** The output of our create `Currency` mutation. */
export type CreateCurrencyPayloadcurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
};

/** All input for the create `Currency` mutation. */
export type CreateCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Currency` to be created by this mutation. */
  currency: CurrencyInput;
};

/** An input for mutations affecting `Currency` */
export type CurrencyInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
};

/** The output of our create `CurrencyRate` mutation. */
export type CreateCurrencyRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencyRate` that was created by this mutation. */
  currencyRate?: Maybe<CurrencyRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencyRate`. May be used by Relay 1. */
  currencyRateEdge?: Maybe<CurrencyRatesEdge>;
};


/** The output of our create `CurrencyRate` mutation. */
export type CreateCurrencyRatePayloadcurrencyRateEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
};

/** All input for the create `CurrencyRate` mutation. */
export type CreateCurrencyRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CurrencyRate` to be created by this mutation. */
  currencyRate: CurrencyRateInput;
};

/** An input for mutations affecting `CurrencyRate` */
export type CurrencyRateInput = {
  importService: Scalars['String'];
  usd?: InputMaybe<Scalars['BigFloat']>;
  id: Scalars['BigInt'];
};

/** The output of our create `CurrencySymbol` mutation. */
export type CreateCurrencySymbolPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencySymbol` that was created by this mutation. */
  currencySymbol?: Maybe<CurrencySymbol>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencySymbol`. May be used by Relay 1. */
  currencySymbolEdge?: Maybe<CurrencySymbolsEdge>;
};


/** The output of our create `CurrencySymbol` mutation. */
export type CreateCurrencySymbolPayloadcurrencySymbolEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
};

/** All input for the create `CurrencySymbol` mutation. */
export type CreateCurrencySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CurrencySymbol` to be created by this mutation. */
  currencySymbol: CurrencySymbolInput;
};

/** An input for mutations affecting `CurrencySymbol` */
export type CurrencySymbolInput = {
  symbol: Scalars['String'];
  useStandard?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** The output of our create `CustomerGroup` mutation. */
export type CreateCustomerGroupPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerGroup` that was created by this mutation. */
  customerGroup?: Maybe<CustomerGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerGroup`. May be used by Relay 1. */
  customerGroupEdge?: Maybe<CustomerGroupsEdge>;
};


/** The output of our create `CustomerGroup` mutation. */
export type CreateCustomerGroupPayloadcustomerGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
};

/** All input for the create `CustomerGroup` mutation. */
export type CreateCustomerGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `CustomerGroup` to be created by this mutation. */
  customerGroup: CustomerGroupInput;
};

/** An input for mutations affecting `CustomerGroup` */
export type CustomerGroupInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  taxClass?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  customers?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  coverPhoto?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Customer` mutation. */
export type CreateCustomerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was created by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our create `Customer` mutation. */
export type CreateCustomerPayloadcustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the create `Customer` mutation. */
export type CreateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Customer` to be created by this mutation. */
  customer: CustomerInput;
};

/** An input for mutations affecting `Customer` */
export type CustomerInput = {
  id?: InputMaybe<Scalars['Int']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  namePrefix?: InputMaybe<Scalars['String']>;
  firstName: Scalars['String'];
  middleName?: InputMaybe<Scalars['String']>;
  lastName: Scalars['String'];
  email: Scalars['String'];
  customerGroup?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  nameSuffix?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  customerSince?: InputMaybe<Scalars['Datetime']>;
  confirmedEmail?: InputMaybe<Scalars['String']>;
  dateOfBirth?: InputMaybe<Scalars['String']>;
  taxVatNumber?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  shortDescription?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  paymentType?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  creditMemos?: InputMaybe<Scalars['String']>;
  customerPayment?: InputMaybe<Scalars['String']>;
  emails?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  messages?: InputMaybe<Scalars['String']>;
  newsletterSubscribers?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  returns?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Customization` mutation. */
export type CreateCustomizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customization` that was created by this mutation. */
  customization?: Maybe<Customization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customization`. May be used by Relay 1. */
  customizationEdge?: Maybe<CustomizationsEdge>;
};


/** The output of our create `Customization` mutation. */
export type CreateCustomizationPayloadcustomizationEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
};

/** All input for the create `Customization` mutation. */
export type CreateCustomizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Customization` to be created by this mutation. */
  customization: CustomizationInput;
};

/** An input for mutations affecting `Customization` */
export type CustomizationInput = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  siteName?: InputMaybe<Scalars['String']>;
  navLink?: InputMaybe<Scalars['String']>;
  notification?: InputMaybe<Scalars['String']>;
  banner?: InputMaybe<Scalars['String']>;
  footerLink?: InputMaybe<Scalars['String']>;
  announcement?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  siteUrl?: InputMaybe<Scalars['String']>;
  allowSignup?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Dashboard` mutation. */
export type CreateDashboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Dashboard` that was created by this mutation. */
  dashboard?: Maybe<Dashboard>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Dashboard`. May be used by Relay 1. */
  dashboardEdge?: Maybe<DashboardsEdge>;
};


/** The output of our create `Dashboard` mutation. */
export type CreateDashboardPayloaddashboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
};

/** All input for the create `Dashboard` mutation. */
export type CreateDashboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Dashboard` to be created by this mutation. */
  dashboard: DashboardInput;
};

/** An input for mutations affecting `Dashboard` */
export type DashboardInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  privacy?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  checklists?: InputMaybe<Scalars['String']>;
  visits?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  sales?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Deepdive` mutation. */
export type CreateDeepdivePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Deepdive` that was created by this mutation. */
  deepdive?: Maybe<Deepdive>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Deepdive`. May be used by Relay 1. */
  deepdiveEdge?: Maybe<DeepdivesEdge>;
};


/** The output of our create `Deepdive` mutation. */
export type CreateDeepdivePayloaddeepdiveEdgeArgs = {
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
};

/** All input for the create `Deepdive` mutation. */
export type CreateDeepdiveInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Deepdive` to be created by this mutation. */
  deepdive: DeepdiveInput;
};

/** An input for mutations affecting `Deepdive` */
export type DeepdiveInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  endDate?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  attendees?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Digiboard` mutation. */
export type CreateDigiboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Digiboard` that was created by this mutation. */
  digiboard?: Maybe<Digiboard>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Digiboard`. May be used by Relay 1. */
  digiboardEdge?: Maybe<DigiboardsEdge>;
};


/** The output of our create `Digiboard` mutation. */
export type CreateDigiboardPayloaddigiboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
};

/** All input for the create `Digiboard` mutation. */
export type CreateDigiboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Digiboard` to be created by this mutation. */
  digiboard: DigiboardInput;
};

/** An input for mutations affecting `Digiboard` */
export type DigiboardInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  board?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  student?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Email` mutation. */
export type CreateEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was created by this mutation. */
  email?: Maybe<Email>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our create `Email` mutation. */
export type CreateEmailPayloademailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the create `Email` mutation. */
export type CreateEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Email` to be created by this mutation. */
  email: EmailInput;
};

/** An input for mutations affecting `Email` */
export type EmailInput = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  bcc?: InputMaybe<Scalars['String']>;
  cc?: InputMaybe<Scalars['String']>;
  from?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Endofshift` mutation. */
export type CreateEndofshiftPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Endofshift` that was created by this mutation. */
  endofshift?: Maybe<Endofshift>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Endofshift`. May be used by Relay 1. */
  endofshiftEdge?: Maybe<EndofshiftsEdge>;
};


/** The output of our create `Endofshift` mutation. */
export type CreateEndofshiftPayloadendofshiftEdgeArgs = {
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
};

/** All input for the create `Endofshift` mutation. */
export type CreateEndofshiftInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Endofshift` to be created by this mutation. */
  endofshift: EndofshiftInput;
};

/** An input for mutations affecting `Endofshift` */
export type EndofshiftInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  content?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  mcms?: InputMaybe<Scalars['String']>;
  nextShift?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Event` mutation. */
export type CreateEventPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` that was created by this mutation. */
  event?: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
};


/** The output of our create `Event` mutation. */
export type CreateEventPayloadeventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the create `Event` mutation. */
export type CreateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Event` to be created by this mutation. */
  event: EventInput;
};

/** An input for mutations affecting `Event` */
export type EventInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  start?: InputMaybe<Scalars['String']>;
  end?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Fullfillment` mutation. */
export type CreateFullfillmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Fullfillment` that was created by this mutation. */
  fullfillment?: Maybe<Fullfillment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Fullfillment`. May be used by Relay 1. */
  fullfillmentEdge?: Maybe<FullfillmentsEdge>;
};


/** The output of our create `Fullfillment` mutation. */
export type CreateFullfillmentPayloadfullfillmentEdgeArgs = {
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
};

/** All input for the create `Fullfillment` mutation. */
export type CreateFullfillmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Fullfillment` to be created by this mutation. */
  fullfillment: FullfillmentInput;
};

/** An input for mutations affecting `Fullfillment` */
export type FullfillmentInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  shippingZones?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  countryArea?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  pickup?: InputMaybe<Scalars['String']>;
  stock?: InputMaybe<Scalars['String']>;
};

/** The output of our create `GiftCertificate` mutation. */
export type CreateGiftCertificatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GiftCertificate` that was created by this mutation. */
  giftCertificate?: Maybe<GiftCertificate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `GiftCertificate`. May be used by Relay 1. */
  giftCertificateEdge?: Maybe<GiftCertificatesEdge>;
};


/** The output of our create `GiftCertificate` mutation. */
export type CreateGiftCertificatePayloadgiftCertificateEdgeArgs = {
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
};

/** All input for the create `GiftCertificate` mutation. */
export type CreateGiftCertificateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `GiftCertificate` to be created by this mutation. */
  giftCertificate: GiftCertificateInput;
};

/** An input for mutations affecting `GiftCertificate` */
export type GiftCertificateInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  specialOffers?: InputMaybe<Scalars['String']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Glossary` mutation. */
export type CreateGlossaryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Glossary` that was created by this mutation. */
  glossary?: Maybe<Glossary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Glossary`. May be used by Relay 1. */
  glossaryEdge?: Maybe<GlossariesEdge>;
};


/** The output of our create `Glossary` mutation. */
export type CreateGlossaryPayloadglossaryEdgeArgs = {
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
};

/** All input for the create `Glossary` mutation. */
export type CreateGlossaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Glossary` to be created by this mutation. */
  glossary: GlossaryInput;
};

/** An input for mutations affecting `Glossary` */
export type GlossaryInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `Importm` mutation. */
export type CreateImportmPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Importm` that was created by this mutation. */
  importm?: Maybe<Importm>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Importm`. May be used by Relay 1. */
  importmEdge?: Maybe<ImportmsEdge>;
};


/** The output of our create `Importm` mutation. */
export type CreateImportmPayloadimportmEdgeArgs = {
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
};

/** All input for the create `Importm` mutation. */
export type CreateImportmInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Importm` to be created by this mutation. */
  importm: ImportmInput;
};

/** An input for mutations affecting `Importm` */
export type ImportmInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Integration` mutation. */
export type CreateIntegrationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Integration` that was created by this mutation. */
  integration?: Maybe<Integration>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Integration`. May be used by Relay 1. */
  integrationEdge?: Maybe<IntegrationsEdge>;
};


/** The output of our create `Integration` mutation. */
export type CreateIntegrationPayloadintegrationEdgeArgs = {
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
};

/** All input for the create `Integration` mutation. */
export type CreateIntegrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Integration` to be created by this mutation. */
  integration: IntegrationInput;
};

/** An input for mutations affecting `Integration` */
export type IntegrationInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Internalization` mutation. */
export type CreateInternalizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Internalization` that was created by this mutation. */
  internalization?: Maybe<Internalization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Internalization`. May be used by Relay 1. */
  internalizationEdge?: Maybe<InternalizationsEdge>;
};


/** The output of our create `Internalization` mutation. */
export type CreateInternalizationPayloadinternalizationEdgeArgs = {
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
};

/** All input for the create `Internalization` mutation. */
export type CreateInternalizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Internalization` to be created by this mutation. */
  internalization: InternalizationInput;
};

/** An input for mutations affecting `Internalization` */
export type InternalizationInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Invitation` mutation. */
export type CreateInvitationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invitation` that was created by this mutation. */
  invitation?: Maybe<Invitation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invitation`. May be used by Relay 1. */
  invitationEdge?: Maybe<InvitationsEdge>;
};


/** The output of our create `Invitation` mutation. */
export type CreateInvitationPayloadinvitationEdgeArgs = {
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
};

/** All input for the create `Invitation` mutation. */
export type CreateInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Invitation` to be created by this mutation. */
  invitation: InvitationInput;
};

/** An input for mutations affecting `Invitation` */
export type InvitationInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  email?: InputMaybe<Scalars['String']>;
  billingAddress?: InputMaybe<Scalars['String']>;
  shippingAddress?: InputMaybe<Scalars['String']>;
  orderNumber?: InputMaybe<Scalars['String']>;
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was created by this mutation. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our create `Invoice` mutation. */
export type CreateInvoicePayloadinvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the create `Invoice` mutation. */
export type CreateInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Invoice` to be created by this mutation. */
  invoice: InvoiceInput;
};

/** An input for mutations affecting `Invoice` */
export type InvoiceInput = {
  invoice: Scalars['Int'];
  orderNumber: Scalars['BigInt'];
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  billingAddress?: InputMaybe<Scalars['String']>;
  grandTotalBase?: InputMaybe<Scalars['String']>;
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  shippingAddress?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  customerGroup?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  shippingInformation?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  shippingAndHandling?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** The output of our create `Lead` mutation. */
export type CreateLeadPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lead` that was created by this mutation. */
  lead?: Maybe<Lead>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
};


/** The output of our create `Lead` mutation. */
export type CreateLeadPayloadleadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the create `Lead` mutation. */
export type CreateLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Lead` to be created by this mutation. */
  lead: LeadInput;
};

/** An input for mutations affecting `Lead` */
export type LeadInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  prefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  mobile?: InputMaybe<Scalars['String']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  statusDescription?: InputMaybe<Scalars['String']>;
  opportunityAmount?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
  leadSource?: InputMaybe<Scalars['String']>;
  leadSourceDescription?: InputMaybe<Scalars['String']>;
  referredBy?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Manufacturer` mutation. */
export type CreateManufacturerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Manufacturer` that was created by this mutation. */
  manufacturer?: Maybe<Manufacturer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Manufacturer`. May be used by Relay 1. */
  manufacturerEdge?: Maybe<ManufacturersEdge>;
};


/** The output of our create `Manufacturer` mutation. */
export type CreateManufacturerPayloadmanufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
};

/** All input for the create `Manufacturer` mutation. */
export type CreateManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Manufacturer` to be created by this mutation. */
  manufacturer: ManufacturerInput;
};

/** An input for mutations affecting `Manufacturer` */
export type ManufacturerInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Mediamanager` mutation. */
export type CreateMediamanagerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Mediamanager` that was created by this mutation. */
  mediamanager?: Maybe<Mediamanager>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Mediamanager`. May be used by Relay 1. */
  mediamanagerEdge?: Maybe<MediamanagersEdge>;
};


/** The output of our create `Mediamanager` mutation. */
export type CreateMediamanagerPayloadmediamanagerEdgeArgs = {
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
};

/** All input for the create `Mediamanager` mutation. */
export type CreateMediamanagerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Mediamanager` to be created by this mutation. */
  mediamanager: MediamanagerInput;
};

/** An input for mutations affecting `Mediamanager` */
export type MediamanagerInput = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  keywords?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  brands?: InputMaybe<Scalars['BigInt']>;
  status?: InputMaybe<Scalars['String']>;
  expirationDate?: InputMaybe<Scalars['String']>;
  copyright?: InputMaybe<Scalars['String']>;
  dimensions?: InputMaybe<Scalars['String']>;
  author?: InputMaybe<Scalars['Int']>;
  contentType?: InputMaybe<Scalars['String']>;
  versions?: InputMaybe<Scalars['String']>;
  watermarkName?: InputMaybe<Scalars['String']>;
  watermarkDescription?: InputMaybe<Scalars['String']>;
  watermarkMedia?: InputMaybe<Scalars['String']>;
  agreements?: InputMaybe<Scalars['Int']>;
  albums?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['Int']>;
  workspace?: InputMaybe<Scalars['String']>;
  taskName?: InputMaybe<Scalars['BigInt']>;
  taskDescription?: InputMaybe<Scalars['String']>;
  taskType?: InputMaybe<Scalars['String']>;
  members?: InputMaybe<Scalars['Int']>;
  products?: InputMaybe<Scalars['BigInt']>;
  agreementsAgreementsTomediamanager?: InputMaybe<Scalars['String']>;
  brandsBrandsTomediamanager?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  productsMediamanagerToproducts?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Meeting` mutation. */
export type CreateMeetingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Meeting` that was created by this mutation. */
  meeting?: Maybe<Meeting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Meeting`. May be used by Relay 1. */
  meetingEdge?: Maybe<MeetingsEdge>;
};


/** The output of our create `Meeting` mutation. */
export type CreateMeetingPayloadmeetingEdgeArgs = {
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
};

/** All input for the create `Meeting` mutation. */
export type CreateMeetingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Meeting` to be created by this mutation. */
  meeting: MeetingInput;
};

/** An input for mutations affecting `Meeting` */
export type MeetingInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  duration?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  relatedTo?: InputMaybe<Scalars['String']>;
  reminders?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  invitees?: InputMaybe<Scalars['String']>;
  scheduling?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Message` mutation. */
export type CreateMessagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was created by this mutation. */
  message?: Maybe<Message>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
};


/** The output of our create `Message` mutation. */
export type CreateMessagePayloadmessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the create `Message` mutation. */
export type CreateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Message` to be created by this mutation. */
  message: MessageInput;
};

/** An input for mutations affecting `Message` */
export type MessageInput = {
  id?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  media?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Newsletter` mutation. */
export type CreateNewsletterPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Newsletter` that was created by this mutation. */
  newsletter?: Maybe<Newsletter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Newsletter`. May be used by Relay 1. */
  newsletterEdge?: Maybe<NewslettersEdge>;
};


/** The output of our create `Newsletter` mutation. */
export type CreateNewsletterPayloadnewsletterEdgeArgs = {
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
};

/** All input for the create `Newsletter` mutation. */
export type CreateNewsletterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Newsletter` to be created by this mutation. */
  newsletter: NewsletterInput;
};

/** An input for mutations affecting `Newsletter` */
export type NewsletterInput = {
  id?: InputMaybe<Scalars['Int']>;
  email: Scalars['String'];
  customerFirstName?: InputMaybe<Scalars['String']>;
  customerLastName?: InputMaybe<Scalars['String']>;
  store?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  custId: Scalars['Int'];
  customers?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Ooto` mutation. */
export type CreateOotoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ooto` that was created by this mutation. */
  ooto?: Maybe<Ooto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ooto`. May be used by Relay 1. */
  ootoEdge?: Maybe<OotosEdge>;
};


/** The output of our create `Ooto` mutation. */
export type CreateOotoPayloadootoEdgeArgs = {
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
};

/** All input for the create `Ooto` mutation. */
export type CreateOotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Ooto` to be created by this mutation. */
  ooto: OotoInput;
};

/** An input for mutations affecting `Ooto` */
export type OotoInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  login?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  note?: InputMaybe<Scalars['String']>;
  usingTime?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Opportunity` mutation. */
export type CreateOpportunityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Opportunity` that was created by this mutation. */
  opportunity?: Maybe<Opportunity>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
};


/** The output of our create `Opportunity` mutation. */
export type CreateOpportunityPayloadopportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the create `Opportunity` mutation. */
export type CreateOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Opportunity` to be created by this mutation. */
  opportunity: OpportunityInput;
};

/** An input for mutations affecting `Opportunity` */
export type OpportunityInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  amount?: InputMaybe<Scalars['String']>;
  salesStage?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  probability?: InputMaybe<Scalars['String']>;
  nextStep?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  leadSource?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  expectedCloseDate?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Order` mutation. */
export type CreateOrderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Order` that was created by this mutation. */
  order?: Maybe<Order>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Order`. May be used by Relay 1. */
  orderEdge?: Maybe<OrdersEdge>;
};


/** The output of our create `Order` mutation. */
export type CreateOrderPayloadorderEdgeArgs = {
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
};

/** All input for the create `Order` mutation. */
export type CreateOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Order` to be created by this mutation. */
  order: OrderInput;
};

/** An input for mutations affecting `Order` */
export type OrderInput = {
  id?: InputMaybe<Scalars['Int']>;
  purchasePoint?: InputMaybe<Scalars['Int']>;
  purchaseDate?: InputMaybe<Scalars['Datetime']>;
  billToName: Scalars['String'];
  shipToName?: InputMaybe<Scalars['String']>;
  grandTotalBase?: InputMaybe<Scalars['Int']>;
  grandTotalPurchased?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<Scalars['Boolean']>;
  action?: InputMaybe<Scalars['Boolean']>;
  allocatedSources?: InputMaybe<Scalars['String']>;
  braintreeTransactionSource?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  transactions?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Page` mutation. */
export type CreatePagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` that was created by this mutation. */
  page?: Maybe<Page>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge?: Maybe<PagesEdge>;
};


/** The output of our create `Page` mutation. */
export type CreatePagePayloadpageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the create `Page` mutation. */
export type CreatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Page` to be created by this mutation. */
  page: PageInput;
};

/** An input for mutations affecting `Page` */
export type PageInput = {
  id?: InputMaybe<Scalars['Int']>;
  enablePage?: InputMaybe<Scalars['Boolean']>;
  title: Scalars['String'];
  contentTitle?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  urlKey?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Partner` mutation. */
export type CreatePartnerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Partner` that was created by this mutation. */
  partner?: Maybe<Partner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Partner`. May be used by Relay 1. */
  partnerEdge?: Maybe<PartnersEdge>;
};


/** The output of our create `Partner` mutation. */
export type CreatePartnerPayloadpartnerEdgeArgs = {
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
};

/** All input for the create `Partner` mutation. */
export type CreatePartnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Partner` to be created by this mutation. */
  partner: PartnerInput;
};

/** An input for mutations affecting `Partner` */
export type PartnerInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  businessType?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Payment` mutation. */
export type CreatePaymentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was created by this mutation. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our create `Payment` mutation. */
export type CreatePaymentPayloadpaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the create `Payment` mutation. */
export type CreatePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Payment` to be created by this mutation. */
  payment: PaymentInput;
};

/** An input for mutations affecting `Payment` */
export type PaymentInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  hostUri?: InputMaybe<Scalars['String']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  active?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Permission` mutation. */
export type CreatePermissionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Permission` that was created by this mutation. */
  permission?: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
};


/** The output of our create `Permission` mutation. */
export type CreatePermissionPayloadpermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the create `Permission` mutation. */
export type CreatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Permission` to be created by this mutation. */
  permission: PermissionInput;
};

/** An input for mutations affecting `Permission` */
export type PermissionInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  create?: InputMaybe<Scalars['String']>;
  delete?: InputMaybe<Scalars['String']>;
  read?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Plugin` mutation. */
export type CreatePluginPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Plugin` that was created by this mutation. */
  plugin?: Maybe<Plugin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Plugin`. May be used by Relay 1. */
  pluginEdge?: Maybe<PluginsEdge>;
};


/** The output of our create `Plugin` mutation. */
export type CreatePluginPayloadpluginEdgeArgs = {
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
};

/** All input for the create `Plugin` mutation. */
export type CreatePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Plugin` to be created by this mutation. */
  plugin: PluginInput;
};

/** An input for mutations affecting `Plugin` */
export type PluginInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  githubLink?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  logo?: InputMaybe<Scalars['String']>;
  screenshots?: InputMaybe<Scalars['String']>;
  lastUpdated?: InputMaybe<Scalars['Datetime']>;
  publisherName?: InputMaybe<Scalars['String']>;
  agreeTerms?: InputMaybe<Scalars['Boolean']>;
  publisherEmail?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Poll` mutation. */
export type CreatePollPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Poll` that was created by this mutation. */
  poll?: Maybe<Poll>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Poll`. May be used by Relay 1. */
  pollEdge?: Maybe<PollsEdge>;
};


/** The output of our create `Poll` mutation. */
export type CreatePollPayloadpollEdgeArgs = {
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
};

/** All input for the create `Poll` mutation. */
export type CreatePollInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Poll` to be created by this mutation. */
  poll: PollInput;
};

/** An input for mutations affecting `Poll` */
export type PollInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  question?: InputMaybe<Scalars['String']>;
  response?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `ProductType` mutation. */
export type CreateProductTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductType` that was created by this mutation. */
  productType?: Maybe<ProductType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductType`. May be used by Relay 1. */
  productTypeEdge?: Maybe<ProductTypesEdge>;
};


/** The output of our create `ProductType` mutation. */
export type CreateProductTypePayloadproductTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
};

/** All input for the create `ProductType` mutation. */
export type CreateProductTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `ProductType` to be created by this mutation. */
  productType: ProductTypeInput;
};

/** An input for mutations affecting `ProductType` */
export type ProductTypeInput = {
  id?: InputMaybe<Scalars['Int']>;
  typeName?: InputMaybe<Scalars['String']>;
  taxes?: InputMaybe<Scalars['String']>;
  isShippable?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  filterOptions?: InputMaybe<Scalars['String']>;
  productType?: InputMaybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Product` mutation. */
export type CreateProductPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Product` that was created by this mutation. */
  product?: Maybe<Product>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Product`. May be used by Relay 1. */
  productEdge?: Maybe<ProductsEdge>;
};


/** The output of our create `Product` mutation. */
export type CreateProductPayloadproductEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
};

/** All input for the create `Product` mutation. */
export type CreateProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Product` to be created by this mutation. */
  product: ProductInput;
};

/** An input for mutations affecting `Product` */
export type ProductInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  sku: Scalars['BigInt'];
  thumbnail?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  price?: InputMaybe<Scalars['String']>;
  quantityPerSource?: InputMaybe<Scalars['String']>;
  salableQuantity?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['Boolean']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  taxClass?: InputMaybe<Scalars['String']>;
  stockStatus?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  country?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['String']>;
  format?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  shortDescription?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
  manufacture?: InputMaybe<Scalars['String']>;
  attributes?: InputMaybe<Scalars['String']>;
  brand?: InputMaybe<Scalars['String']>;
  contract?: InputMaybe<Scalars['String']>;
  costString?: InputMaybe<Scalars['String']>;
  customerType?: InputMaybe<Scalars['String']>;
  family?: InputMaybe<Scalars['String']>;
  manufacturerPartNumber?: InputMaybe<Scalars['String']>;
  occassions?: InputMaybe<Scalars['String']>;
  partNumber?: InputMaybe<Scalars['String']>;
  relatedProduct?: InputMaybe<Scalars['BigInt']>;
  tags?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Scalars['String']>;
  variants?: InputMaybe<Scalars['String']>;
  zone?: InputMaybe<Scalars['String']>;
  brands?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  creditMemos?: InputMaybe<Scalars['String']>;
  manufacturer?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  occassionsOccassionsToproducts?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  otherProducts?: InputMaybe<Scalars['String']>;
  productAttribute?: InputMaybe<Scalars['String']>;
  productTypes?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  returns?: InputMaybe<Scalars['String']>;
  taxRate?: InputMaybe<Scalars['String']>;
  taxRule?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Project` mutation. */
export type CreateProjectPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Project` that was created by this mutation. */
  project?: Maybe<Project>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
};


/** The output of our create `Project` mutation. */
export type CreateProjectPayloadprojectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the create `Project` mutation. */
export type CreateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Project` to be created by this mutation. */
  project: ProjectInput;
};

/** An input for mutations affecting `Project` */
export type ProjectInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  projectManager?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  resource?: InputMaybe<Scalars['String']>;
  considerworkingdays?: InputMaybe<Scalars['String']>;
  projectTemplate?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  assignee?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  doing?: InputMaybe<Scalars['String']>;
  done?: InputMaybe<Scalars['String']>;
  goalCollaborators?: InputMaybe<Scalars['String']>;
  goalMeasurement?: InputMaybe<Scalars['String']>;
  goalName?: InputMaybe<Scalars['String']>;
  goalPrivacy?: InputMaybe<Scalars['String']>;
  goalProgressSource?: InputMaybe<Scalars['String']>;
  goalTimeperiod?: InputMaybe<Scalars['String']>;
  goalUpdatemethod?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  sectionRule?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  taskId?: InputMaybe<Scalars['BigInt']>;
  ticketId?: InputMaybe<Scalars['BigInt']>;
  customers?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  ticketing?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  method?: InputMaybe<Scalars['String']>;
  zone?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  team?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Provider` mutation. */
export type CreateProviderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Provider` that was created by this mutation. */
  provider?: Maybe<Provider>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Provider`. May be used by Relay 1. */
  providerEdge?: Maybe<ProvidersEdge>;
};


/** The output of our create `Provider` mutation. */
export type CreateProviderPayloadproviderEdgeArgs = {
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
};

/** All input for the create `Provider` mutation. */
export type CreateProviderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Provider` to be created by this mutation. */
  provider: ProviderInput;
};

/** An input for mutations affecting `Provider` */
export type ProviderInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  hostUri?: InputMaybe<Scalars['String']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  active?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Quote` mutation. */
export type CreateQuotePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was created by this mutation. */
  quote?: Maybe<Quote>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our create `Quote` mutation. */
export type CreateQuotePayloadquoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the create `Quote` mutation. */
export type CreateQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Quote` to be created by this mutation. */
  quote: QuoteInput;
};

/** An input for mutations affecting `Quote` */
export type QuoteInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  grandTotal?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  categories?: InputMaybe<Scalars['String']>;
  validUntil?: InputMaybe<Scalars['String']>;
  quoteStage?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  custId: Scalars['Int'];
  prodId: Scalars['BigInt'];
  orderId: Scalars['Int'];
  account?: InputMaybe<Scalars['String']>;
  approvalIssues?: InputMaybe<Scalars['String']>;
  approvalStatus?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  billingCity?: InputMaybe<Scalars['String']>;
  billingCountry?: InputMaybe<Scalars['String']>;
  billingPostal?: InputMaybe<Scalars['String']>;
  billingState?: InputMaybe<Scalars['String']>;
  billingStreet?: InputMaybe<Scalars['String']>;
  contact?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  invoiceStatus?: InputMaybe<Scalars['String']>;
  lineItemDiscount?: InputMaybe<Scalars['String']>;
  lineItemGroupTotal?: InputMaybe<Scalars['String']>;
  lineItemName?: InputMaybe<Scalars['String']>;
  lineItemSubtotal?: InputMaybe<Scalars['String']>;
  lineItemTax?: InputMaybe<Scalars['String']>;
  lineItemTotal?: InputMaybe<Scalars['String']>;
  paymentTerms?: InputMaybe<Scalars['String']>;
  shipping?: InputMaybe<Scalars['String']>;
  shippingCity?: InputMaybe<Scalars['String']>;
  shippingCountry?: InputMaybe<Scalars['String']>;
  shippingPostal?: InputMaybe<Scalars['String']>;
  shippingState?: InputMaybe<Scalars['String']>;
  shippingStreet?: InputMaybe<Scalars['String']>;
  shippingTax?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  tax?: InputMaybe<Scalars['String']>;
  total?: InputMaybe<Scalars['String']>;
  customersCustomersToquotes?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  productsProductsToquotes?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Rating` mutation. */
export type CreateRatingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Rating` that was created by this mutation. */
  rating?: Maybe<Rating>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Rating`. May be used by Relay 1. */
  ratingEdge?: Maybe<RatingsEdge>;
};


/** The output of our create `Rating` mutation. */
export type CreateRatingPayloadratingEdgeArgs = {
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
};

/** All input for the create `Rating` mutation. */
export type CreateRatingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Rating` to be created by this mutation. */
  rating: RatingInput;
};

/** An input for mutations affecting `Rating` */
export type RatingInput = {
  id?: InputMaybe<Scalars['Int']>;
  defaultValue?: InputMaybe<Scalars['String']>;
  defaultStoreView?: InputMaybe<Scalars['String']>;
  ratingVisibility?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  sortOrder?: InputMaybe<Scalars['BigFloat']>;
  prodId: Scalars['BigInt'];
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Report` mutation. */
export type CreateReportPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Report` that was created by this mutation. */
  report?: Maybe<Report>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
};


/** The output of our create `Report` mutation. */
export type CreateReportPayloadreportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the create `Report` mutation. */
export type CreateReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Report` to be created by this mutation. */
  report: ReportInput;
};

/** An input for mutations affecting `Report` */
export type ReportInput = {
  id?: InputMaybe<Scalars['Int']>;
  customer?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['BigFloat']>;
  subtotal?: InputMaybe<Scalars['String']>;
  appliedCoupon?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  ipAddress?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Return` mutation. */
export type CreateReturnPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Return` that was created by this mutation. */
  return?: Maybe<Return>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Return`. May be used by Relay 1. */
  returnEdge?: Maybe<ReturnsEdge>;
};


/** The output of our create `Return` mutation. */
export type CreateReturnPayloadreturnEdgeArgs = {
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
};

/** All input for the create `Return` mutation. */
export type CreateReturnInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Return` to be created by this mutation. */
  return: ReturnInput;
};

/** An input for mutations affecting `Return` */
export type ReturnInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  validity?: InputMaybe<Scalars['String']>;
  returnPrefix?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  shippingNumber?: InputMaybe<Scalars['String']>;
  shippingDescription?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  liquidationReason?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['String']>;
  howShipped?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  shipTo?: InputMaybe<Scalars['String']>;
  caseId?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Review` mutation. */
export type CreateReviewPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was created by this mutation. */
  review?: Maybe<Review>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our create `Review` mutation. */
export type CreateReviewPayloadreviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the create `Review` mutation. */
export type CreateReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Review` to be created by this mutation. */
  review: ReviewInput;
};

/** An input for mutations affecting `Review` */
export type ReviewInput = {
  id?: InputMaybe<Scalars['Int']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  shopId: Scalars['Int'];
  commentId: Scalars['Int'];
};

/** The output of our create `Reward` mutation. */
export type CreateRewardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reward` that was created by this mutation. */
  reward?: Maybe<Reward>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Reward`. May be used by Relay 1. */
  rewardEdge?: Maybe<RewardsEdge>;
};


/** The output of our create `Reward` mutation. */
export type CreateRewardPayloadrewardEdgeArgs = {
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
};

/** All input for the create `Reward` mutation. */
export type CreateRewardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Reward` to be created by this mutation. */
  reward: RewardInput;
};

/** An input for mutations affecting `Reward` */
export type RewardInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  slug?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Role` mutation. */
export type CreateRolePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Role` that was created by this mutation. */
  role?: Maybe<Role>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our create `Role` mutation. */
export type CreateRolePayloadroleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the create `Role` mutation. */
export type CreateRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Role` to be created by this mutation. */
  role: RoleInput;
};

/** An input for mutations affecting `Role` */
export type RoleInput = {
  id?: InputMaybe<Scalars['Int']>;
  roleName: Scalars['String'];
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `Scheduler` mutation. */
export type CreateSchedulerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Scheduler` that was created by this mutation. */
  scheduler?: Maybe<Scheduler>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
};


/** The output of our create `Scheduler` mutation. */
export type CreateSchedulerPayloadschedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the create `Scheduler` mutation. */
export type CreateSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Scheduler` to be created by this mutation. */
  scheduler: SchedulerInput;
};

/** An input for mutations affecting `Scheduler` */
export type SchedulerInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  endDate?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  notes?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Segment` mutation. */
export type CreateSegmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Segment` that was created by this mutation. */
  segment?: Maybe<Segment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Segment`. May be used by Relay 1. */
  segmentEdge?: Maybe<SegmentsEdge>;
};


/** The output of our create `Segment` mutation. */
export type CreateSegmentPayloadsegmentEdgeArgs = {
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
};

/** All input for the create `Segment` mutation. */
export type CreateSegmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Segment` to be created by this mutation. */
  segment: SegmentInput;
};

/** An input for mutations affecting `Segment` */
export type SegmentInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  applyTo?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Setting` mutation. */
export type CreateSettingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Setting` that was created by this mutation. */
  setting?: Maybe<Setting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our create `Setting` mutation. */
export type CreateSettingPayloadsettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the create `Setting` mutation. */
export type CreateSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Setting` to be created by this mutation. */
  setting: SettingInput;
};

/** An input for mutations affecting `Setting` */
export type SettingInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  storeName?: InputMaybe<Scalars['String']>;
  storePhone?: InputMaybe<Scalars['String']>;
  storeHours?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  vatNumber?: InputMaybe<Scalars['String']>;
  allowState?: InputMaybe<Scalars['String']>;
  stateRequiredFor?: InputMaybe<Scalars['String']>;
  allowCountries?: InputMaybe<Scalars['String']>;
  defaultCountry?: InputMaybe<Scalars['String']>;
  optionalZip?: InputMaybe<Scalars['String']>;
  europeanUnionCountries?: InputMaybe<Scalars['String']>;
  topDestinations?: InputMaybe<Scalars['String']>;
  baseCurrency?: InputMaybe<Scalars['String']>;
  defaultCurrency?: InputMaybe<Scalars['String']>;
  allowedCurrency?: InputMaybe<Scalars['String']>;
  siteName?: InputMaybe<Scalars['String']>;
  siteWebsite?: InputMaybe<Scalars['String']>;
  sentryDsn?: InputMaybe<Scalars['String']>;
  awsS3?: InputMaybe<Scalars['String']>;
  databaseUrl?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  googleAnalytics?: InputMaybe<Scalars['String']>;
  searchSetting?: InputMaybe<Scalars['String']>;
  mailServer?: InputMaybe<Scalars['String']>;
  youtubeVideos?: InputMaybe<Scalars['String']>;
  siteTagline?: InputMaybe<Scalars['String']>;
  googleDrive?: InputMaybe<Scalars['String']>;
  disqusKey?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Shipment` mutation. */
export type CreateShipmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipment` that was created by this mutation. */
  shipment?: Maybe<Shipment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Shipment`. May be used by Relay 1. */
  shipmentEdge?: Maybe<ShipmentsEdge>;
};


/** The output of our create `Shipment` mutation. */
export type CreateShipmentPayloadshipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
};

/** All input for the create `Shipment` mutation. */
export type CreateShipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Shipment` to be created by this mutation. */
  shipment: ShipmentInput;
};

/** An input for mutations affecting `Shipment` */
export type ShipmentInput = {
  product?: InputMaybe<Scalars['String']>;
  speedGrade?: InputMaybe<Scalars['String']>;
  shipDate?: InputMaybe<Scalars['Datetime']>;
  carrierName: Scalars['String'];
  transitTime?: InputMaybe<Scalars['String']>;
  trackingUrl?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
};

/** The output of our create `SpecialDiscount` mutation. */
export type CreateSpecialDiscountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpecialDiscount` that was created by this mutation. */
  specialDiscount?: Maybe<SpecialDiscount>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SpecialDiscount`. May be used by Relay 1. */
  specialDiscountEdge?: Maybe<SpecialDiscountsEdge>;
};


/** The output of our create `SpecialDiscount` mutation. */
export type CreateSpecialDiscountPayloadspecialDiscountEdgeArgs = {
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
};

/** All input for the create `SpecialDiscount` mutation. */
export type CreateSpecialDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `SpecialDiscount` to be created by this mutation. */
  specialDiscount: SpecialDiscountInput;
};

/** An input for mutations affecting `SpecialDiscount` */
export type SpecialDiscountInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['BigFloat']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['Date']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `State` mutation. */
export type CreateStatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `State` that was created by this mutation. */
  state?: Maybe<State>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `State`. May be used by Relay 1. */
  stateEdge?: Maybe<StatesEdge>;
};


/** The output of our create `State` mutation. */
export type CreateStatePayloadstateEdgeArgs = {
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
};

/** All input for the create `State` mutation. */
export type CreateStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `State` to be created by this mutation. */
  state: StateInput;
};

/** An input for mutations affecting `State` */
export type StateInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Statistic` mutation. */
export type CreateStatisticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Statistic` that was created by this mutation. */
  statistic?: Maybe<Statistic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Statistic`. May be used by Relay 1. */
  statisticEdge?: Maybe<StatisticsEdge>;
};


/** The output of our create `Statistic` mutation. */
export type CreateStatisticPayloadstatisticEdgeArgs = {
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
};

/** All input for the create `Statistic` mutation. */
export type CreateStatisticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Statistic` to be created by this mutation. */
  statistic: StatisticInput;
};

/** An input for mutations affecting `Statistic` */
export type StatisticInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  specialOffers?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['Date']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Stock` mutation. */
export type CreateStockPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Stock` that was created by this mutation. */
  stock?: Maybe<Stock>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Stock`. May be used by Relay 1. */
  stockEdge?: Maybe<StocksEdge>;
};


/** The output of our create `Stock` mutation. */
export type CreateStockPayloadstockEdgeArgs = {
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
};

/** All input for the create `Stock` mutation. */
export type CreateStockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Stock` to be created by this mutation. */
  stock: StockInput;
};

/** An input for mutations affecting `Stock` */
export type StockInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  enabled?: InputMaybe<Scalars['Boolean']>;
  description?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  sources?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Survey` mutation. */
export type CreateSurveyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Survey` that was created by this mutation. */
  survey?: Maybe<Survey>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Survey`. May be used by Relay 1. */
  surveyEdge?: Maybe<SurveysEdge>;
};


/** The output of our create `Survey` mutation. */
export type CreateSurveyPayloadsurveyEdgeArgs = {
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
};

/** All input for the create `Survey` mutation. */
export type CreateSurveyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Survey` to be created by this mutation. */
  survey: SurveyInput;
};

/** An input for mutations affecting `Survey` */
export type SurveyInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  question?: InputMaybe<Scalars['String']>;
  answer?: InputMaybe<Scalars['String']>;
  submitText?: InputMaybe<Scalars['String']>;
  satisfiedText?: InputMaybe<Scalars['String']>;
  neitherText?: InputMaybe<Scalars['String']>;
  dissatisfiedText?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Tag` mutation. */
export type CreateTagPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Tag` that was created by this mutation. */
  tag?: Maybe<Tag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our create `Tag` mutation. */
export type CreateTagPayloadtagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the create `Tag` mutation. */
export type CreateTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Tag` to be created by this mutation. */
  tag: TagInput;
};

/** An input for mutations affecting `Tag` */
export type TagInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  excerpt?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Target` mutation. */
export type CreateTargetPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Target` that was created by this mutation. */
  target?: Maybe<Target>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Target`. May be used by Relay 1. */
  targetEdge?: Maybe<TargetsEdge>;
};


/** The output of our create `Target` mutation. */
export type CreateTargetPayloadtargetEdgeArgs = {
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
};

/** All input for the create `Target` mutation. */
export type CreateTargetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Target` to be created by this mutation. */
  target: TargetInput;
};

/** An input for mutations affecting `Target` */
export type TargetInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  prefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  mobile?: InputMaybe<Scalars['String']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
  emailOptOut?: InputMaybe<Scalars['String']>;
  donotcall?: InputMaybe<Scalars['String']>;
};

/** The output of our create `TaxCategory` mutation. */
export type CreateTaxCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxCategory` that was created by this mutation. */
  taxCategory?: Maybe<TaxCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxCategory`. May be used by Relay 1. */
  taxCategoryEdge?: Maybe<TaxCategoriesEdge>;
};


/** The output of our create `TaxCategory` mutation. */
export type CreateTaxCategoryPayloadtaxCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
};

/** All input for the create `TaxCategory` mutation. */
export type CreateTaxCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TaxCategory` to be created by this mutation. */
  taxCategory: TaxCategoryInput;
};

/** An input for mutations affecting `TaxCategory` */
export type TaxCategoryInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
};

/** The output of our create `TaxRate` mutation. */
export type CreateTaxRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRate` that was created by this mutation. */
  taxRate?: Maybe<TaxRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRate`. May be used by Relay 1. */
  taxRateEdge?: Maybe<TaxRatesEdge>;
};


/** The output of our create `TaxRate` mutation. */
export type CreateTaxRatePayloadtaxRateEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
};

/** All input for the create `TaxRate` mutation. */
export type CreateTaxRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TaxRate` to be created by this mutation. */
  taxRate: TaxRateInput;
};

/** An input for mutations affecting `TaxRate` */
export type TaxRateInput = {
  id?: InputMaybe<Scalars['Int']>;
  taxIdentifier: Scalars['String'];
  zipPostIsRange?: InputMaybe<Scalars['Boolean']>;
  postcode?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  ratePercent?: InputMaybe<Scalars['String']>;
  defaultStoreView?: InputMaybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `TaxRule` mutation. */
export type CreateTaxRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRule` that was created by this mutation. */
  taxRule?: Maybe<TaxRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRule`. May be used by Relay 1. */
  taxRuleEdge?: Maybe<TaxRulesEdge>;
};


/** The output of our create `TaxRule` mutation. */
export type CreateTaxRulePayloadtaxRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
};

/** All input for the create `TaxRule` mutation. */
export type CreateTaxRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `TaxRule` to be created by this mutation. */
  taxRule: TaxRuleInput;
};

/** An input for mutations affecting `TaxRule` */
export type TaxRuleInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  taxRate?: InputMaybe<Scalars['String']>;
  prodId: Scalars['BigInt'];
  products?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Template` mutation. */
export type CreateTemplatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was created by this mutation. */
  template?: Maybe<Template>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our create `Template` mutation. */
export type CreateTemplatePayloadtemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the create `Template` mutation. */
export type CreateTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Template` to be created by this mutation. */
  template: TemplateInput;
};

/** An input for mutations affecting `Template` */
export type TemplateInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['String']>;
  pageSize?: InputMaybe<Scalars['String']>;
  orientation?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  header?: InputMaybe<Scalars['String']>;
  footer?: InputMaybe<Scalars['String']>;
  marginLeft?: InputMaybe<Scalars['String']>;
  marginRight?: InputMaybe<Scalars['String']>;
  marginTop?: InputMaybe<Scalars['String']>;
  marginBottom?: InputMaybe<Scalars['String']>;
  marginHeader?: InputMaybe<Scalars['String']>;
  marginFooter?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Theme` mutation. */
export type CreateThemePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Theme` that was created by this mutation. */
  theme?: Maybe<Theme>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Theme`. May be used by Relay 1. */
  themeEdge?: Maybe<ThemesEdge>;
};


/** The output of our create `Theme` mutation. */
export type CreateThemePayloadthemeEdgeArgs = {
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
};

/** All input for the create `Theme` mutation. */
export type CreateThemeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Theme` to be created by this mutation. */
  theme: ThemeInput;
};

/** An input for mutations affecting `Theme` */
export type ThemeInput = {
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  parentTheme?: InputMaybe<Scalars['String']>;
  themePath?: InputMaybe<Scalars['String']>;
  action?: InputMaybe<Scalars['String']>;
  websiteId: Scalars['BigInt'];
  websites: Scalars['String'];
};

/** The output of our create `Ticketing` mutation. */
export type CreateTicketingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ticketing` that was created by this mutation. */
  ticketing?: Maybe<Ticketing>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ticketing`. May be used by Relay 1. */
  ticketingEdge?: Maybe<TicketingsEdge>;
};


/** The output of our create `Ticketing` mutation. */
export type CreateTicketingPayloadticketingEdgeArgs = {
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
};

/** All input for the create `Ticketing` mutation. */
export type CreateTicketingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Ticketing` to be created by this mutation. */
  ticketing: TicketingInput;
};

/** An input for mutations affecting `Ticketing` */
export type TicketingInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['String']>;
  severity?: InputMaybe<Scalars['String']>;
  team?: InputMaybe<Scalars['String']>;
  requester?: InputMaybe<Scalars['String']>;
  requesterEmail?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  ticketType?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  resolution?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  dateModified?: InputMaybe<Scalars['Datetime']>;
  accountName?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  projectsProjectsToticketing?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Training` mutation. */
export type CreateTrainingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Training` that was created by this mutation. */
  training?: Maybe<Training>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Training`. May be used by Relay 1. */
  trainingEdge?: Maybe<TrainingsEdge>;
};


/** The output of our create `Training` mutation. */
export type CreateTrainingPayloadtrainingEdgeArgs = {
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
};

/** All input for the create `Training` mutation. */
export type CreateTrainingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Training` to be created by this mutation. */
  training: TrainingInput;
};

/** An input for mutations affecting `Training` */
export type TrainingInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  link?: InputMaybe<Scalars['String']>;
  steps?: InputMaybe<Scalars['String']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  analytics?: InputMaybe<Scalars['String']>;
  competency?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Scalars['String']>;
  grade?: InputMaybe<Scalars['String']>;
  school?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['Int']>;
  address?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['Int']>;
  postal?: InputMaybe<Scalars['String']>;
  teacher?: InputMaybe<Scalars['String']>;
  student?: InputMaybe<Scalars['String']>;
  announcement?: InputMaybe<Scalars['String']>;
  resource?: InputMaybe<Scalars['String']>;
  badges?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  isCompleted?: InputMaybe<Scalars['String']>;
  speakers?: InputMaybe<Scalars['String']>;
  fieldTrips?: InputMaybe<Scalars['String']>;
  assignments?: InputMaybe<Scalars['String']>;
  assignmentsDueDate?: InputMaybe<Scalars['String']>;
  origanalityReport?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['BigInt']>;
  faqs?: InputMaybe<Scalars['String']>;
  languages?: InputMaybe<Scalars['String']>;
  checklists?: InputMaybe<Scalars['BigInt']>;
  city?: InputMaybe<Scalars['String']>;
  meetups?: InputMaybe<Scalars['String']>;
  lab?: InputMaybe<Scalars['String']>;
  digiboards?: InputMaybe<Scalars['String']>;
  countries?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Transaction` mutation. */
export type CreateTransactionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was created by this mutation. */
  transaction?: Maybe<Transaction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our create `Transaction` mutation. */
export type CreateTransactionPayloadtransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the create `Transaction` mutation. */
export type CreateTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Transaction` to be created by this mutation. */
  transaction: TransactionInput;
};

/** An input for mutations affecting `Transaction` */
export type TransactionInput = {
  id?: InputMaybe<Scalars['Int']>;
  orderId: Scalars['Int'];
  transactionId: Scalars['Int'];
  parentTransactionId: Scalars['Int'];
  created?: InputMaybe<Scalars['Datetime']>;
  paymentMethod: Scalars['BigInt'];
  closed?: InputMaybe<Scalars['String']>;
  customerPayment?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
};

/** The output of our create `UploadFile` mutation. */
export type CreateUploadFilePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UploadFile` that was created by this mutation. */
  uploadFile?: Maybe<UploadFile>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `UploadFile`. May be used by Relay 1. */
  uploadFileEdge?: Maybe<UploadFilesEdge>;
};


/** The output of our create `UploadFile` mutation. */
export type CreateUploadFilePayloaduploadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
};

/** All input for the create `UploadFile` mutation. */
export type CreateUploadFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `UploadFile` to be created by this mutation. */
  uploadFile: UploadFileInput;
};

/** An input for mutations affecting `UploadFile` */
export type UploadFileInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  alternativeText?: InputMaybe<Scalars['String']>;
  caption?: InputMaybe<Scalars['String']>;
  width?: InputMaybe<Scalars['Int']>;
  height?: InputMaybe<Scalars['Int']>;
  formats?: InputMaybe<Scalars['JSON']>;
  hash: Scalars['String'];
  ext?: InputMaybe<Scalars['String']>;
  mime: Scalars['String'];
  size: Scalars['BigFloat'];
  url: Scalars['String'];
  previewUrl?: InputMaybe<Scalars['String']>;
  provider: Scalars['String'];
  providerMetadata?: InputMaybe<Scalars['JSON']>;
  createdBy?: InputMaybe<Scalars['Int']>;
  updatedBy?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloaduserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  username: Scalars['String'];
  firstName: Scalars['String'];
  lastName?: InputMaybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
  interfaceLocale?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
  permissions?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  emails?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  messages?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Vendor` mutation. */
export type CreateVendorPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was created by this mutation. */
  vendor?: Maybe<Vendor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our create `Vendor` mutation. */
export type CreateVendorPayloadvendorEdgeArgs = {
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
};

/** All input for the create `Vendor` mutation. */
export type CreateVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Vendor` to be created by this mutation. */
  vendor: VendorInput;
};

/** An input for mutations affecting `Vendor` */
export type VendorInput = {
  id?: InputMaybe<Scalars['Int']>;
  name: Scalars['String'];
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  polls?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  reviews?: InputMaybe<Scalars['String']>;
  giftCertificates?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  invoices?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  rewardPoints?: InputMaybe<Scalars['String']>;
  specialDiscounts?: InputMaybe<Scalars['String']>;
  statistics?: InputMaybe<Scalars['String']>;
  stocks?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  physicalStore?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Visit` mutation. */
export type CreateVisitPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Visit` that was created by this mutation. */
  visit?: Maybe<Visit>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Visit`. May be used by Relay 1. */
  visitEdge?: Maybe<VisitsEdge>;
};


/** The output of our create `Visit` mutation. */
export type CreateVisitPayloadvisitEdgeArgs = {
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
};

/** All input for the create `Visit` mutation. */
export type CreateVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Visit` to be created by this mutation. */
  visit: VisitInput;
};

/** An input for mutations affecting `Visit` */
export type VisitInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  location?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  reason?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  emergency?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  meeting?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Warehouse` mutation. */
export type CreateWarehousePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was created by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our create `Warehouse` mutation. */
export type CreateWarehousePayloadwarehouseEdgeArgs = {
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
};

/** All input for the create `Warehouse` mutation. */
export type CreateWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Warehouse` to be created by this mutation. */
  warehouse: WarehouseInput;
};

/** An input for mutations affecting `Warehouse` */
export type WarehouseInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postal?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Webhook` mutation. */
export type CreateWebhookPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Webhook` that was created by this mutation. */
  webhook?: Maybe<Webhook>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Webhook`. May be used by Relay 1. */
  webhookEdge?: Maybe<WebhooksEdge>;
};


/** The output of our create `Webhook` mutation. */
export type CreateWebhookPayloadwebhookEdgeArgs = {
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
};

/** All input for the create `Webhook` mutation. */
export type CreateWebhookInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Webhook` to be created by this mutation. */
  webhook: WebhookInput;
};

/** An input for mutations affecting `Webhook` */
export type WebhookInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name: Scalars['String'];
  url: Scalars['String'];
  headers?: InputMaybe<Scalars['String']>;
  create?: InputMaybe<Scalars['String']>;
  retrieve?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['String']>;
  delete?: InputMaybe<Scalars['String']>;
  publish?: InputMaybe<Scalars['String']>;
  unpublish?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Website` mutation. */
export type CreateWebsitePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Website` that was created by this mutation. */
  website?: Maybe<Website>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Website`. May be used by Relay 1. */
  websiteEdge?: Maybe<WebsitesEdge>;
};


/** The output of our create `Website` mutation. */
export type CreateWebsitePayloadwebsiteEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
};

/** All input for the create `Website` mutation. */
export type CreateWebsiteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Website` to be created by this mutation. */
  website: WebsiteInput;
};

/** An input for mutations affecting `Website` */
export type WebsiteInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  shop?: InputMaybe<Scalars['String']>;
  store?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  themes: Scalars['String'];
};

/** The output of our create `Wishlist` mutation. */
export type CreateWishlistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Wishlist` that was created by this mutation. */
  wishlist?: Maybe<Wishlist>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Wishlist`. May be used by Relay 1. */
  wishlistEdge?: Maybe<WishlistsEdge>;
};


/** The output of our create `Wishlist` mutation. */
export type CreateWishlistPayloadwishlistEdgeArgs = {
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
};

/** All input for the create `Wishlist` mutation. */
export type CreateWishlistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Wishlist` to be created by this mutation. */
  wishlist: WishlistInput;
};

/** An input for mutations affecting `Wishlist` */
export type WishlistInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['String']>;
  occassions?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Workspace` mutation. */
export type CreateWorkspacePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Workspace` that was created by this mutation. */
  workspace?: Maybe<Workspace>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Workspace`. May be used by Relay 1. */
  workspaceEdge?: Maybe<WorkspacesEdge>;
};


/** The output of our create `Workspace` mutation. */
export type CreateWorkspacePayloadworkspaceEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
};

/** All input for the create `Workspace` mutation. */
export type CreateWorkspaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Workspace` to be created by this mutation. */
  workspace: WorkspaceInput;
};

/** An input for mutations affecting `Workspace` */
export type WorkspaceInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['Int']>;
  users?: InputMaybe<Scalars['Int']>;
  products?: InputMaybe<Scalars['BigInt']>;
  tasks?: InputMaybe<Scalars['BigInt']>;
  brands?: InputMaybe<Scalars['BigInt']>;
  shops?: InputMaybe<Scalars['Int']>;
  category?: InputMaybe<Scalars['Int']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  projects?: InputMaybe<Scalars['BigInt']>;
  author?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  brandsBrandsToworkspaces?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  customersCustomersToworkspaces?: InputMaybe<Scalars['String']>;
  productsProductsToworkspaces?: InputMaybe<Scalars['String']>;
  projectsProjectsToworkspaces?: InputMaybe<Scalars['String']>;
  shopsShopsToworkspaces?: InputMaybe<Scalars['String']>;
  tasksTasksToworkspaces?: InputMaybe<Scalars['String']>;
  usersUsersToworkspaces?: InputMaybe<Scalars['String']>;
};

/** The output of our create `Zone` mutation. */
export type CreateZonePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Zone` that was created by this mutation. */
  zone?: Maybe<Zone>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Zone`. May be used by Relay 1. */
  zoneEdge?: Maybe<ZonesEdge>;
};


/** The output of our create `Zone` mutation. */
export type CreateZonePayloadzoneEdgeArgs = {
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
};

/** All input for the create `Zone` mutation. */
export type CreateZoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The `Zone` to be created by this mutation. */
  zone: ZoneInput;
};

/** An input for mutations affecting `Zone` */
export type ZoneInput = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  scope?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  code?: InputMaybe<Scalars['String']>;
};

/** The output of our update `Account` mutation. */
export type UpdateAccountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was updated by this mutation. */
  account?: Maybe<Account>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our update `Account` mutation. */
export type UpdateAccountPayloadaccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the `updateAccount` mutation. */
export type UpdateAccountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Account` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Account` being updated. */
  accountPatch: AccountPatch;
};

/** Represents an update to a `Account`. Fields that are set will be updated. */
export type AccountPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  industry?: InputMaybe<Scalars['String']>;
  employees?: InputMaybe<Scalars['String']>;
  annualRevenue?: InputMaybe<Scalars['String']>;
  memberOf?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateAccountById` mutation. */
export type UpdateAccountByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Account` being updated. */
  accountPatch: AccountPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Agreement` mutation. */
export type UpdateAgreementPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agreement` that was updated by this mutation. */
  agreement?: Maybe<Agreement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Agreement`. May be used by Relay 1. */
  agreementEdge?: Maybe<AgreementsEdge>;
};


/** The output of our update `Agreement` mutation. */
export type UpdateAgreementPayloadagreementEdgeArgs = {
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
};

/** All input for the `updateAgreement` mutation. */
export type UpdateAgreementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Agreement` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Agreement` being updated. */
  agreementPatch: AgreementPatch;
};

/** Represents an update to a `Agreement`. Fields that are set will be updated. */
export type AgreementPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  referenceId?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  content?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  userId?: InputMaybe<Scalars['String']>;
  shopId?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateAgreementById` mutation. */
export type UpdateAgreementByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Agreement` being updated. */
  agreementPatch: AgreementPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Analytic` mutation. */
export type UpdateAnalyticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Analytic` that was updated by this mutation. */
  analytic?: Maybe<Analytic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Analytic`. May be used by Relay 1. */
  analyticEdge?: Maybe<AnalyticsEdge>;
};


/** The output of our update `Analytic` mutation. */
export type UpdateAnalyticPayloadanalyticEdgeArgs = {
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
};

/** All input for the `updateAnalytic` mutation. */
export type UpdateAnalyticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Analytic` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Analytic` being updated. */
  analyticPatch: AnalyticPatch;
};

/** Represents an update to a `Analytic`. Fields that are set will be updated. */
export type AnalyticPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  shareData?: InputMaybe<Scalars['String']>;
  websiteName?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  trackingId?: InputMaybe<Scalars['String']>;
  propertyName?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  defaultView?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  propertyHit?: InputMaybe<Scalars['String']>;
  trackingCode?: InputMaybe<Scalars['String']>;
  dataCollection?: InputMaybe<Scalars['Boolean']>;
  dataRetention?: InputMaybe<Scalars['Boolean']>;
  searchAnalytics?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateAnalyticById` mutation. */
export type UpdateAnalyticByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Analytic` being updated. */
  analyticPatch: AnalyticPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Apitoken` mutation. */
export type UpdateApitokenPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Apitoken` that was updated by this mutation. */
  apitoken?: Maybe<Apitoken>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Apitoken`. May be used by Relay 1. */
  apitokenEdge?: Maybe<ApitokensEdge>;
};


/** The output of our update `Apitoken` mutation. */
export type UpdateApitokenPayloadapitokenEdgeArgs = {
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
};

/** All input for the `updateApitoken` mutation. */
export type UpdateApitokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Apitoken` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Apitoken` being updated. */
  apitokenPatch: ApitokenPatch;
};

/** Represents an update to a `Apitoken`. Fields that are set will be updated. */
export type ApitokenPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  tokenType?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the `updateApitokenById` mutation. */
export type UpdateApitokenByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Apitoken` being updated. */
  apitokenPatch: ApitokenPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Article` mutation. */
export type UpdateArticlePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Article` that was updated by this mutation. */
  article?: Maybe<Article>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Article`. May be used by Relay 1. */
  articleEdge?: Maybe<ArticlesEdge>;
};


/** The output of our update `Article` mutation. */
export type UpdateArticlePayloadarticleEdgeArgs = {
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
};

/** All input for the `updateArticle` mutation. */
export type UpdateArticleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Article` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Article` being updated. */
  articlePatch: ArticlePatch;
};

/** Represents an update to a `Article`. Fields that are set will be updated. */
export type ArticlePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaName?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateArticleById` mutation. */
export type UpdateArticleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Article` being updated. */
  articlePatch: ArticlePatch;
  id: Scalars['Int'];
};

/** The output of our update `Attribute` mutation. */
export type UpdateAttributePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Attribute` that was updated by this mutation. */
  attribute?: Maybe<Attribute>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Attribute`. May be used by Relay 1. */
  attributeEdge?: Maybe<AttributesEdge>;
};


/** The output of our update `Attribute` mutation. */
export type UpdateAttributePayloadattributeEdgeArgs = {
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
};

/** All input for the `updateAttribute` mutation. */
export type UpdateAttributeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Attribute` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Attribute` being updated. */
  attributePatch: AttributePatch;
};

/** Represents an update to a `Attribute`. Fields that are set will be updated. */
export type AttributePatch = {
  id?: InputMaybe<Scalars['Int']>;
  defaultLabel?: InputMaybe<Scalars['String']>;
  attributeCode?: InputMaybe<Scalars['String']>;
  filterOptions?: InputMaybe<Scalars['String']>;
  useSearch?: InputMaybe<Scalars['String']>;
  layeredNavigation?: InputMaybe<Scalars['Boolean']>;
  searchResultsLayeredNavigation?: InputMaybe<Scalars['Boolean']>;
  position?: InputMaybe<Scalars['String']>;
  promoRuleConditions?: InputMaybe<Scalars['Boolean']>;
  allowHtmlTagsStorefront?: InputMaybe<Scalars['Boolean']>;
  visibleCatalogPagesStorefront?: InputMaybe<Scalars['Boolean']>;
  usedProductListing?: InputMaybe<Scalars['Boolean']>;
  usedSortingProductListing?: InputMaybe<Scalars['Boolean']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  attributeClass?: InputMaybe<Scalars['String']>;
  attributeValue?: InputMaybe<Scalars['String']>;
  columnOptions?: InputMaybe<Scalars['String']>;
  facetedNavigation?: InputMaybe<Scalars['Boolean']>;
  isPublic?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaName?: InputMaybe<Scalars['Boolean']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  productAttributeSet?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateAttributeById` mutation. */
export type UpdateAttributeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Attribute` being updated. */
  attributePatch: AttributePatch;
  id: Scalars['Int'];
};

/** The output of our update `Brand` mutation. */
export type UpdateBrandPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Brand` that was updated by this mutation. */
  brand?: Maybe<Brand>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<BrandsEdge>;
};


/** The output of our update `Brand` mutation. */
export type UpdateBrandPayloadbrandEdgeArgs = {
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
};

/** All input for the `updateBrand` mutation. */
export type UpdateBrandInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Brand` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Brand` being updated. */
  brandPatch: BrandPatch;
};

/** Represents an update to a `Brand`. Fields that are set will be updated. */
export type BrandPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateBrandById` mutation. */
export type UpdateBrandByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Brand` being updated. */
  brandPatch: BrandPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CartPriceRule` mutation. */
export type UpdateCartPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CartPriceRule` that was updated by this mutation. */
  cartPriceRule?: Maybe<CartPriceRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CartPriceRule`. May be used by Relay 1. */
  cartPriceRuleEdge?: Maybe<CartPriceRulesEdge>;
};


/** The output of our update `CartPriceRule` mutation. */
export type UpdateCartPriceRulePayloadcartPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
};

/** All input for the `updateCartPriceRule` mutation. */
export type UpdateCartPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CartPriceRule` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CartPriceRule` being updated. */
  cartPriceRulePatch: CartPriceRulePatch;
};

/** Represents an update to a `CartPriceRule`. Fields that are set will be updated. */
export type CartPriceRulePatch = {
  id?: InputMaybe<Scalars['Int']>;
  rule?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  coupon?: InputMaybe<Scalars['String']>;
  usesPerCustomer?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  actionsApply?: InputMaybe<Scalars['String']>;
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
  actionsMaxQtyDiscountIsAppliedTo?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscountQtyStep?: InputMaybe<Scalars['BigFloat']>;
  actionsApplyShippingAmount?: InputMaybe<Scalars['Boolean']>;
};

/** All input for the `updateCartPriceRuleById` mutation. */
export type UpdateCartPriceRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CartPriceRule` being updated. */
  cartPriceRulePatch: CartPriceRulePatch;
  id: Scalars['Int'];
};

/** The output of our update `Case` mutation. */
export type UpdateCasePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Case` that was updated by this mutation. */
  case?: Maybe<Case>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Case`. May be used by Relay 1. */
  caseEdge?: Maybe<CasesEdge>;
};


/** The output of our update `Case` mutation. */
export type UpdateCasePayloadcaseEdgeArgs = {
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
};

/** All input for the `updateCase` mutation. */
export type UpdateCaseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Case` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Case` being updated. */
  casePatch: CasePatch;
};

/** Represents an update to a `Case`. Fields that are set will be updated. */
export type CasePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  caseNumber?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  resolution?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  dateModified?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateCaseById` mutation. */
export type UpdateCaseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Case` being updated. */
  casePatch: CasePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CatalogPriceRule` mutation. */
export type UpdateCatalogPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CatalogPriceRule` that was updated by this mutation. */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CatalogPriceRule`. May be used by Relay 1. */
  catalogPriceRuleEdge?: Maybe<CatalogPriceRulesEdge>;
};


/** The output of our update `CatalogPriceRule` mutation. */
export type UpdateCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
};

/** All input for the `updateCatalogPriceRule` mutation. */
export type UpdateCatalogPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CatalogPriceRule` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CatalogPriceRule` being updated. */
  catalogPriceRulePatch: CatalogPriceRulePatch;
};

/** Represents an update to a `CatalogPriceRule`. Fields that are set will be updated. */
export type CatalogPriceRulePatch = {
  id?: InputMaybe<Scalars['Int']>;
  rule?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  customerGroups?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['Date']>;
  endDate?: InputMaybe<Scalars['Date']>;
  status?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  actionsApply?: InputMaybe<Scalars['String']>;
  actionsDiscountAmount?: InputMaybe<Scalars['BigFloat']>;
  actionsDiscardSubsequentRules?: InputMaybe<Scalars['Boolean']>;
};

/** All input for the `updateCatalogPriceRuleById` mutation. */
export type UpdateCatalogPriceRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CatalogPriceRule` being updated. */
  catalogPriceRulePatch: CatalogPriceRulePatch;
  id: Scalars['Int'];
};

/** The output of our update `Category` mutation. */
export type UpdateCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Category` that was updated by this mutation. */
  category?: Maybe<Category>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<CategoriesEdge>;
};


/** The output of our update `Category` mutation. */
export type UpdateCategoryPayloadcategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
};

/** All input for the `updateCategory` mutation. */
export type UpdateCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Category` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Category` being updated. */
  categoryPatch: CategoryPatch;
};

/** Represents an update to a `Category`. Fields that are set will be updated. */
export type CategoryPatch = {
  id?: InputMaybe<Scalars['Int']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['Boolean']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCategoryById` mutation. */
export type UpdateCategoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Category` being updated. */
  categoryPatch: CategoryPatch;
  id: Scalars['Int'];
};

/** The output of our update `Channel` mutation. */
export type UpdateChannelPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Channel` that was updated by this mutation. */
  channel?: Maybe<Channel>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Channel`. May be used by Relay 1. */
  channelEdge?: Maybe<ChannelsEdge>;
};


/** The output of our update `Channel` mutation. */
export type UpdateChannelPayloadchannelEdgeArgs = {
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
};

/** All input for the `updateChannel` mutation. */
export type UpdateChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Channel` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Channel` being updated. */
  channelPatch: ChannelPatch;
};

/** Represents an update to a `Channel`. Fields that are set will be updated. */
export type ChannelPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  defaultLang?: InputMaybe<Scalars['String']>;
  includeTax?: InputMaybe<Scalars['String']>;
  defaultZone?: InputMaybe<Scalars['String']>;
  defaultShipping?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateChannelById` mutation. */
export type UpdateChannelByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Channel` being updated. */
  channelPatch: ChannelPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Checklist` mutation. */
export type UpdateChecklistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Checklist` that was updated by this mutation. */
  checklist?: Maybe<Checklist>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Checklist`. May be used by Relay 1. */
  checklistEdge?: Maybe<ChecklistsEdge>;
};


/** The output of our update `Checklist` mutation. */
export type UpdateChecklistPayloadchecklistEdgeArgs = {
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
};

/** All input for the `updateChecklist` mutation. */
export type UpdateChecklistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Checklist` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Checklist` being updated. */
  checklistPatch: ChecklistPatch;
};

/** Represents an update to a `Checklist`. Fields that are set will be updated. */
export type ChecklistPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  username?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  regionalManager?: InputMaybe<Scalars['String']>;
  manager?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  ticket?: InputMaybe<Scalars['String']>;
  project?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateChecklistById` mutation. */
export type UpdateChecklistByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Checklist` being updated. */
  checklistPatch: ChecklistPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `City` mutation. */
export type UpdateCityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `City` that was updated by this mutation. */
  city?: Maybe<City>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `City`. May be used by Relay 1. */
  cityEdge?: Maybe<CitiesEdge>;
};


/** The output of our update `City` mutation. */
export type UpdateCityPayloadcityEdgeArgs = {
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
};

/** All input for the `updateCity` mutation. */
export type UpdateCityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `City` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `City` being updated. */
  cityPatch: CityPatch;
};

/** Represents an update to a `City`. Fields that are set will be updated. */
export type CityPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postalCode?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCityById` mutation. */
export type UpdateCityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `City` being updated. */
  cityPatch: CityPatch;
  id: Scalars['Int'];
};

/** The output of our update `Collection` mutation. */
export type UpdateCollectionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Collection` that was updated by this mutation. */
  collection?: Maybe<Collection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Collection`. May be used by Relay 1. */
  collectionEdge?: Maybe<CollectionsEdge>;
};


/** The output of our update `Collection` mutation. */
export type UpdateCollectionPayloadcollectionEdgeArgs = {
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
};

/** All input for the `updateCollection` mutation. */
export type UpdateCollectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Collection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Collection` being updated. */
  collectionPatch: CollectionPatch;
};

/** Represents an update to a `Collection`. Fields that are set will be updated. */
export type CollectionPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCollectionById` mutation. */
export type UpdateCollectionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Collection` being updated. */
  collectionPatch: CollectionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Comment` mutation. */
export type UpdateCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Comment` that was updated by this mutation. */
  comment?: Maybe<Comment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  commentEdge?: Maybe<CommentsEdge>;
};


/** The output of our update `Comment` mutation. */
export type UpdateCommentPayloadcommentEdgeArgs = {
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
};

/** All input for the `updateComment` mutation. */
export type UpdateCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Comment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Comment` being updated. */
  commentPatch: CommentPatch;
};

/** Represents an update to a `Comment`. Fields that are set will be updated. */
export type CommentPatch = {
  id?: InputMaybe<Scalars['Int']>;
  customerName?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  response?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  custId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCommentById` mutation. */
export type UpdateCommentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Comment` being updated. */
  commentPatch: CommentPatch;
  id: Scalars['Int'];
};

/** The output of our update `ContentType` mutation. */
export type UpdateContentTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContentType` that was updated by this mutation. */
  contentType?: Maybe<ContentType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ContentType`. May be used by Relay 1. */
  contentTypeEdge?: Maybe<ContentTypesEdge>;
};


/** The output of our update `ContentType` mutation. */
export type UpdateContentTypePayloadcontentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
};

/** All input for the `updateContentType` mutation. */
export type UpdateContentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContentType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ContentType` being updated. */
  contentTypePatch: ContentTypePatch;
};

/** Represents an update to a `ContentType`. Fields that are set will be updated. */
export type ContentTypePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  text?: InputMaybe<Scalars['String']>;
  number?: InputMaybe<Scalars['BigFloat']>;
  json?: InputMaybe<Scalars['JSON']>;
  link?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  uid?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['Date']>;
  time?: InputMaybe<Scalars['Time']>;
  timestamp?: InputMaybe<Scalars['Datetime']>;
  boolean?: InputMaybe<Scalars['Boolean']>;
  richText?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  databaseName?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateContentTypeById` mutation. */
export type UpdateContentTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ContentType` being updated. */
  contentTypePatch: ContentTypePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Contract` mutation. */
export type UpdateContractPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Contract` that was updated by this mutation. */
  contract?: Maybe<Contract>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Contract`. May be used by Relay 1. */
  contractEdge?: Maybe<ContractsEdge>;
};


/** The output of our update `Contract` mutation. */
export type UpdateContractPayloadcontractEdgeArgs = {
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
};

/** All input for the `updateContract` mutation. */
export type UpdateContractInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Contract` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Contract` being updated. */
  contractPatch: ContractPatch;
};

/** Represents an update to a `Contract`. Fields that are set will be updated. */
export type ContractPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  contractTitle?: InputMaybe<Scalars['String']>;
  contractValue?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  renewalReminder?: InputMaybe<Scalars['String']>;
  customerSignedDate?: InputMaybe<Scalars['String']>;
  companySignedDate?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  contractManager?: InputMaybe<Scalars['String']>;
  account?: InputMaybe<Scalars['String']>;
  contact?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  opportunity?: InputMaybe<Scalars['String']>;
  contractType?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  lineItems?: InputMaybe<Scalars['String']>;
  total?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  shipping?: InputMaybe<Scalars['String']>;
  shippingTax?: InputMaybe<Scalars['String']>;
  tax?: InputMaybe<Scalars['String']>;
  grandTotal?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateContractById` mutation. */
export type UpdateContractByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Contract` being updated. */
  contractPatch: ContractPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Country` mutation. */
export type UpdateCountryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was updated by this mutation. */
  country?: Maybe<Country>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our update `Country` mutation. */
export type UpdateCountryPayloadcountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the `updateCountry` mutation. */
export type UpdateCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Country` being updated. */
  countryPatch: CountryPatch;
};

/** Represents an update to a `Country`. Fields that are set will be updated. */
export type CountryPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCountryById` mutation. */
export type UpdateCountryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Country` being updated. */
  countryPatch: CountryPatch;
  id: Scalars['Int'];
};

/** The output of our update `Coupon` mutation. */
export type UpdateCouponPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Coupon` that was updated by this mutation. */
  coupon?: Maybe<Coupon>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Coupon`. May be used by Relay 1. */
  couponEdge?: Maybe<CouponsEdge>;
};


/** The output of our update `Coupon` mutation. */
export type UpdateCouponPayloadcouponEdgeArgs = {
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
};

/** All input for the `updateCoupon` mutation. */
export type UpdateCouponInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Coupon` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Coupon` being updated. */
  couponPatch: CouponPatch;
};

/** Represents an update to a `Coupon`. Fields that are set will be updated. */
export type CouponPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  productsCouponsToproducts?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCouponById` mutation. */
export type UpdateCouponByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Coupon` being updated. */
  couponPatch: CouponPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CreditMemo` mutation. */
export type UpdateCreditMemoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CreditMemo` that was updated by this mutation. */
  creditMemo?: Maybe<CreditMemo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CreditMemo`. May be used by Relay 1. */
  creditMemoEdge?: Maybe<CreditMemosEdge>;
};


/** The output of our update `CreditMemo` mutation. */
export type UpdateCreditMemoPayloadcreditMemoEdgeArgs = {
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
};

/** All input for the `updateCreditMemo` mutation. */
export type UpdateCreditMemoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CreditMemo` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CreditMemo` being updated. */
  creditMemoPatch: CreditMemoPatch;
};

/** Represents an update to a `CreditMemo`. Fields that are set will be updated. */
export type CreditMemoPatch = {
  creditMemo?: InputMaybe<Scalars['String']>;
  orderNumber?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['Datetime']>;
  billToName?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  refunded?: InputMaybe<Scalars['String']>;
  action?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  custId?: InputMaybe<Scalars['Int']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCreditMemoByCreditMemoAndId` mutation. */
export type UpdateCreditMemoByCreditMemoAndIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CreditMemo` being updated. */
  creditMemoPatch: CreditMemoPatch;
  creditMemo: Scalars['String'];
  id: Scalars['BigInt'];
};

/** The output of our update `Currency` mutation. */
export type UpdateCurrencyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Currency` that was updated by this mutation. */
  currency?: Maybe<Currency>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Currency`. May be used by Relay 1. */
  currencyEdge?: Maybe<CurrenciesEdge>;
};


/** The output of our update `Currency` mutation. */
export type UpdateCurrencyPayloadcurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
};

/** All input for the `updateCurrency` mutation. */
export type UpdateCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Currency` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Currency` being updated. */
  currencyPatch: CurrencyPatch;
};

/** Represents an update to a `Currency`. Fields that are set will be updated. */
export type CurrencyPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCurrencyById` mutation. */
export type UpdateCurrencyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Currency` being updated. */
  currencyPatch: CurrencyPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `CurrencyRate` mutation. */
export type UpdateCurrencyRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencyRate` that was updated by this mutation. */
  currencyRate?: Maybe<CurrencyRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencyRate`. May be used by Relay 1. */
  currencyRateEdge?: Maybe<CurrencyRatesEdge>;
};


/** The output of our update `CurrencyRate` mutation. */
export type UpdateCurrencyRatePayloadcurrencyRateEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
};

/** All input for the `updateCurrencyRate` mutation. */
export type UpdateCurrencyRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CurrencyRate` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CurrencyRate` being updated. */
  currencyRatePatch: CurrencyRatePatch;
};

/** Represents an update to a `CurrencyRate`. Fields that are set will be updated. */
export type CurrencyRatePatch = {
  importService?: InputMaybe<Scalars['String']>;
  usd?: InputMaybe<Scalars['BigFloat']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the `updateCurrencyRateByImportService` mutation. */
export type UpdateCurrencyRateByImportServiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CurrencyRate` being updated. */
  currencyRatePatch: CurrencyRatePatch;
  importService: Scalars['String'];
};

/** The output of our update `CurrencySymbol` mutation. */
export type UpdateCurrencySymbolPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencySymbol` that was updated by this mutation. */
  currencySymbol?: Maybe<CurrencySymbol>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencySymbol`. May be used by Relay 1. */
  currencySymbolEdge?: Maybe<CurrencySymbolsEdge>;
};


/** The output of our update `CurrencySymbol` mutation. */
export type UpdateCurrencySymbolPayloadcurrencySymbolEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
};

/** All input for the `updateCurrencySymbol` mutation. */
export type UpdateCurrencySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CurrencySymbol` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CurrencySymbol` being updated. */
  currencySymbolPatch: CurrencySymbolPatch;
};

/** Represents an update to a `CurrencySymbol`. Fields that are set will be updated. */
export type CurrencySymbolPatch = {
  symbol?: InputMaybe<Scalars['String']>;
  useStandard?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the `updateCurrencySymbolBySymbol` mutation. */
export type UpdateCurrencySymbolBySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CurrencySymbol` being updated. */
  currencySymbolPatch: CurrencySymbolPatch;
  symbol: Scalars['String'];
};

/** The output of our update `CustomerGroup` mutation. */
export type UpdateCustomerGroupPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerGroup` that was updated by this mutation. */
  customerGroup?: Maybe<CustomerGroup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerGroup`. May be used by Relay 1. */
  customerGroupEdge?: Maybe<CustomerGroupsEdge>;
};


/** The output of our update `CustomerGroup` mutation. */
export type UpdateCustomerGroupPayloadcustomerGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
};

/** All input for the `updateCustomerGroup` mutation. */
export type UpdateCustomerGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerGroup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `CustomerGroup` being updated. */
  customerGroupPatch: CustomerGroupPatch;
};

/** Represents an update to a `CustomerGroup`. Fields that are set will be updated. */
export type CustomerGroupPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  taxClass?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  coverPhoto?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCustomerGroupById` mutation. */
export type UpdateCustomerGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `CustomerGroup` being updated. */
  customerGroupPatch: CustomerGroupPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was updated by this mutation. */
  customer?: Maybe<Customer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our update `Customer` mutation. */
export type UpdateCustomerPayloadcustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the `updateCustomer` mutation. */
export type UpdateCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Customer` being updated. */
  customerPatch: CustomerPatch;
};

/** Represents an update to a `Customer`. Fields that are set will be updated. */
export type CustomerPatch = {
  id?: InputMaybe<Scalars['Int']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  namePrefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  middleName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  customerGroup?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  nameSuffix?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  customerSince?: InputMaybe<Scalars['Datetime']>;
  confirmedEmail?: InputMaybe<Scalars['String']>;
  dateOfBirth?: InputMaybe<Scalars['String']>;
  taxVatNumber?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  shortDescription?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  paymentType?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  creditMemos?: InputMaybe<Scalars['String']>;
  customerPayment?: InputMaybe<Scalars['String']>;
  emails?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  messages?: InputMaybe<Scalars['String']>;
  newsletterSubscribers?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  returns?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCustomerById` mutation. */
export type UpdateCustomerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Customer` being updated. */
  customerPatch: CustomerPatch;
  id: Scalars['Int'];
};

/** The output of our update `Customization` mutation. */
export type UpdateCustomizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customization` that was updated by this mutation. */
  customization?: Maybe<Customization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customization`. May be used by Relay 1. */
  customizationEdge?: Maybe<CustomizationsEdge>;
};


/** The output of our update `Customization` mutation. */
export type UpdateCustomizationPayloadcustomizationEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
};

/** All input for the `updateCustomization` mutation. */
export type UpdateCustomizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customization` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Customization` being updated. */
  customizationPatch: CustomizationPatch;
};

/** Represents an update to a `Customization`. Fields that are set will be updated. */
export type CustomizationPatch = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  siteName?: InputMaybe<Scalars['String']>;
  navLink?: InputMaybe<Scalars['String']>;
  notification?: InputMaybe<Scalars['String']>;
  banner?: InputMaybe<Scalars['String']>;
  footerLink?: InputMaybe<Scalars['String']>;
  announcement?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  siteUrl?: InputMaybe<Scalars['String']>;
  allowSignup?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateCustomizationById` mutation. */
export type UpdateCustomizationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Customization` being updated. */
  customizationPatch: CustomizationPatch;
  id: Scalars['Int'];
};

/** The output of our update `Dashboard` mutation. */
export type UpdateDashboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Dashboard` that was updated by this mutation. */
  dashboard?: Maybe<Dashboard>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Dashboard`. May be used by Relay 1. */
  dashboardEdge?: Maybe<DashboardsEdge>;
};


/** The output of our update `Dashboard` mutation. */
export type UpdateDashboardPayloaddashboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
};

/** All input for the `updateDashboard` mutation. */
export type UpdateDashboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dashboard` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Dashboard` being updated. */
  dashboardPatch: DashboardPatch;
};

/** Represents an update to a `Dashboard`. Fields that are set will be updated. */
export type DashboardPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  privacy?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  checklists?: InputMaybe<Scalars['String']>;
  visits?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  sales?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateDashboardById` mutation. */
export type UpdateDashboardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Dashboard` being updated. */
  dashboardPatch: DashboardPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Deepdive` mutation. */
export type UpdateDeepdivePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Deepdive` that was updated by this mutation. */
  deepdive?: Maybe<Deepdive>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Deepdive`. May be used by Relay 1. */
  deepdiveEdge?: Maybe<DeepdivesEdge>;
};


/** The output of our update `Deepdive` mutation. */
export type UpdateDeepdivePayloaddeepdiveEdgeArgs = {
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
};

/** All input for the `updateDeepdive` mutation. */
export type UpdateDeepdiveInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Deepdive` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Deepdive` being updated. */
  deepdivePatch: DeepdivePatch;
};

/** Represents an update to a `Deepdive`. Fields that are set will be updated. */
export type DeepdivePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  endDate?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  attendees?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateDeepdiveById` mutation. */
export type UpdateDeepdiveByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Deepdive` being updated. */
  deepdivePatch: DeepdivePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Digiboard` mutation. */
export type UpdateDigiboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Digiboard` that was updated by this mutation. */
  digiboard?: Maybe<Digiboard>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Digiboard`. May be used by Relay 1. */
  digiboardEdge?: Maybe<DigiboardsEdge>;
};


/** The output of our update `Digiboard` mutation. */
export type UpdateDigiboardPayloaddigiboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
};

/** All input for the `updateDigiboard` mutation. */
export type UpdateDigiboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Digiboard` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Digiboard` being updated. */
  digiboardPatch: DigiboardPatch;
};

/** Represents an update to a `Digiboard`. Fields that are set will be updated. */
export type DigiboardPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  board?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  student?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateDigiboardById` mutation. */
export type UpdateDigiboardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Digiboard` being updated. */
  digiboardPatch: DigiboardPatch;
  id: Scalars['Int'];
};

/** The output of our update `Email` mutation. */
export type UpdateEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was updated by this mutation. */
  email?: Maybe<Email>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our update `Email` mutation. */
export type UpdateEmailPayloademailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the `updateEmail` mutation. */
export type UpdateEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Email` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Email` being updated. */
  emailPatch: EmailPatch;
};

/** Represents an update to a `Email`. Fields that are set will be updated. */
export type EmailPatch = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  bcc?: InputMaybe<Scalars['String']>;
  cc?: InputMaybe<Scalars['String']>;
  from?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateEmailById` mutation. */
export type UpdateEmailByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Email` being updated. */
  emailPatch: EmailPatch;
  id: Scalars['Int'];
};

/** The output of our update `Endofshift` mutation. */
export type UpdateEndofshiftPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Endofshift` that was updated by this mutation. */
  endofshift?: Maybe<Endofshift>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Endofshift`. May be used by Relay 1. */
  endofshiftEdge?: Maybe<EndofshiftsEdge>;
};


/** The output of our update `Endofshift` mutation. */
export type UpdateEndofshiftPayloadendofshiftEdgeArgs = {
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
};

/** All input for the `updateEndofshift` mutation. */
export type UpdateEndofshiftInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Endofshift` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Endofshift` being updated. */
  endofshiftPatch: EndofshiftPatch;
};

/** Represents an update to a `Endofshift`. Fields that are set will be updated. */
export type EndofshiftPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  content?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  mcms?: InputMaybe<Scalars['String']>;
  nextShift?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateEndofshiftById` mutation. */
export type UpdateEndofshiftByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Endofshift` being updated. */
  endofshiftPatch: EndofshiftPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Event` mutation. */
export type UpdateEventPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` that was updated by this mutation. */
  event?: Maybe<Event>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
};


/** The output of our update `Event` mutation. */
export type UpdateEventPayloadeventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `updateEvent` mutation. */
export type UpdateEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Event` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Event` being updated. */
  eventPatch: EventPatch;
};

/** Represents an update to a `Event`. Fields that are set will be updated. */
export type EventPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  tickets?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  start?: InputMaybe<Scalars['String']>;
  end?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateEventById` mutation. */
export type UpdateEventByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Event` being updated. */
  eventPatch: EventPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Fullfillment` mutation. */
export type UpdateFullfillmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Fullfillment` that was updated by this mutation. */
  fullfillment?: Maybe<Fullfillment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Fullfillment`. May be used by Relay 1. */
  fullfillmentEdge?: Maybe<FullfillmentsEdge>;
};


/** The output of our update `Fullfillment` mutation. */
export type UpdateFullfillmentPayloadfullfillmentEdgeArgs = {
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
};

/** All input for the `updateFullfillment` mutation. */
export type UpdateFullfillmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Fullfillment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Fullfillment` being updated. */
  fullfillmentPatch: FullfillmentPatch;
};

/** Represents an update to a `Fullfillment`. Fields that are set will be updated. */
export type FullfillmentPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  shippingZones?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  countryArea?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  pickup?: InputMaybe<Scalars['String']>;
  stock?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateFullfillmentById` mutation. */
export type UpdateFullfillmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Fullfillment` being updated. */
  fullfillmentPatch: FullfillmentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `GiftCertificate` mutation. */
export type UpdateGiftCertificatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GiftCertificate` that was updated by this mutation. */
  giftCertificate?: Maybe<GiftCertificate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `GiftCertificate`. May be used by Relay 1. */
  giftCertificateEdge?: Maybe<GiftCertificatesEdge>;
};


/** The output of our update `GiftCertificate` mutation. */
export type UpdateGiftCertificatePayloadgiftCertificateEdgeArgs = {
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
};

/** All input for the `updateGiftCertificate` mutation. */
export type UpdateGiftCertificateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GiftCertificate` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GiftCertificate` being updated. */
  giftCertificatePatch: GiftCertificatePatch;
};

/** Represents an update to a `GiftCertificate`. Fields that are set will be updated. */
export type GiftCertificatePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  specialOffers?: InputMaybe<Scalars['String']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateGiftCertificateById` mutation. */
export type UpdateGiftCertificateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GiftCertificate` being updated. */
  giftCertificatePatch: GiftCertificatePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Glossary` mutation. */
export type UpdateGlossaryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Glossary` that was updated by this mutation. */
  glossary?: Maybe<Glossary>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Glossary`. May be used by Relay 1. */
  glossaryEdge?: Maybe<GlossariesEdge>;
};


/** The output of our update `Glossary` mutation. */
export type UpdateGlossaryPayloadglossaryEdgeArgs = {
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
};

/** All input for the `updateGlossary` mutation. */
export type UpdateGlossaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Glossary` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Glossary` being updated. */
  glossaryPatch: GlossaryPatch;
};

/** Represents an update to a `Glossary`. Fields that are set will be updated. */
export type GlossaryPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateGlossaryById` mutation. */
export type UpdateGlossaryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Glossary` being updated. */
  glossaryPatch: GlossaryPatch;
  id: Scalars['Int'];
};

/** The output of our update `Importm` mutation. */
export type UpdateImportmPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Importm` that was updated by this mutation. */
  importm?: Maybe<Importm>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Importm`. May be used by Relay 1. */
  importmEdge?: Maybe<ImportmsEdge>;
};


/** The output of our update `Importm` mutation. */
export type UpdateImportmPayloadimportmEdgeArgs = {
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
};

/** All input for the `updateImportm` mutation. */
export type UpdateImportmInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Importm` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Importm` being updated. */
  importmPatch: ImportmPatch;
};

/** Represents an update to a `Importm`. Fields that are set will be updated. */
export type ImportmPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateImportmById` mutation. */
export type UpdateImportmByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Importm` being updated. */
  importmPatch: ImportmPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Integration` mutation. */
export type UpdateIntegrationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Integration` that was updated by this mutation. */
  integration?: Maybe<Integration>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Integration`. May be used by Relay 1. */
  integrationEdge?: Maybe<IntegrationsEdge>;
};


/** The output of our update `Integration` mutation. */
export type UpdateIntegrationPayloadintegrationEdgeArgs = {
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
};

/** All input for the `updateIntegration` mutation. */
export type UpdateIntegrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Integration` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Integration` being updated. */
  integrationPatch: IntegrationPatch;
};

/** Represents an update to a `Integration`. Fields that are set will be updated. */
export type IntegrationPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateIntegrationById` mutation. */
export type UpdateIntegrationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Integration` being updated. */
  integrationPatch: IntegrationPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Internalization` mutation. */
export type UpdateInternalizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Internalization` that was updated by this mutation. */
  internalization?: Maybe<Internalization>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Internalization`. May be used by Relay 1. */
  internalizationEdge?: Maybe<InternalizationsEdge>;
};


/** The output of our update `Internalization` mutation. */
export type UpdateInternalizationPayloadinternalizationEdgeArgs = {
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
};

/** All input for the `updateInternalization` mutation. */
export type UpdateInternalizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Internalization` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Internalization` being updated. */
  internalizationPatch: InternalizationPatch;
};

/** Represents an update to a `Internalization`. Fields that are set will be updated. */
export type InternalizationPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateInternalizationById` mutation. */
export type UpdateInternalizationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Internalization` being updated. */
  internalizationPatch: InternalizationPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Invitation` mutation. */
export type UpdateInvitationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invitation` that was updated by this mutation. */
  invitation?: Maybe<Invitation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invitation`. May be used by Relay 1. */
  invitationEdge?: Maybe<InvitationsEdge>;
};


/** The output of our update `Invitation` mutation. */
export type UpdateInvitationPayloadinvitationEdgeArgs = {
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
};

/** All input for the `updateInvitation` mutation. */
export type UpdateInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invitation` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Invitation` being updated. */
  invitationPatch: InvitationPatch;
};

/** Represents an update to a `Invitation`. Fields that are set will be updated. */
export type InvitationPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  email?: InputMaybe<Scalars['String']>;
  billingAddress?: InputMaybe<Scalars['String']>;
  shippingAddress?: InputMaybe<Scalars['String']>;
  orderNumber?: InputMaybe<Scalars['String']>;
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateInvitationById` mutation. */
export type UpdateInvitationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Invitation` being updated. */
  invitationPatch: InvitationPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was updated by this mutation. */
  invoice?: Maybe<Invoice>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our update `Invoice` mutation. */
export type UpdateInvoicePayloadinvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the `updateInvoice` mutation. */
export type UpdateInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invoice` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  invoicePatch: InvoicePatch;
};

/** Represents an update to a `Invoice`. Fields that are set will be updated. */
export type InvoicePatch = {
  invoice?: InputMaybe<Scalars['Int']>;
  orderNumber?: InputMaybe<Scalars['BigInt']>;
  invoiceDate?: InputMaybe<Scalars['Datetime']>;
  billToName?: InputMaybe<Scalars['String']>;
  billingAddress?: InputMaybe<Scalars['String']>;
  grandTotalBase?: InputMaybe<Scalars['String']>;
  grandTotalPurchased?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  shippingAddress?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  customerGroup?: InputMaybe<Scalars['String']>;
  paymentMethod?: InputMaybe<Scalars['String']>;
  shippingInformation?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  shippingAndHandling?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
};

/** All input for the `updateInvoiceById` mutation. */
export type UpdateInvoiceByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Invoice` being updated. */
  invoicePatch: InvoicePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Lead` mutation. */
export type UpdateLeadPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lead` that was updated by this mutation. */
  lead?: Maybe<Lead>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
};


/** The output of our update `Lead` mutation. */
export type UpdateLeadPayloadleadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the `updateLead` mutation. */
export type UpdateLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lead` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Lead` being updated. */
  leadPatch: LeadPatch;
};

/** Represents an update to a `Lead`. Fields that are set will be updated. */
export type LeadPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  prefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  mobile?: InputMaybe<Scalars['String']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  statusDescription?: InputMaybe<Scalars['String']>;
  opportunityAmount?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
  leadSource?: InputMaybe<Scalars['String']>;
  leadSourceDescription?: InputMaybe<Scalars['String']>;
  referredBy?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateLeadById` mutation. */
export type UpdateLeadByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Lead` being updated. */
  leadPatch: LeadPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Manufacturer` mutation. */
export type UpdateManufacturerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Manufacturer` that was updated by this mutation. */
  manufacturer?: Maybe<Manufacturer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Manufacturer`. May be used by Relay 1. */
  manufacturerEdge?: Maybe<ManufacturersEdge>;
};


/** The output of our update `Manufacturer` mutation. */
export type UpdateManufacturerPayloadmanufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
};

/** All input for the `updateManufacturer` mutation. */
export type UpdateManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Manufacturer` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Manufacturer` being updated. */
  manufacturerPatch: ManufacturerPatch;
};

/** Represents an update to a `Manufacturer`. Fields that are set will be updated. */
export type ManufacturerPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['BigInt']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateManufacturerById` mutation. */
export type UpdateManufacturerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Manufacturer` being updated. */
  manufacturerPatch: ManufacturerPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Mediamanager` mutation. */
export type UpdateMediamanagerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Mediamanager` that was updated by this mutation. */
  mediamanager?: Maybe<Mediamanager>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Mediamanager`. May be used by Relay 1. */
  mediamanagerEdge?: Maybe<MediamanagersEdge>;
};


/** The output of our update `Mediamanager` mutation. */
export type UpdateMediamanagerPayloadmediamanagerEdgeArgs = {
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
};

/** All input for the `updateMediamanager` mutation. */
export type UpdateMediamanagerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Mediamanager` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Mediamanager` being updated. */
  mediamanagerPatch: MediamanagerPatch;
};

/** Represents an update to a `Mediamanager`. Fields that are set will be updated. */
export type MediamanagerPatch = {
  id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  keywords?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  brands?: InputMaybe<Scalars['BigInt']>;
  status?: InputMaybe<Scalars['String']>;
  expirationDate?: InputMaybe<Scalars['String']>;
  copyright?: InputMaybe<Scalars['String']>;
  dimensions?: InputMaybe<Scalars['String']>;
  author?: InputMaybe<Scalars['Int']>;
  contentType?: InputMaybe<Scalars['String']>;
  versions?: InputMaybe<Scalars['String']>;
  watermarkName?: InputMaybe<Scalars['String']>;
  watermarkDescription?: InputMaybe<Scalars['String']>;
  watermarkMedia?: InputMaybe<Scalars['String']>;
  agreements?: InputMaybe<Scalars['Int']>;
  albums?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['Int']>;
  workspace?: InputMaybe<Scalars['String']>;
  taskName?: InputMaybe<Scalars['BigInt']>;
  taskDescription?: InputMaybe<Scalars['String']>;
  taskType?: InputMaybe<Scalars['String']>;
  members?: InputMaybe<Scalars['Int']>;
  products?: InputMaybe<Scalars['BigInt']>;
  agreementsAgreementsTomediamanager?: InputMaybe<Scalars['String']>;
  brandsBrandsTomediamanager?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  productsMediamanagerToproducts?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateMediamanagerById` mutation. */
export type UpdateMediamanagerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Mediamanager` being updated. */
  mediamanagerPatch: MediamanagerPatch;
  id: Scalars['Int'];
};

/** The output of our update `Meeting` mutation. */
export type UpdateMeetingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Meeting` that was updated by this mutation. */
  meeting?: Maybe<Meeting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Meeting`. May be used by Relay 1. */
  meetingEdge?: Maybe<MeetingsEdge>;
};


/** The output of our update `Meeting` mutation. */
export type UpdateMeetingPayloadmeetingEdgeArgs = {
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
};

/** All input for the `updateMeeting` mutation. */
export type UpdateMeetingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Meeting` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Meeting` being updated. */
  meetingPatch: MeetingPatch;
};

/** Represents an update to a `Meeting`. Fields that are set will be updated. */
export type MeetingPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  duration?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  relatedTo?: InputMaybe<Scalars['String']>;
  reminders?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  invitees?: InputMaybe<Scalars['String']>;
  scheduling?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateMeetingById` mutation. */
export type UpdateMeetingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Meeting` being updated. */
  meetingPatch: MeetingPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Message` mutation. */
export type UpdateMessagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was updated by this mutation. */
  message?: Maybe<Message>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
};


/** The output of our update `Message` mutation. */
export type UpdateMessagePayloadmessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the `updateMessage` mutation. */
export type UpdateMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Message` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Message` being updated. */
  messagePatch: MessagePatch;
};

/** Represents an update to a `Message`. Fields that are set will be updated. */
export type MessagePatch = {
  id?: InputMaybe<Scalars['Int']>;
  from?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  media?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateMessageById` mutation. */
export type UpdateMessageByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Message` being updated. */
  messagePatch: MessagePatch;
  id: Scalars['Int'];
};

/** The output of our update `Newsletter` mutation. */
export type UpdateNewsletterPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Newsletter` that was updated by this mutation. */
  newsletter?: Maybe<Newsletter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Newsletter`. May be used by Relay 1. */
  newsletterEdge?: Maybe<NewslettersEdge>;
};


/** The output of our update `Newsletter` mutation. */
export type UpdateNewsletterPayloadnewsletterEdgeArgs = {
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
};

/** All input for the `updateNewsletter` mutation. */
export type UpdateNewsletterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Newsletter` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Newsletter` being updated. */
  newsletterPatch: NewsletterPatch;
};

/** Represents an update to a `Newsletter`. Fields that are set will be updated. */
export type NewsletterPatch = {
  id?: InputMaybe<Scalars['Int']>;
  email?: InputMaybe<Scalars['String']>;
  customerFirstName?: InputMaybe<Scalars['String']>;
  customerLastName?: InputMaybe<Scalars['String']>;
  store?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  custId?: InputMaybe<Scalars['Int']>;
  customers?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateNewsletterById` mutation. */
export type UpdateNewsletterByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Newsletter` being updated. */
  newsletterPatch: NewsletterPatch;
  id: Scalars['Int'];
};

/** The output of our update `Ooto` mutation. */
export type UpdateOotoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ooto` that was updated by this mutation. */
  ooto?: Maybe<Ooto>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ooto`. May be used by Relay 1. */
  ootoEdge?: Maybe<OotosEdge>;
};


/** The output of our update `Ooto` mutation. */
export type UpdateOotoPayloadootoEdgeArgs = {
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
};

/** All input for the `updateOoto` mutation. */
export type UpdateOotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Ooto` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Ooto` being updated. */
  ootoPatch: OotoPatch;
};

/** Represents an update to a `Ooto`. Fields that are set will be updated. */
export type OotoPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  login?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  note?: InputMaybe<Scalars['String']>;
  usingTime?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateOotoById` mutation. */
export type UpdateOotoByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Ooto` being updated. */
  ootoPatch: OotoPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Opportunity` mutation. */
export type UpdateOpportunityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Opportunity` that was updated by this mutation. */
  opportunity?: Maybe<Opportunity>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
};


/** The output of our update `Opportunity` mutation. */
export type UpdateOpportunityPayloadopportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the `updateOpportunity` mutation. */
export type UpdateOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Opportunity` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Opportunity` being updated. */
  opportunityPatch: OpportunityPatch;
};

/** Represents an update to a `Opportunity`. Fields that are set will be updated. */
export type OpportunityPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  amount?: InputMaybe<Scalars['String']>;
  salesStage?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  probability?: InputMaybe<Scalars['String']>;
  nextStep?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  leadSource?: InputMaybe<Scalars['String']>;
  campaign?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  expectedCloseDate?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateOpportunityById` mutation. */
export type UpdateOpportunityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Opportunity` being updated. */
  opportunityPatch: OpportunityPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Order` mutation. */
export type UpdateOrderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Order` that was updated by this mutation. */
  order?: Maybe<Order>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Order`. May be used by Relay 1. */
  orderEdge?: Maybe<OrdersEdge>;
};


/** The output of our update `Order` mutation. */
export type UpdateOrderPayloadorderEdgeArgs = {
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
};

/** All input for the `updateOrder` mutation. */
export type UpdateOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Order` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Order` being updated. */
  orderPatch: OrderPatch;
};

/** Represents an update to a `Order`. Fields that are set will be updated. */
export type OrderPatch = {
  id?: InputMaybe<Scalars['Int']>;
  purchasePoint?: InputMaybe<Scalars['Int']>;
  purchaseDate?: InputMaybe<Scalars['Datetime']>;
  billToName?: InputMaybe<Scalars['String']>;
  shipToName?: InputMaybe<Scalars['String']>;
  grandTotalBase?: InputMaybe<Scalars['Int']>;
  grandTotalPurchased?: InputMaybe<Scalars['Int']>;
  status?: InputMaybe<Scalars['Boolean']>;
  action?: InputMaybe<Scalars['Boolean']>;
  allocatedSources?: InputMaybe<Scalars['String']>;
  braintreeTransactionSource?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  transactions?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateOrderById` mutation. */
export type UpdateOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Order` being updated. */
  orderPatch: OrderPatch;
  id: Scalars['Int'];
};

/** The output of our update `Page` mutation. */
export type UpdatePagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` that was updated by this mutation. */
  page?: Maybe<Page>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge?: Maybe<PagesEdge>;
};


/** The output of our update `Page` mutation. */
export type UpdatePagePayloadpageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the `updatePage` mutation. */
export type UpdatePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Page` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Page` being updated. */
  pagePatch: PagePatch;
};

/** Represents an update to a `Page`. Fields that are set will be updated. */
export type PagePatch = {
  id?: InputMaybe<Scalars['Int']>;
  enablePage?: InputMaybe<Scalars['Boolean']>;
  title?: InputMaybe<Scalars['String']>;
  contentTitle?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  urlKey?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePageById` mutation. */
export type UpdatePageByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Page` being updated. */
  pagePatch: PagePatch;
  id: Scalars['Int'];
};

/** The output of our update `Partner` mutation. */
export type UpdatePartnerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Partner` that was updated by this mutation. */
  partner?: Maybe<Partner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Partner`. May be used by Relay 1. */
  partnerEdge?: Maybe<PartnersEdge>;
};


/** The output of our update `Partner` mutation. */
export type UpdatePartnerPayloadpartnerEdgeArgs = {
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
};

/** All input for the `updatePartner` mutation. */
export type UpdatePartnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Partner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Partner` being updated. */
  partnerPatch: PartnerPatch;
};

/** Represents an update to a `Partner`. Fields that are set will be updated. */
export type PartnerPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  businessType?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePartnerById` mutation. */
export type UpdatePartnerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Partner` being updated. */
  partnerPatch: PartnerPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Payment` mutation. */
export type UpdatePaymentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was updated by this mutation. */
  payment?: Maybe<Payment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our update `Payment` mutation. */
export type UpdatePaymentPayloadpaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the `updatePayment` mutation. */
export type UpdatePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Payment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Payment` being updated. */
  paymentPatch: PaymentPatch;
};

/** Represents an update to a `Payment`. Fields that are set will be updated. */
export type PaymentPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  hostUri?: InputMaybe<Scalars['String']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePaymentById` mutation. */
export type UpdatePaymentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Payment` being updated. */
  paymentPatch: PaymentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Permission` that was updated by this mutation. */
  permission?: Maybe<Permission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
};


/** The output of our update `Permission` mutation. */
export type UpdatePermissionPayloadpermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `updatePermission` mutation. */
export type UpdatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Permission` being updated. */
  permissionPatch: PermissionPatch;
};

/** Represents an update to a `Permission`. Fields that are set will be updated. */
export type PermissionPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  create?: InputMaybe<Scalars['String']>;
  delete?: InputMaybe<Scalars['String']>;
  read?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePermissionById` mutation. */
export type UpdatePermissionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Permission` being updated. */
  permissionPatch: PermissionPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Plugin` mutation. */
export type UpdatePluginPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Plugin` that was updated by this mutation. */
  plugin?: Maybe<Plugin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Plugin`. May be used by Relay 1. */
  pluginEdge?: Maybe<PluginsEdge>;
};


/** The output of our update `Plugin` mutation. */
export type UpdatePluginPayloadpluginEdgeArgs = {
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
};

/** All input for the `updatePlugin` mutation. */
export type UpdatePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Plugin` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Plugin` being updated. */
  pluginPatch: PluginPatch;
};

/** Represents an update to a `Plugin`. Fields that are set will be updated. */
export type PluginPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  githubLink?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  logo?: InputMaybe<Scalars['String']>;
  screenshots?: InputMaybe<Scalars['String']>;
  lastUpdated?: InputMaybe<Scalars['Datetime']>;
  publisherName?: InputMaybe<Scalars['String']>;
  agreeTerms?: InputMaybe<Scalars['Boolean']>;
  publisherEmail?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePluginById` mutation. */
export type UpdatePluginByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Plugin` being updated. */
  pluginPatch: PluginPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Poll` mutation. */
export type UpdatePollPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Poll` that was updated by this mutation. */
  poll?: Maybe<Poll>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Poll`. May be used by Relay 1. */
  pollEdge?: Maybe<PollsEdge>;
};


/** The output of our update `Poll` mutation. */
export type UpdatePollPayloadpollEdgeArgs = {
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
};

/** All input for the `updatePoll` mutation. */
export type UpdatePollInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Poll` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Poll` being updated. */
  pollPatch: PollPatch;
};

/** Represents an update to a `Poll`. Fields that are set will be updated. */
export type PollPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  question?: InputMaybe<Scalars['String']>;
  response?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updatePollById` mutation. */
export type UpdatePollByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Poll` being updated. */
  pollPatch: PollPatch;
  id: Scalars['Int'];
};

/** The output of our update `ProductType` mutation. */
export type UpdateProductTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductType` that was updated by this mutation. */
  productType?: Maybe<ProductType>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductType`. May be used by Relay 1. */
  productTypeEdge?: Maybe<ProductTypesEdge>;
};


/** The output of our update `ProductType` mutation. */
export type UpdateProductTypePayloadproductTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
};

/** All input for the `updateProductType` mutation. */
export type UpdateProductTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductType` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ProductType` being updated. */
  productTypePatch: ProductTypePatch;
};

/** Represents an update to a `ProductType`. Fields that are set will be updated. */
export type ProductTypePatch = {
  id?: InputMaybe<Scalars['Int']>;
  typeName?: InputMaybe<Scalars['String']>;
  taxes?: InputMaybe<Scalars['String']>;
  isShippable?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  filterOptions?: InputMaybe<Scalars['String']>;
  productType?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateProductTypeById` mutation. */
export type UpdateProductTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ProductType` being updated. */
  productTypePatch: ProductTypePatch;
  id: Scalars['Int'];
};

/** The output of our update `Product` mutation. */
export type UpdateProductPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Product` that was updated by this mutation. */
  product?: Maybe<Product>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Product`. May be used by Relay 1. */
  productEdge?: Maybe<ProductsEdge>;
};


/** The output of our update `Product` mutation. */
export type UpdateProductPayloadproductEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
};

/** All input for the `updateProduct` mutation. */
export type UpdateProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Product` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Product` being updated. */
  productPatch: ProductPatch;
};

/** Represents an update to a `Product`. Fields that are set will be updated. */
export type ProductPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  sku?: InputMaybe<Scalars['BigInt']>;
  thumbnail?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  price?: InputMaybe<Scalars['String']>;
  quantityPerSource?: InputMaybe<Scalars['String']>;
  salableQuantity?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['Boolean']>;
  websites?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  taxClass?: InputMaybe<Scalars['String']>;
  stockStatus?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  country?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['String']>;
  format?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  shortDescription?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  metaTitle?: InputMaybe<Scalars['String']>;
  metaKeywords?: InputMaybe<Scalars['String']>;
  metaDescription?: InputMaybe<Scalars['String']>;
  metaUrl?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
  manufacture?: InputMaybe<Scalars['String']>;
  attributes?: InputMaybe<Scalars['String']>;
  brand?: InputMaybe<Scalars['String']>;
  contract?: InputMaybe<Scalars['String']>;
  costString?: InputMaybe<Scalars['String']>;
  customerType?: InputMaybe<Scalars['String']>;
  family?: InputMaybe<Scalars['String']>;
  manufacturerPartNumber?: InputMaybe<Scalars['String']>;
  occassions?: InputMaybe<Scalars['String']>;
  partNumber?: InputMaybe<Scalars['String']>;
  relatedProduct?: InputMaybe<Scalars['BigInt']>;
  tags?: InputMaybe<Scalars['String']>;
  types?: InputMaybe<Scalars['String']>;
  variants?: InputMaybe<Scalars['String']>;
  zone?: InputMaybe<Scalars['String']>;
  brands?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  creditMemos?: InputMaybe<Scalars['String']>;
  manufacturer?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  occassionsOccassionsToproducts?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  otherProducts?: InputMaybe<Scalars['String']>;
  productAttribute?: InputMaybe<Scalars['String']>;
  productTypes?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  returns?: InputMaybe<Scalars['String']>;
  taxRate?: InputMaybe<Scalars['String']>;
  taxRule?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateProductById` mutation. */
export type UpdateProductByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Product` being updated. */
  productPatch: ProductPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Project` mutation. */
export type UpdateProjectPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Project` that was updated by this mutation. */
  project?: Maybe<Project>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
};


/** The output of our update `Project` mutation. */
export type UpdateProjectPayloadprojectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the `updateProject` mutation. */
export type UpdateProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Project` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Project` being updated. */
  projectPatch: ProjectPatch;
};

/** Represents an update to a `Project`. Fields that are set will be updated. */
export type ProjectPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  name?: InputMaybe<Scalars['String']>;
  projectManager?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  resource?: InputMaybe<Scalars['String']>;
  considerworkingdays?: InputMaybe<Scalars['String']>;
  projectTemplate?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  assignee?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  doing?: InputMaybe<Scalars['String']>;
  done?: InputMaybe<Scalars['String']>;
  goalCollaborators?: InputMaybe<Scalars['String']>;
  goalMeasurement?: InputMaybe<Scalars['String']>;
  goalName?: InputMaybe<Scalars['String']>;
  goalPrivacy?: InputMaybe<Scalars['String']>;
  goalProgressSource?: InputMaybe<Scalars['String']>;
  goalTimeperiod?: InputMaybe<Scalars['String']>;
  goalUpdatemethod?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  sectionRule?: InputMaybe<Scalars['String']>;
  staffId?: InputMaybe<Scalars['Int']>;
  taskId?: InputMaybe<Scalars['BigInt']>;
  ticketId?: InputMaybe<Scalars['BigInt']>;
  customers?: InputMaybe<Scalars['String']>;
  tasks?: InputMaybe<Scalars['String']>;
  ticketing?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  product?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  method?: InputMaybe<Scalars['String']>;
  zone?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  team?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  company?: InputMaybe<Scalars['String']>;
  file?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateProjectById` mutation. */
export type UpdateProjectByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Project` being updated. */
  projectPatch: ProjectPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Provider` mutation. */
export type UpdateProviderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Provider` that was updated by this mutation. */
  provider?: Maybe<Provider>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Provider`. May be used by Relay 1. */
  providerEdge?: Maybe<ProvidersEdge>;
};


/** The output of our update `Provider` mutation. */
export type UpdateProviderPayloadproviderEdgeArgs = {
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
};

/** All input for the `updateProvider` mutation. */
export type UpdateProviderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Provider` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Provider` being updated. */
  providerPatch: ProviderPatch;
};

/** Represents an update to a `Provider`. Fields that are set will be updated. */
export type ProviderPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  hostUri?: InputMaybe<Scalars['String']>;
  redirectUrl?: InputMaybe<Scalars['String']>;
  redirectUrlApp?: InputMaybe<Scalars['String']>;
  icon?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateProviderById` mutation. */
export type UpdateProviderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Provider` being updated. */
  providerPatch: ProviderPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Quote` mutation. */
export type UpdateQuotePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was updated by this mutation. */
  quote?: Maybe<Quote>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our update `Quote` mutation. */
export type UpdateQuotePayloadquoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the `updateQuote` mutation. */
export type UpdateQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Quote` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Quote` being updated. */
  quotePatch: QuotePatch;
};

/** Represents an update to a `Quote`. Fields that are set will be updated. */
export type QuotePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  grandTotal?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  categories?: InputMaybe<Scalars['String']>;
  validUntil?: InputMaybe<Scalars['String']>;
  quoteStage?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  custId?: InputMaybe<Scalars['Int']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  orderId?: InputMaybe<Scalars['Int']>;
  account?: InputMaybe<Scalars['String']>;
  approvalIssues?: InputMaybe<Scalars['String']>;
  approvalStatus?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  billingCity?: InputMaybe<Scalars['String']>;
  billingCountry?: InputMaybe<Scalars['String']>;
  billingPostal?: InputMaybe<Scalars['String']>;
  billingState?: InputMaybe<Scalars['String']>;
  billingStreet?: InputMaybe<Scalars['String']>;
  contact?: InputMaybe<Scalars['String']>;
  currency?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['String']>;
  invoiceStatus?: InputMaybe<Scalars['String']>;
  lineItemDiscount?: InputMaybe<Scalars['String']>;
  lineItemGroupTotal?: InputMaybe<Scalars['String']>;
  lineItemName?: InputMaybe<Scalars['String']>;
  lineItemSubtotal?: InputMaybe<Scalars['String']>;
  lineItemTax?: InputMaybe<Scalars['String']>;
  lineItemTotal?: InputMaybe<Scalars['String']>;
  paymentTerms?: InputMaybe<Scalars['String']>;
  shipping?: InputMaybe<Scalars['String']>;
  shippingCity?: InputMaybe<Scalars['String']>;
  shippingCountry?: InputMaybe<Scalars['String']>;
  shippingPostal?: InputMaybe<Scalars['String']>;
  shippingState?: InputMaybe<Scalars['String']>;
  shippingStreet?: InputMaybe<Scalars['String']>;
  shippingTax?: InputMaybe<Scalars['String']>;
  subtotal?: InputMaybe<Scalars['String']>;
  tax?: InputMaybe<Scalars['String']>;
  total?: InputMaybe<Scalars['String']>;
  customersCustomersToquotes?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
  productsProductsToquotes?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateQuoteById` mutation. */
export type UpdateQuoteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Quote` being updated. */
  quotePatch: QuotePatch;
  id: Scalars['Int'];
};

/** The output of our update `Rating` mutation. */
export type UpdateRatingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Rating` that was updated by this mutation. */
  rating?: Maybe<Rating>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Rating`. May be used by Relay 1. */
  ratingEdge?: Maybe<RatingsEdge>;
};


/** The output of our update `Rating` mutation. */
export type UpdateRatingPayloadratingEdgeArgs = {
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
};

/** All input for the `updateRating` mutation. */
export type UpdateRatingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rating` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Rating` being updated. */
  ratingPatch: RatingPatch;
};

/** Represents an update to a `Rating`. Fields that are set will be updated. */
export type RatingPatch = {
  id?: InputMaybe<Scalars['Int']>;
  defaultValue?: InputMaybe<Scalars['String']>;
  defaultStoreView?: InputMaybe<Scalars['String']>;
  ratingVisibility?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  sortOrder?: InputMaybe<Scalars['BigFloat']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateRatingById` mutation. */
export type UpdateRatingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Rating` being updated. */
  ratingPatch: RatingPatch;
  id: Scalars['Int'];
};

/** The output of our update `Report` mutation. */
export type UpdateReportPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Report` that was updated by this mutation. */
  report?: Maybe<Report>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
};


/** The output of our update `Report` mutation. */
export type UpdateReportPayloadreportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the `updateReport` mutation. */
export type UpdateReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Report` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Report` being updated. */
  reportPatch: ReportPatch;
};

/** Represents an update to a `Report`. Fields that are set will be updated. */
export type ReportPatch = {
  id?: InputMaybe<Scalars['Int']>;
  customer?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['BigFloat']>;
  subtotal?: InputMaybe<Scalars['String']>;
  appliedCoupon?: InputMaybe<Scalars['String']>;
  created?: InputMaybe<Scalars['Datetime']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  ipAddress?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateReportById` mutation. */
export type UpdateReportByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Report` being updated. */
  reportPatch: ReportPatch;
  id: Scalars['Int'];
};

/** The output of our update `Return` mutation. */
export type UpdateReturnPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Return` that was updated by this mutation. */
  return?: Maybe<Return>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Return`. May be used by Relay 1. */
  returnEdge?: Maybe<ReturnsEdge>;
};


/** The output of our update `Return` mutation. */
export type UpdateReturnPayloadreturnEdgeArgs = {
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
};

/** All input for the `updateReturn` mutation. */
export type UpdateReturnInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Return` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Return` being updated. */
  returnPatch: ReturnPatch;
};

/** Represents an update to a `Return`. Fields that are set will be updated. */
export type ReturnPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  validity?: InputMaybe<Scalars['String']>;
  returnPrefix?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  shippingNumber?: InputMaybe<Scalars['String']>;
  shippingDescription?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  liquidationReason?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  weight?: InputMaybe<Scalars['String']>;
  height?: InputMaybe<Scalars['String']>;
  howShipped?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  shipTo?: InputMaybe<Scalars['String']>;
  caseId?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateReturnById` mutation. */
export type UpdateReturnByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Return` being updated. */
  returnPatch: ReturnPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Review` mutation. */
export type UpdateReviewPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was updated by this mutation. */
  review?: Maybe<Review>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our update `Review` mutation. */
export type UpdateReviewPayloadreviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the `updateReview` mutation. */
export type UpdateReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Review` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Review` being updated. */
  reviewPatch: ReviewPatch;
};

/** Represents an update to a `Review`. Fields that are set will be updated. */
export type ReviewPatch = {
  id?: InputMaybe<Scalars['Int']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  websites?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  shopId?: InputMaybe<Scalars['Int']>;
  commentId?: InputMaybe<Scalars['Int']>;
};

/** All input for the `updateReviewById` mutation. */
export type UpdateReviewByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Review` being updated. */
  reviewPatch: ReviewPatch;
  id: Scalars['Int'];
};

/** The output of our update `Reward` mutation. */
export type UpdateRewardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reward` that was updated by this mutation. */
  reward?: Maybe<Reward>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Reward`. May be used by Relay 1. */
  rewardEdge?: Maybe<RewardsEdge>;
};


/** The output of our update `Reward` mutation. */
export type UpdateRewardPayloadrewardEdgeArgs = {
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
};

/** All input for the `updateReward` mutation. */
export type UpdateRewardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Reward` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Reward` being updated. */
  rewardPatch: RewardPatch;
};

/** Represents an update to a `Reward`. Fields that are set will be updated. */
export type RewardPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  slug?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateRewardById` mutation. */
export type UpdateRewardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Reward` being updated. */
  rewardPatch: RewardPatch;
  id: Scalars['Int'];
};

/** The output of our update `Role` mutation. */
export type UpdateRolePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Role` that was updated by this mutation. */
  role?: Maybe<Role>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our update `Role` mutation. */
export type UpdateRolePayloadroleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the `updateRole` mutation. */
export type UpdateRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Role` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Role` being updated. */
  rolePatch: RolePatch;
};

/** Represents an update to a `Role`. Fields that are set will be updated. */
export type RolePatch = {
  id?: InputMaybe<Scalars['Int']>;
  roleName?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateRoleById` mutation. */
export type UpdateRoleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Role` being updated. */
  rolePatch: RolePatch;
  id: Scalars['Int'];
};

/** The output of our update `Scheduler` mutation. */
export type UpdateSchedulerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Scheduler` that was updated by this mutation. */
  scheduler?: Maybe<Scheduler>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
};


/** The output of our update `Scheduler` mutation. */
export type UpdateSchedulerPayloadschedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the `updateScheduler` mutation. */
export type UpdateSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Scheduler` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Scheduler` being updated. */
  schedulerPatch: SchedulerPatch;
};

/** Represents an update to a `Scheduler`. Fields that are set will be updated. */
export type SchedulerPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  endDate?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  login?: InputMaybe<Scalars['String']>;
  notes?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  whid?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSchedulerById` mutation. */
export type UpdateSchedulerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Scheduler` being updated. */
  schedulerPatch: SchedulerPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Segment` mutation. */
export type UpdateSegmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Segment` that was updated by this mutation. */
  segment?: Maybe<Segment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Segment`. May be used by Relay 1. */
  segmentEdge?: Maybe<SegmentsEdge>;
};


/** The output of our update `Segment` mutation. */
export type UpdateSegmentPayloadsegmentEdgeArgs = {
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
};

/** All input for the `updateSegment` mutation. */
export type UpdateSegmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Segment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Segment` being updated. */
  segmentPatch: SegmentPatch;
};

/** Represents an update to a `Segment`. Fields that are set will be updated. */
export type SegmentPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  applyTo?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSegmentById` mutation. */
export type UpdateSegmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Segment` being updated. */
  segmentPatch: SegmentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Setting` mutation. */
export type UpdateSettingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Setting` that was updated by this mutation. */
  setting?: Maybe<Setting>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our update `Setting` mutation. */
export type UpdateSettingPayloadsettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the `updateSetting` mutation. */
export type UpdateSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Setting` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Setting` being updated. */
  settingPatch: SettingPatch;
};

/** Represents an update to a `Setting`. Fields that are set will be updated. */
export type SettingPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  storeName?: InputMaybe<Scalars['String']>;
  storePhone?: InputMaybe<Scalars['String']>;
  storeHours?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  region?: InputMaybe<Scalars['String']>;
  zipcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  vatNumber?: InputMaybe<Scalars['String']>;
  allowState?: InputMaybe<Scalars['String']>;
  stateRequiredFor?: InputMaybe<Scalars['String']>;
  allowCountries?: InputMaybe<Scalars['String']>;
  defaultCountry?: InputMaybe<Scalars['String']>;
  optionalZip?: InputMaybe<Scalars['String']>;
  europeanUnionCountries?: InputMaybe<Scalars['String']>;
  topDestinations?: InputMaybe<Scalars['String']>;
  baseCurrency?: InputMaybe<Scalars['String']>;
  defaultCurrency?: InputMaybe<Scalars['String']>;
  allowedCurrency?: InputMaybe<Scalars['String']>;
  siteName?: InputMaybe<Scalars['String']>;
  siteWebsite?: InputMaybe<Scalars['String']>;
  sentryDsn?: InputMaybe<Scalars['String']>;
  awsS3?: InputMaybe<Scalars['String']>;
  databaseUrl?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  googleAnalytics?: InputMaybe<Scalars['String']>;
  searchSetting?: InputMaybe<Scalars['String']>;
  mailServer?: InputMaybe<Scalars['String']>;
  youtubeVideos?: InputMaybe<Scalars['String']>;
  siteTagline?: InputMaybe<Scalars['String']>;
  googleDrive?: InputMaybe<Scalars['String']>;
  disqusKey?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSettingById` mutation. */
export type UpdateSettingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Setting` being updated. */
  settingPatch: SettingPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Shipment` mutation. */
export type UpdateShipmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipment` that was updated by this mutation. */
  shipment?: Maybe<Shipment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Shipment`. May be used by Relay 1. */
  shipmentEdge?: Maybe<ShipmentsEdge>;
};


/** The output of our update `Shipment` mutation. */
export type UpdateShipmentPayloadshipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
};

/** All input for the `updateShipment` mutation. */
export type UpdateShipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Shipment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Shipment` being updated. */
  shipmentPatch: ShipmentPatch;
};

/** Represents an update to a `Shipment`. Fields that are set will be updated. */
export type ShipmentPatch = {
  product?: InputMaybe<Scalars['String']>;
  speedGrade?: InputMaybe<Scalars['String']>;
  shipDate?: InputMaybe<Scalars['Datetime']>;
  carrierName?: InputMaybe<Scalars['String']>;
  transitTime?: InputMaybe<Scalars['String']>;
  trackingUrl?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['BigInt']>;
  clientId?: InputMaybe<Scalars['String']>;
  clientSecret?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateShipmentById` mutation. */
export type UpdateShipmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Shipment` being updated. */
  shipmentPatch: ShipmentPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `SpecialDiscount` mutation. */
export type UpdateSpecialDiscountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpecialDiscount` that was updated by this mutation. */
  specialDiscount?: Maybe<SpecialDiscount>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SpecialDiscount`. May be used by Relay 1. */
  specialDiscountEdge?: Maybe<SpecialDiscountsEdge>;
};


/** The output of our update `SpecialDiscount` mutation. */
export type UpdateSpecialDiscountPayloadspecialDiscountEdgeArgs = {
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
};

/** All input for the `updateSpecialDiscount` mutation. */
export type UpdateSpecialDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpecialDiscount` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SpecialDiscount` being updated. */
  specialDiscountPatch: SpecialDiscountPatch;
};

/** Represents an update to a `SpecialDiscount`. Fields that are set will be updated. */
export type SpecialDiscountPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  discount?: InputMaybe<Scalars['BigFloat']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['Date']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSpecialDiscountById` mutation. */
export type UpdateSpecialDiscountByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SpecialDiscount` being updated. */
  specialDiscountPatch: SpecialDiscountPatch;
  id: Scalars['Int'];
};

/** The output of our update `State` mutation. */
export type UpdateStatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `State` that was updated by this mutation. */
  state?: Maybe<State>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `State`. May be used by Relay 1. */
  stateEdge?: Maybe<StatesEdge>;
};


/** The output of our update `State` mutation. */
export type UpdateStatePayloadstateEdgeArgs = {
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
};

/** All input for the `updateState` mutation. */
export type UpdateStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `State` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `State` being updated. */
  statePatch: StatePatch;
};

/** Represents an update to a `State`. Fields that are set will be updated. */
export type StatePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  trainings?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateStateById` mutation. */
export type UpdateStateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `State` being updated. */
  statePatch: StatePatch;
  id: Scalars['Int'];
};

/** The output of our update `Statistic` mutation. */
export type UpdateStatisticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Statistic` that was updated by this mutation. */
  statistic?: Maybe<Statistic>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Statistic`. May be used by Relay 1. */
  statisticEdge?: Maybe<StatisticsEdge>;
};


/** The output of our update `Statistic` mutation. */
export type UpdateStatisticPayloadstatisticEdgeArgs = {
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
};

/** All input for the `updateStatistic` mutation. */
export type UpdateStatisticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Statistic` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Statistic` being updated. */
  statisticPatch: StatisticPatch;
};

/** Represents an update to a `Statistic`. Fields that are set will be updated. */
export type StatisticPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  published?: InputMaybe<Scalars['Datetime']>;
  specialOffers?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  rewards?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  expiration?: InputMaybe<Scalars['Date']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateStatisticById` mutation. */
export type UpdateStatisticByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Statistic` being updated. */
  statisticPatch: StatisticPatch;
  id: Scalars['Int'];
};

/** The output of our update `Stock` mutation. */
export type UpdateStockPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Stock` that was updated by this mutation. */
  stock?: Maybe<Stock>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Stock`. May be used by Relay 1. */
  stockEdge?: Maybe<StocksEdge>;
};


/** The output of our update `Stock` mutation. */
export type UpdateStockPayloadstockEdgeArgs = {
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
};

/** All input for the `updateStock` mutation. */
export type UpdateStockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Stock` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Stock` being updated. */
  stockPatch: StockPatch;
};

/** Represents an update to a `Stock`. Fields that are set will be updated. */
export type StockPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  description?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  sources?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateStockById` mutation. */
export type UpdateStockByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Stock` being updated. */
  stockPatch: StockPatch;
  id: Scalars['Int'];
};

/** The output of our update `Survey` mutation. */
export type UpdateSurveyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Survey` that was updated by this mutation. */
  survey?: Maybe<Survey>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Survey`. May be used by Relay 1. */
  surveyEdge?: Maybe<SurveysEdge>;
};


/** The output of our update `Survey` mutation. */
export type UpdateSurveyPayloadsurveyEdgeArgs = {
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
};

/** All input for the `updateSurvey` mutation. */
export type UpdateSurveyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Survey` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Survey` being updated. */
  surveyPatch: SurveyPatch;
};

/** Represents an update to a `Survey`. Fields that are set will be updated. */
export type SurveyPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  question?: InputMaybe<Scalars['String']>;
  answer?: InputMaybe<Scalars['String']>;
  submitText?: InputMaybe<Scalars['String']>;
  satisfiedText?: InputMaybe<Scalars['String']>;
  neitherText?: InputMaybe<Scalars['String']>;
  dissatisfiedText?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateSurveyById` mutation. */
export type UpdateSurveyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Survey` being updated. */
  surveyPatch: SurveyPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Tag` mutation. */
export type UpdateTagPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Tag` that was updated by this mutation. */
  tag?: Maybe<Tag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our update `Tag` mutation. */
export type UpdateTagPayloadtagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the `updateTag` mutation. */
export type UpdateTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tag` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: TagPatch;
};

/** Represents an update to a `Tag`. Fields that are set will be updated. */
export type TagPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  excerpt?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTagById` mutation. */
export type UpdateTagByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Tag` being updated. */
  tagPatch: TagPatch;
  id: Scalars['Int'];
};

/** The output of our update `Target` mutation. */
export type UpdateTargetPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Target` that was updated by this mutation. */
  target?: Maybe<Target>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Target`. May be used by Relay 1. */
  targetEdge?: Maybe<TargetsEdge>;
};


/** The output of our update `Target` mutation. */
export type UpdateTargetPayloadtargetEdgeArgs = {
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
};

/** All input for the `updateTarget` mutation. */
export type UpdateTargetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Target` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Target` being updated. */
  targetPatch: TargetPatch;
};

/** Represents an update to a `Target`. Fields that are set will be updated. */
export type TargetPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  prefix?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  accountName?: InputMaybe<Scalars['String']>;
  address?: InputMaybe<Scalars['String']>;
  postalcode?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  fax?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  mobile?: InputMaybe<Scalars['String']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  altAddress?: InputMaybe<Scalars['String']>;
  altPostalcode?: InputMaybe<Scalars['String']>;
  altCity?: InputMaybe<Scalars['String']>;
  altState?: InputMaybe<Scalars['String']>;
  altCountry?: InputMaybe<Scalars['String']>;
  officePhone?: InputMaybe<Scalars['String']>;
  customerName?: InputMaybe<Scalars['String']>;
  emailOptOut?: InputMaybe<Scalars['String']>;
  donotcall?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTargetById` mutation. */
export type UpdateTargetByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Target` being updated. */
  targetPatch: TargetPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `TaxCategory` mutation. */
export type UpdateTaxCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxCategory` that was updated by this mutation. */
  taxCategory?: Maybe<TaxCategory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxCategory`. May be used by Relay 1. */
  taxCategoryEdge?: Maybe<TaxCategoriesEdge>;
};


/** The output of our update `TaxCategory` mutation. */
export type UpdateTaxCategoryPayloadtaxCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
};

/** All input for the `updateTaxCategory` mutation. */
export type UpdateTaxCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxCategory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TaxCategory` being updated. */
  taxCategoryPatch: TaxCategoryPatch;
};

/** Represents an update to a `TaxCategory`. Fields that are set will be updated. */
export type TaxCategoryPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  default?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTaxCategoryById` mutation. */
export type UpdateTaxCategoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TaxCategory` being updated. */
  taxCategoryPatch: TaxCategoryPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `TaxRate` mutation. */
export type UpdateTaxRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRate` that was updated by this mutation. */
  taxRate?: Maybe<TaxRate>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRate`. May be used by Relay 1. */
  taxRateEdge?: Maybe<TaxRatesEdge>;
};


/** The output of our update `TaxRate` mutation. */
export type UpdateTaxRatePayloadtaxRateEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
};

/** All input for the `updateTaxRate` mutation. */
export type UpdateTaxRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxRate` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TaxRate` being updated. */
  taxRatePatch: TaxRatePatch;
};

/** Represents an update to a `TaxRate`. Fields that are set will be updated. */
export type TaxRatePatch = {
  id?: InputMaybe<Scalars['Int']>;
  taxIdentifier?: InputMaybe<Scalars['String']>;
  zipPostIsRange?: InputMaybe<Scalars['Boolean']>;
  postcode?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  ratePercent?: InputMaybe<Scalars['String']>;
  defaultStoreView?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTaxRateById` mutation. */
export type UpdateTaxRateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TaxRate` being updated. */
  taxRatePatch: TaxRatePatch;
  id: Scalars['Int'];
};

/** The output of our update `TaxRule` mutation. */
export type UpdateTaxRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRule` that was updated by this mutation. */
  taxRule?: Maybe<TaxRule>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRule`. May be used by Relay 1. */
  taxRuleEdge?: Maybe<TaxRulesEdge>;
};


/** The output of our update `TaxRule` mutation. */
export type UpdateTaxRulePayloadtaxRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
};

/** All input for the `updateTaxRule` mutation. */
export type UpdateTaxRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxRule` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TaxRule` being updated. */
  taxRulePatch: TaxRulePatch;
};

/** Represents an update to a `TaxRule`. Fields that are set will be updated. */
export type TaxRulePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  taxRate?: InputMaybe<Scalars['String']>;
  prodId?: InputMaybe<Scalars['BigInt']>;
  products?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTaxRuleById` mutation. */
export type UpdateTaxRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TaxRule` being updated. */
  taxRulePatch: TaxRulePatch;
  id: Scalars['Int'];
};

/** The output of our update `Template` mutation. */
export type UpdateTemplatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was updated by this mutation. */
  template?: Maybe<Template>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our update `Template` mutation. */
export type UpdateTemplatePayloadtemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the `updateTemplate` mutation. */
export type UpdateTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Template` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  templatePatch: TemplatePatch;
};

/** Represents an update to a `Template`. Fields that are set will be updated. */
export type TemplatePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['String']>;
  pageSize?: InputMaybe<Scalars['String']>;
  orientation?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  header?: InputMaybe<Scalars['String']>;
  footer?: InputMaybe<Scalars['String']>;
  marginLeft?: InputMaybe<Scalars['String']>;
  marginRight?: InputMaybe<Scalars['String']>;
  marginTop?: InputMaybe<Scalars['String']>;
  marginBottom?: InputMaybe<Scalars['String']>;
  marginHeader?: InputMaybe<Scalars['String']>;
  marginFooter?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTemplateById` mutation. */
export type UpdateTemplateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Template` being updated. */
  templatePatch: TemplatePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Theme` mutation. */
export type UpdateThemePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Theme` that was updated by this mutation. */
  theme?: Maybe<Theme>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Theme`. May be used by Relay 1. */
  themeEdge?: Maybe<ThemesEdge>;
};


/** The output of our update `Theme` mutation. */
export type UpdateThemePayloadthemeEdgeArgs = {
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
};

/** All input for the `updateTheme` mutation. */
export type UpdateThemeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Theme` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Theme` being updated. */
  themePatch: ThemePatch;
};

/** Represents an update to a `Theme`. Fields that are set will be updated. */
export type ThemePatch = {
  id?: InputMaybe<Scalars['Int']>;
  title?: InputMaybe<Scalars['String']>;
  parentTheme?: InputMaybe<Scalars['String']>;
  themePath?: InputMaybe<Scalars['String']>;
  action?: InputMaybe<Scalars['String']>;
  websiteId?: InputMaybe<Scalars['BigInt']>;
  websites?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateThemeById` mutation. */
export type UpdateThemeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Theme` being updated. */
  themePatch: ThemePatch;
  id: Scalars['Int'];
};

/** The output of our update `Ticketing` mutation. */
export type UpdateTicketingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ticketing` that was updated by this mutation. */
  ticketing?: Maybe<Ticketing>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ticketing`. May be used by Relay 1. */
  ticketingEdge?: Maybe<TicketingsEdge>;
};


/** The output of our update `Ticketing` mutation. */
export type UpdateTicketingPayloadticketingEdgeArgs = {
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
};

/** All input for the `updateTicketing` mutation. */
export type UpdateTicketingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Ticketing` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Ticketing` being updated. */
  ticketingPatch: TicketingPatch;
};

/** Represents an update to a `Ticketing`. Fields that are set will be updated. */
export type TicketingPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  location?: InputMaybe<Scalars['String']>;
  date?: InputMaybe<Scalars['String']>;
  severity?: InputMaybe<Scalars['String']>;
  team?: InputMaybe<Scalars['String']>;
  requester?: InputMaybe<Scalars['String']>;
  requesterEmail?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  department?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  ticketType?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  priority?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  resolution?: InputMaybe<Scalars['String']>;
  assignedTo?: InputMaybe<Scalars['String']>;
  dateModified?: InputMaybe<Scalars['Datetime']>;
  accountName?: InputMaybe<Scalars['String']>;
  level?: InputMaybe<Scalars['String']>;
  projectsProjectsToticketing?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTicketingById` mutation. */
export type UpdateTicketingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Ticketing` being updated. */
  ticketingPatch: TicketingPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Training` mutation. */
export type UpdateTrainingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Training` that was updated by this mutation. */
  training?: Maybe<Training>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Training`. May be used by Relay 1. */
  trainingEdge?: Maybe<TrainingsEdge>;
};


/** The output of our update `Training` mutation. */
export type UpdateTrainingPayloadtrainingEdgeArgs = {
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
};

/** All input for the `updateTraining` mutation. */
export type UpdateTrainingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Training` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Training` being updated. */
  trainingPatch: TrainingPatch;
};

/** Represents an update to a `Training`. Fields that are set will be updated. */
export type TrainingPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  subject?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  link?: InputMaybe<Scalars['String']>;
  steps?: InputMaybe<Scalars['String']>;
  updated?: InputMaybe<Scalars['Datetime']>;
  analytics?: InputMaybe<Scalars['String']>;
  competency?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Scalars['String']>;
  grade?: InputMaybe<Scalars['String']>;
  school?: InputMaybe<Scalars['String']>;
  comment?: InputMaybe<Scalars['Int']>;
  address?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['Int']>;
  postal?: InputMaybe<Scalars['String']>;
  teacher?: InputMaybe<Scalars['String']>;
  student?: InputMaybe<Scalars['String']>;
  announcement?: InputMaybe<Scalars['String']>;
  resource?: InputMaybe<Scalars['String']>;
  badges?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
  isCompleted?: InputMaybe<Scalars['String']>;
  speakers?: InputMaybe<Scalars['String']>;
  fieldTrips?: InputMaybe<Scalars['String']>;
  assignments?: InputMaybe<Scalars['String']>;
  assignmentsDueDate?: InputMaybe<Scalars['String']>;
  origanalityReport?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['BigInt']>;
  faqs?: InputMaybe<Scalars['String']>;
  languages?: InputMaybe<Scalars['String']>;
  checklists?: InputMaybe<Scalars['BigInt']>;
  city?: InputMaybe<Scalars['String']>;
  meetups?: InputMaybe<Scalars['String']>;
  lab?: InputMaybe<Scalars['String']>;
  digiboards?: InputMaybe<Scalars['String']>;
  countries?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTrainingById` mutation. */
export type UpdateTrainingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Training` being updated. */
  trainingPatch: TrainingPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Transaction` mutation. */
export type UpdateTransactionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was updated by this mutation. */
  transaction?: Maybe<Transaction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our update `Transaction` mutation. */
export type UpdateTransactionPayloadtransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the `updateTransaction` mutation. */
export type UpdateTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Transaction` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Transaction` being updated. */
  transactionPatch: TransactionPatch;
};

/** Represents an update to a `Transaction`. Fields that are set will be updated. */
export type TransactionPatch = {
  id?: InputMaybe<Scalars['Int']>;
  orderId?: InputMaybe<Scalars['Int']>;
  transactionId?: InputMaybe<Scalars['Int']>;
  parentTransactionId?: InputMaybe<Scalars['Int']>;
  created?: InputMaybe<Scalars['Datetime']>;
  paymentMethod?: InputMaybe<Scalars['BigInt']>;
  closed?: InputMaybe<Scalars['String']>;
  customerPayment?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateTransactionById` mutation. */
export type UpdateTransactionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Transaction` being updated. */
  transactionPatch: TransactionPatch;
  id: Scalars['Int'];
};

/** The output of our update `UploadFile` mutation. */
export type UpdateUploadFilePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UploadFile` that was updated by this mutation. */
  uploadFile?: Maybe<UploadFile>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `UploadFile`. May be used by Relay 1. */
  uploadFileEdge?: Maybe<UploadFilesEdge>;
};


/** The output of our update `UploadFile` mutation. */
export type UpdateUploadFilePayloaduploadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
};

/** All input for the `updateUploadFile` mutation. */
export type UpdateUploadFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UploadFile` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UploadFile` being updated. */
  uploadFilePatch: UploadFilePatch;
};

/** Represents an update to a `UploadFile`. Fields that are set will be updated. */
export type UploadFilePatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  alternativeText?: InputMaybe<Scalars['String']>;
  caption?: InputMaybe<Scalars['String']>;
  width?: InputMaybe<Scalars['Int']>;
  height?: InputMaybe<Scalars['Int']>;
  formats?: InputMaybe<Scalars['JSON']>;
  hash?: InputMaybe<Scalars['String']>;
  ext?: InputMaybe<Scalars['String']>;
  mime?: InputMaybe<Scalars['String']>;
  size?: InputMaybe<Scalars['BigFloat']>;
  url?: InputMaybe<Scalars['String']>;
  previewUrl?: InputMaybe<Scalars['String']>;
  provider?: InputMaybe<Scalars['String']>;
  providerMetadata?: InputMaybe<Scalars['JSON']>;
  createdBy?: InputMaybe<Scalars['Int']>;
  updatedBy?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
};

/** All input for the `updateUploadFileById` mutation. */
export type UpdateUploadFileByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UploadFile` being updated. */
  uploadFilePatch: UploadFilePatch;
  id: Scalars['Int'];
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloaduserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch;
};

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  username?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  email?: InputMaybe<Scalars['String']>;
  password?: InputMaybe<Scalars['String']>;
  interfaceLocale?: InputMaybe<Scalars['String']>;
  value?: InputMaybe<Scalars['String']>;
  permissions?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  emails?: InputMaybe<Scalars['String']>;
  mediamanager?: InputMaybe<Scalars['String']>;
  messages?: InputMaybe<Scalars['String']>;
  projects?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateUserById` mutation. */
export type UpdateUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  userPatch: UserPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Vendor` mutation. */
export type UpdateVendorPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was updated by this mutation. */
  vendor?: Maybe<Vendor>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our update `Vendor` mutation. */
export type UpdateVendorPayloadvendorEdgeArgs = {
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
};

/** All input for the `updateVendor` mutation. */
export type UpdateVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vendor` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Vendor` being updated. */
  vendorPatch: VendorPatch;
};

/** Represents an update to a `Vendor`. Fields that are set will be updated. */
export type VendorPatch = {
  id?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  website?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  articles?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  comments?: InputMaybe<Scalars['String']>;
  coupons?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  polls?: InputMaybe<Scalars['String']>;
  quotes?: InputMaybe<Scalars['String']>;
  reviews?: InputMaybe<Scalars['String']>;
  giftCertificates?: InputMaybe<Scalars['String']>;
  rating?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  users?: InputMaybe<Scalars['String']>;
  invoices?: InputMaybe<Scalars['String']>;
  reports?: InputMaybe<Scalars['String']>;
  rewardPoints?: InputMaybe<Scalars['String']>;
  specialDiscounts?: InputMaybe<Scalars['String']>;
  statistics?: InputMaybe<Scalars['String']>;
  stocks?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  physicalStore?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  workspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateVendorById` mutation. */
export type UpdateVendorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Vendor` being updated. */
  vendorPatch: VendorPatch;
  id: Scalars['Int'];
};

/** The output of our update `Visit` mutation. */
export type UpdateVisitPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Visit` that was updated by this mutation. */
  visit?: Maybe<Visit>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Visit`. May be used by Relay 1. */
  visitEdge?: Maybe<VisitsEdge>;
};


/** The output of our update `Visit` mutation. */
export type UpdateVisitPayloadvisitEdgeArgs = {
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
};

/** All input for the `updateVisit` mutation. */
export type UpdateVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Visit` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Visit` being updated. */
  visitPatch: VisitPatch;
};

/** Represents an update to a `Visit`. Fields that are set will be updated. */
export type VisitPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  location?: InputMaybe<Scalars['String']>;
  username?: InputMaybe<Scalars['String']>;
  reason?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Scalars['String']>;
  emergency?: InputMaybe<Scalars['String']>;
  startDate?: InputMaybe<Scalars['String']>;
  endDate?: InputMaybe<Scalars['String']>;
  task?: InputMaybe<Scalars['String']>;
  meeting?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateVisitById` mutation. */
export type UpdateVisitByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Visit` being updated. */
  visitPatch: VisitPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Warehouse` mutation. */
export type UpdateWarehousePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was updated by this mutation. */
  warehouse?: Maybe<Warehouse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our update `Warehouse` mutation. */
export type UpdateWarehousePayloadwarehouseEdgeArgs = {
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
};

/** All input for the `updateWarehouse` mutation. */
export type UpdateWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Warehouse` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Warehouse` being updated. */
  warehousePatch: WarehousePatch;
};

/** Represents an update to a `Warehouse`. Fields that are set will be updated. */
export type WarehousePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  postal?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Scalars['String']>;
  image?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  isPublic?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWarehouseById` mutation. */
export type UpdateWarehouseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Warehouse` being updated. */
  warehousePatch: WarehousePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Webhook` mutation. */
export type UpdateWebhookPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Webhook` that was updated by this mutation. */
  webhook?: Maybe<Webhook>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Webhook`. May be used by Relay 1. */
  webhookEdge?: Maybe<WebhooksEdge>;
};


/** The output of our update `Webhook` mutation. */
export type UpdateWebhookPayloadwebhookEdgeArgs = {
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
};

/** All input for the `updateWebhook` mutation. */
export type UpdateWebhookInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Webhook` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Webhook` being updated. */
  webhookPatch: WebhookPatch;
};

/** Represents an update to a `Webhook`. Fields that are set will be updated. */
export type WebhookPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  headers?: InputMaybe<Scalars['String']>;
  create?: InputMaybe<Scalars['String']>;
  retrieve?: InputMaybe<Scalars['String']>;
  update?: InputMaybe<Scalars['String']>;
  delete?: InputMaybe<Scalars['String']>;
  publish?: InputMaybe<Scalars['String']>;
  unpublish?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWebhookById` mutation. */
export type UpdateWebhookByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Webhook` being updated. */
  webhookPatch: WebhookPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Website` mutation. */
export type UpdateWebsitePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Website` that was updated by this mutation. */
  website?: Maybe<Website>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Website`. May be used by Relay 1. */
  websiteEdge?: Maybe<WebsitesEdge>;
};


/** The output of our update `Website` mutation. */
export type UpdateWebsitePayloadwebsiteEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
};

/** All input for the `updateWebsite` mutation. */
export type UpdateWebsiteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Website` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Website` being updated. */
  websitePatch: WebsitePatch;
};

/** Represents an update to a `Website`. Fields that are set will be updated. */
export type WebsitePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  url?: InputMaybe<Scalars['String']>;
  shop?: InputMaybe<Scalars['String']>;
  store?: InputMaybe<Scalars['String']>;
  category?: InputMaybe<Scalars['String']>;
  themes?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWebsiteById` mutation. */
export type UpdateWebsiteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Website` being updated. */
  websitePatch: WebsitePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Wishlist` mutation. */
export type UpdateWishlistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Wishlist` that was updated by this mutation. */
  wishlist?: Maybe<Wishlist>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Wishlist`. May be used by Relay 1. */
  wishlistEdge?: Maybe<WishlistsEdge>;
};


/** The output of our update `Wishlist` mutation. */
export type UpdateWishlistPayloadwishlistEdgeArgs = {
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
};

/** All input for the `updateWishlist` mutation. */
export type UpdateWishlistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Wishlist` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Wishlist` being updated. */
  wishlistPatch: WishlistPatch;
};

/** Represents an update to a `Wishlist`. Fields that are set will be updated. */
export type WishlistPatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Scalars['String']>;
  products?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['String']>;
  occassions?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWishlistById` mutation. */
export type UpdateWishlistByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Wishlist` being updated. */
  wishlistPatch: WishlistPatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Workspace` mutation. */
export type UpdateWorkspacePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Workspace` that was updated by this mutation. */
  workspace?: Maybe<Workspace>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Workspace`. May be used by Relay 1. */
  workspaceEdge?: Maybe<WorkspacesEdge>;
};


/** The output of our update `Workspace` mutation. */
export type UpdateWorkspacePayloadworkspaceEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
};

/** All input for the `updateWorkspace` mutation. */
export type UpdateWorkspaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Workspace` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Workspace` being updated. */
  workspacePatch: WorkspacePatch;
};

/** Represents an update to a `Workspace`. Fields that are set will be updated. */
export type WorkspacePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  code?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  description?: InputMaybe<Scalars['String']>;
  customers?: InputMaybe<Scalars['Int']>;
  users?: InputMaybe<Scalars['Int']>;
  products?: InputMaybe<Scalars['BigInt']>;
  tasks?: InputMaybe<Scalars['BigInt']>;
  brands?: InputMaybe<Scalars['BigInt']>;
  shops?: InputMaybe<Scalars['Int']>;
  category?: InputMaybe<Scalars['Int']>;
  isPublic?: InputMaybe<Scalars['Boolean']>;
  projects?: InputMaybe<Scalars['BigInt']>;
  author?: InputMaybe<Scalars['String']>;
  media?: InputMaybe<Scalars['String']>;
  brandsBrandsToworkspaces?: InputMaybe<Scalars['String']>;
  categories?: InputMaybe<Scalars['String']>;
  customersCustomersToworkspaces?: InputMaybe<Scalars['String']>;
  productsProductsToworkspaces?: InputMaybe<Scalars['String']>;
  projectsProjectsToworkspaces?: InputMaybe<Scalars['String']>;
  shopsShopsToworkspaces?: InputMaybe<Scalars['String']>;
  tasksTasksToworkspaces?: InputMaybe<Scalars['String']>;
  usersUsersToworkspaces?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateWorkspaceById` mutation. */
export type UpdateWorkspaceByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Workspace` being updated. */
  workspacePatch: WorkspacePatch;
  id: Scalars['BigInt'];
};

/** The output of our update `Zone` mutation. */
export type UpdateZonePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Zone` that was updated by this mutation. */
  zone?: Maybe<Zone>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Zone`. May be used by Relay 1. */
  zoneEdge?: Maybe<ZonesEdge>;
};


/** The output of our update `Zone` mutation. */
export type UpdateZonePayloadzoneEdgeArgs = {
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
};

/** All input for the `updateZone` mutation. */
export type UpdateZoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Zone` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Zone` being updated. */
  zonePatch: ZonePatch;
};

/** Represents an update to a `Zone`. Fields that are set will be updated. */
export type ZonePatch = {
  id?: InputMaybe<Scalars['BigInt']>;
  createdAt?: InputMaybe<Scalars['Datetime']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['Datetime']>;
  scope?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Scalars['String']>;
  country?: InputMaybe<Scalars['String']>;
  code?: InputMaybe<Scalars['String']>;
};

/** All input for the `updateZoneById` mutation. */
export type UpdateZoneByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Zone` being updated. */
  zonePatch: ZonePatch;
  id: Scalars['BigInt'];
};

/** The output of our delete `Account` mutation. */
export type DeleteAccountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Account` that was deleted by this mutation. */
  account?: Maybe<Account>;
  deletedAccountId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Account`. May be used by Relay 1. */
  accountEdge?: Maybe<AccountsEdge>;
};


/** The output of our delete `Account` mutation. */
export type DeleteAccountPayloadaccountEdgeArgs = {
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
};

/** All input for the `deleteAccount` mutation. */
export type DeleteAccountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Account` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAccountById` mutation. */
export type DeleteAccountByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Agreement` mutation. */
export type DeleteAgreementPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Agreement` that was deleted by this mutation. */
  agreement?: Maybe<Agreement>;
  deletedAgreementId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Agreement`. May be used by Relay 1. */
  agreementEdge?: Maybe<AgreementsEdge>;
};


/** The output of our delete `Agreement` mutation. */
export type DeleteAgreementPayloadagreementEdgeArgs = {
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
};

/** All input for the `deleteAgreement` mutation. */
export type DeleteAgreementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Agreement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAgreementById` mutation. */
export type DeleteAgreementByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Analytic` mutation. */
export type DeleteAnalyticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Analytic` that was deleted by this mutation. */
  analytic?: Maybe<Analytic>;
  deletedAnalyticId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Analytic`. May be used by Relay 1. */
  analyticEdge?: Maybe<AnalyticsEdge>;
};


/** The output of our delete `Analytic` mutation. */
export type DeleteAnalyticPayloadanalyticEdgeArgs = {
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
};

/** All input for the `deleteAnalytic` mutation. */
export type DeleteAnalyticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Analytic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAnalyticById` mutation. */
export type DeleteAnalyticByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Apitoken` mutation. */
export type DeleteApitokenPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Apitoken` that was deleted by this mutation. */
  apitoken?: Maybe<Apitoken>;
  deletedApitokenId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Apitoken`. May be used by Relay 1. */
  apitokenEdge?: Maybe<ApitokensEdge>;
};


/** The output of our delete `Apitoken` mutation. */
export type DeleteApitokenPayloadapitokenEdgeArgs = {
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
};

/** All input for the `deleteApitoken` mutation. */
export type DeleteApitokenInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Apitoken` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteApitokenById` mutation. */
export type DeleteApitokenByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Article` mutation. */
export type DeleteArticlePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Article` that was deleted by this mutation. */
  article?: Maybe<Article>;
  deletedArticleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Article`. May be used by Relay 1. */
  articleEdge?: Maybe<ArticlesEdge>;
};


/** The output of our delete `Article` mutation. */
export type DeleteArticlePayloadarticleEdgeArgs = {
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
};

/** All input for the `deleteArticle` mutation. */
export type DeleteArticleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Article` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteArticleById` mutation. */
export type DeleteArticleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Attribute` mutation. */
export type DeleteAttributePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Attribute` that was deleted by this mutation. */
  attribute?: Maybe<Attribute>;
  deletedAttributeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Attribute`. May be used by Relay 1. */
  attributeEdge?: Maybe<AttributesEdge>;
};


/** The output of our delete `Attribute` mutation. */
export type DeleteAttributePayloadattributeEdgeArgs = {
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
};

/** All input for the `deleteAttribute` mutation. */
export type DeleteAttributeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Attribute` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAttributeById` mutation. */
export type DeleteAttributeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Brand` mutation. */
export type DeleteBrandPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Brand` that was deleted by this mutation. */
  brand?: Maybe<Brand>;
  deletedBrandId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Brand`. May be used by Relay 1. */
  brandEdge?: Maybe<BrandsEdge>;
};


/** The output of our delete `Brand` mutation. */
export type DeleteBrandPayloadbrandEdgeArgs = {
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
};

/** All input for the `deleteBrand` mutation. */
export type DeleteBrandInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Brand` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteBrandById` mutation. */
export type DeleteBrandByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CartPriceRule` mutation. */
export type DeleteCartPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CartPriceRule` that was deleted by this mutation. */
  cartPriceRule?: Maybe<CartPriceRule>;
  deletedCartPriceRuleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CartPriceRule`. May be used by Relay 1. */
  cartPriceRuleEdge?: Maybe<CartPriceRulesEdge>;
};


/** The output of our delete `CartPriceRule` mutation. */
export type DeleteCartPriceRulePayloadcartPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
};

/** All input for the `deleteCartPriceRule` mutation. */
export type DeleteCartPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CartPriceRule` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCartPriceRuleById` mutation. */
export type DeleteCartPriceRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Case` mutation. */
export type DeleteCasePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Case` that was deleted by this mutation. */
  case?: Maybe<Case>;
  deletedCaseId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Case`. May be used by Relay 1. */
  caseEdge?: Maybe<CasesEdge>;
};


/** The output of our delete `Case` mutation. */
export type DeleteCasePayloadcaseEdgeArgs = {
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
};

/** All input for the `deleteCase` mutation. */
export type DeleteCaseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Case` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCaseById` mutation. */
export type DeleteCaseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CatalogPriceRule` mutation. */
export type DeleteCatalogPriceRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CatalogPriceRule` that was deleted by this mutation. */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  deletedCatalogPriceRuleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CatalogPriceRule`. May be used by Relay 1. */
  catalogPriceRuleEdge?: Maybe<CatalogPriceRulesEdge>;
};


/** The output of our delete `CatalogPriceRule` mutation. */
export type DeleteCatalogPriceRulePayloadcatalogPriceRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
};

/** All input for the `deleteCatalogPriceRule` mutation. */
export type DeleteCatalogPriceRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CatalogPriceRule` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCatalogPriceRuleById` mutation. */
export type DeleteCatalogPriceRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Category` mutation. */
export type DeleteCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Category` that was deleted by this mutation. */
  category?: Maybe<Category>;
  deletedCategoryId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Category`. May be used by Relay 1. */
  categoryEdge?: Maybe<CategoriesEdge>;
};


/** The output of our delete `Category` mutation. */
export type DeleteCategoryPayloadcategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
};

/** All input for the `deleteCategory` mutation. */
export type DeleteCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Category` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCategoryById` mutation. */
export type DeleteCategoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Channel` mutation. */
export type DeleteChannelPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Channel` that was deleted by this mutation. */
  channel?: Maybe<Channel>;
  deletedChannelId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Channel`. May be used by Relay 1. */
  channelEdge?: Maybe<ChannelsEdge>;
};


/** The output of our delete `Channel` mutation. */
export type DeleteChannelPayloadchannelEdgeArgs = {
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
};

/** All input for the `deleteChannel` mutation. */
export type DeleteChannelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Channel` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChannelById` mutation. */
export type DeleteChannelByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Checklist` mutation. */
export type DeleteChecklistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Checklist` that was deleted by this mutation. */
  checklist?: Maybe<Checklist>;
  deletedChecklistId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Checklist`. May be used by Relay 1. */
  checklistEdge?: Maybe<ChecklistsEdge>;
};


/** The output of our delete `Checklist` mutation. */
export type DeleteChecklistPayloadchecklistEdgeArgs = {
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
};

/** All input for the `deleteChecklist` mutation. */
export type DeleteChecklistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Checklist` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteChecklistById` mutation. */
export type DeleteChecklistByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `City` mutation. */
export type DeleteCityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `City` that was deleted by this mutation. */
  city?: Maybe<City>;
  deletedCityId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `City`. May be used by Relay 1. */
  cityEdge?: Maybe<CitiesEdge>;
};


/** The output of our delete `City` mutation. */
export type DeleteCityPayloadcityEdgeArgs = {
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
};

/** All input for the `deleteCity` mutation. */
export type DeleteCityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `City` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCityById` mutation. */
export type DeleteCityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Collection` mutation. */
export type DeleteCollectionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Collection` that was deleted by this mutation. */
  collection?: Maybe<Collection>;
  deletedCollectionId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Collection`. May be used by Relay 1. */
  collectionEdge?: Maybe<CollectionsEdge>;
};


/** The output of our delete `Collection` mutation. */
export type DeleteCollectionPayloadcollectionEdgeArgs = {
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
};

/** All input for the `deleteCollection` mutation. */
export type DeleteCollectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Collection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCollectionById` mutation. */
export type DeleteCollectionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Comment` mutation. */
export type DeleteCommentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Comment` that was deleted by this mutation. */
  comment?: Maybe<Comment>;
  deletedCommentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Comment`. May be used by Relay 1. */
  commentEdge?: Maybe<CommentsEdge>;
};


/** The output of our delete `Comment` mutation. */
export type DeleteCommentPayloadcommentEdgeArgs = {
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
};

/** All input for the `deleteComment` mutation. */
export type DeleteCommentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Comment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCommentById` mutation. */
export type DeleteCommentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ContentType` mutation. */
export type DeleteContentTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ContentType` that was deleted by this mutation. */
  contentType?: Maybe<ContentType>;
  deletedContentTypeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ContentType`. May be used by Relay 1. */
  contentTypeEdge?: Maybe<ContentTypesEdge>;
};


/** The output of our delete `ContentType` mutation. */
export type DeleteContentTypePayloadcontentTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
};

/** All input for the `deleteContentType` mutation. */
export type DeleteContentTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ContentType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContentTypeById` mutation. */
export type DeleteContentTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Contract` mutation. */
export type DeleteContractPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Contract` that was deleted by this mutation. */
  contract?: Maybe<Contract>;
  deletedContractId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Contract`. May be used by Relay 1. */
  contractEdge?: Maybe<ContractsEdge>;
};


/** The output of our delete `Contract` mutation. */
export type DeleteContractPayloadcontractEdgeArgs = {
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
};

/** All input for the `deleteContract` mutation. */
export type DeleteContractInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Contract` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteContractById` mutation. */
export type DeleteContractByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Country` mutation. */
export type DeleteCountryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Country` that was deleted by this mutation. */
  country?: Maybe<Country>;
  deletedCountryId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Country`. May be used by Relay 1. */
  countryEdge?: Maybe<CountriesEdge>;
};


/** The output of our delete `Country` mutation. */
export type DeleteCountryPayloadcountryEdgeArgs = {
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
};

/** All input for the `deleteCountry` mutation. */
export type DeleteCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Country` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCountryById` mutation. */
export type DeleteCountryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Coupon` mutation. */
export type DeleteCouponPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Coupon` that was deleted by this mutation. */
  coupon?: Maybe<Coupon>;
  deletedCouponId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Coupon`. May be used by Relay 1. */
  couponEdge?: Maybe<CouponsEdge>;
};


/** The output of our delete `Coupon` mutation. */
export type DeleteCouponPayloadcouponEdgeArgs = {
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
};

/** All input for the `deleteCoupon` mutation. */
export type DeleteCouponInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Coupon` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCouponById` mutation. */
export type DeleteCouponByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CreditMemo` mutation. */
export type DeleteCreditMemoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CreditMemo` that was deleted by this mutation. */
  creditMemo?: Maybe<CreditMemo>;
  deletedCreditMemoId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CreditMemo`. May be used by Relay 1. */
  creditMemoEdge?: Maybe<CreditMemosEdge>;
};


/** The output of our delete `CreditMemo` mutation. */
export type DeleteCreditMemoPayloadcreditMemoEdgeArgs = {
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
};

/** All input for the `deleteCreditMemo` mutation. */
export type DeleteCreditMemoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CreditMemo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCreditMemoByCreditMemoAndId` mutation. */
export type DeleteCreditMemoByCreditMemoAndIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  creditMemo: Scalars['String'];
  id: Scalars['BigInt'];
};

/** The output of our delete `Currency` mutation. */
export type DeleteCurrencyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Currency` that was deleted by this mutation. */
  currency?: Maybe<Currency>;
  deletedCurrencyId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Currency`. May be used by Relay 1. */
  currencyEdge?: Maybe<CurrenciesEdge>;
};


/** The output of our delete `Currency` mutation. */
export type DeleteCurrencyPayloadcurrencyEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
};

/** All input for the `deleteCurrency` mutation. */
export type DeleteCurrencyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Currency` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCurrencyById` mutation. */
export type DeleteCurrencyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `CurrencyRate` mutation. */
export type DeleteCurrencyRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencyRate` that was deleted by this mutation. */
  currencyRate?: Maybe<CurrencyRate>;
  deletedCurrencyRateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencyRate`. May be used by Relay 1. */
  currencyRateEdge?: Maybe<CurrencyRatesEdge>;
};


/** The output of our delete `CurrencyRate` mutation. */
export type DeleteCurrencyRatePayloadcurrencyRateEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
};

/** All input for the `deleteCurrencyRate` mutation. */
export type DeleteCurrencyRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CurrencyRate` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCurrencyRateByImportService` mutation. */
export type DeleteCurrencyRateByImportServiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  importService: Scalars['String'];
};

/** The output of our delete `CurrencySymbol` mutation. */
export type DeleteCurrencySymbolPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CurrencySymbol` that was deleted by this mutation. */
  currencySymbol?: Maybe<CurrencySymbol>;
  deletedCurrencySymbolId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CurrencySymbol`. May be used by Relay 1. */
  currencySymbolEdge?: Maybe<CurrencySymbolsEdge>;
};


/** The output of our delete `CurrencySymbol` mutation. */
export type DeleteCurrencySymbolPayloadcurrencySymbolEdgeArgs = {
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
};

/** All input for the `deleteCurrencySymbol` mutation. */
export type DeleteCurrencySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CurrencySymbol` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCurrencySymbolBySymbol` mutation. */
export type DeleteCurrencySymbolBySymbolInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  symbol: Scalars['String'];
};

/** The output of our delete `CustomerGroup` mutation. */
export type DeleteCustomerGroupPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `CustomerGroup` that was deleted by this mutation. */
  customerGroup?: Maybe<CustomerGroup>;
  deletedCustomerGroupId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `CustomerGroup`. May be used by Relay 1. */
  customerGroupEdge?: Maybe<CustomerGroupsEdge>;
};


/** The output of our delete `CustomerGroup` mutation. */
export type DeleteCustomerGroupPayloadcustomerGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
};

/** All input for the `deleteCustomerGroup` mutation. */
export type DeleteCustomerGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `CustomerGroup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerGroupById` mutation. */
export type DeleteCustomerGroupByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customer` that was deleted by this mutation. */
  customer?: Maybe<Customer>;
  deletedCustomerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customer`. May be used by Relay 1. */
  customerEdge?: Maybe<CustomersEdge>;
};


/** The output of our delete `Customer` mutation. */
export type DeleteCustomerPayloadcustomerEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
};

/** All input for the `deleteCustomer` mutation. */
export type DeleteCustomerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomerById` mutation. */
export type DeleteCustomerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Customization` mutation. */
export type DeleteCustomizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Customization` that was deleted by this mutation. */
  customization?: Maybe<Customization>;
  deletedCustomizationId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Customization`. May be used by Relay 1. */
  customizationEdge?: Maybe<CustomizationsEdge>;
};


/** The output of our delete `Customization` mutation. */
export type DeleteCustomizationPayloadcustomizationEdgeArgs = {
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
};

/** All input for the `deleteCustomization` mutation. */
export type DeleteCustomizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Customization` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteCustomizationById` mutation. */
export type DeleteCustomizationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Dashboard` mutation. */
export type DeleteDashboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Dashboard` that was deleted by this mutation. */
  dashboard?: Maybe<Dashboard>;
  deletedDashboardId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Dashboard`. May be used by Relay 1. */
  dashboardEdge?: Maybe<DashboardsEdge>;
};


/** The output of our delete `Dashboard` mutation. */
export type DeleteDashboardPayloaddashboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
};

/** All input for the `deleteDashboard` mutation. */
export type DeleteDashboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Dashboard` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDashboardById` mutation. */
export type DeleteDashboardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Deepdive` mutation. */
export type DeleteDeepdivePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Deepdive` that was deleted by this mutation. */
  deepdive?: Maybe<Deepdive>;
  deletedDeepdiveId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Deepdive`. May be used by Relay 1. */
  deepdiveEdge?: Maybe<DeepdivesEdge>;
};


/** The output of our delete `Deepdive` mutation. */
export type DeleteDeepdivePayloaddeepdiveEdgeArgs = {
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
};

/** All input for the `deleteDeepdive` mutation. */
export type DeleteDeepdiveInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Deepdive` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDeepdiveById` mutation. */
export type DeleteDeepdiveByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Digiboard` mutation. */
export type DeleteDigiboardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Digiboard` that was deleted by this mutation. */
  digiboard?: Maybe<Digiboard>;
  deletedDigiboardId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Digiboard`. May be used by Relay 1. */
  digiboardEdge?: Maybe<DigiboardsEdge>;
};


/** The output of our delete `Digiboard` mutation. */
export type DeleteDigiboardPayloaddigiboardEdgeArgs = {
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
};

/** All input for the `deleteDigiboard` mutation. */
export type DeleteDigiboardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Digiboard` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteDigiboardById` mutation. */
export type DeleteDigiboardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Email` mutation. */
export type DeleteEmailPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Email` that was deleted by this mutation. */
  email?: Maybe<Email>;
  deletedEmailId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Email`. May be used by Relay 1. */
  emailEdge?: Maybe<EmailsEdge>;
};


/** The output of our delete `Email` mutation. */
export type DeleteEmailPayloademailEdgeArgs = {
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
};

/** All input for the `deleteEmail` mutation. */
export type DeleteEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Email` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEmailById` mutation. */
export type DeleteEmailByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Endofshift` mutation. */
export type DeleteEndofshiftPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Endofshift` that was deleted by this mutation. */
  endofshift?: Maybe<Endofshift>;
  deletedEndofshiftId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Endofshift`. May be used by Relay 1. */
  endofshiftEdge?: Maybe<EndofshiftsEdge>;
};


/** The output of our delete `Endofshift` mutation. */
export type DeleteEndofshiftPayloadendofshiftEdgeArgs = {
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
};

/** All input for the `deleteEndofshift` mutation. */
export type DeleteEndofshiftInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Endofshift` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEndofshiftById` mutation. */
export type DeleteEndofshiftByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Event` mutation. */
export type DeleteEventPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Event` that was deleted by this mutation. */
  event?: Maybe<Event>;
  deletedEventId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Event`. May be used by Relay 1. */
  eventEdge?: Maybe<EventsEdge>;
};


/** The output of our delete `Event` mutation. */
export type DeleteEventPayloadeventEdgeArgs = {
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
};

/** All input for the `deleteEvent` mutation. */
export type DeleteEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Event` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEventById` mutation. */
export type DeleteEventByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Fullfillment` mutation. */
export type DeleteFullfillmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Fullfillment` that was deleted by this mutation. */
  fullfillment?: Maybe<Fullfillment>;
  deletedFullfillmentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Fullfillment`. May be used by Relay 1. */
  fullfillmentEdge?: Maybe<FullfillmentsEdge>;
};


/** The output of our delete `Fullfillment` mutation. */
export type DeleteFullfillmentPayloadfullfillmentEdgeArgs = {
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
};

/** All input for the `deleteFullfillment` mutation. */
export type DeleteFullfillmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Fullfillment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFullfillmentById` mutation. */
export type DeleteFullfillmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `GiftCertificate` mutation. */
export type DeleteGiftCertificatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GiftCertificate` that was deleted by this mutation. */
  giftCertificate?: Maybe<GiftCertificate>;
  deletedGiftCertificateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `GiftCertificate`. May be used by Relay 1. */
  giftCertificateEdge?: Maybe<GiftCertificatesEdge>;
};


/** The output of our delete `GiftCertificate` mutation. */
export type DeleteGiftCertificatePayloadgiftCertificateEdgeArgs = {
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
};

/** All input for the `deleteGiftCertificate` mutation. */
export type DeleteGiftCertificateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GiftCertificate` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGiftCertificateById` mutation. */
export type DeleteGiftCertificateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Glossary` mutation. */
export type DeleteGlossaryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Glossary` that was deleted by this mutation. */
  glossary?: Maybe<Glossary>;
  deletedGlossaryId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Glossary`. May be used by Relay 1. */
  glossaryEdge?: Maybe<GlossariesEdge>;
};


/** The output of our delete `Glossary` mutation. */
export type DeleteGlossaryPayloadglossaryEdgeArgs = {
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
};

/** All input for the `deleteGlossary` mutation. */
export type DeleteGlossaryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Glossary` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGlossaryById` mutation. */
export type DeleteGlossaryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Importm` mutation. */
export type DeleteImportmPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Importm` that was deleted by this mutation. */
  importm?: Maybe<Importm>;
  deletedImportmId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Importm`. May be used by Relay 1. */
  importmEdge?: Maybe<ImportmsEdge>;
};


/** The output of our delete `Importm` mutation. */
export type DeleteImportmPayloadimportmEdgeArgs = {
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
};

/** All input for the `deleteImportm` mutation. */
export type DeleteImportmInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Importm` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteImportmById` mutation. */
export type DeleteImportmByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Integration` mutation. */
export type DeleteIntegrationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Integration` that was deleted by this mutation. */
  integration?: Maybe<Integration>;
  deletedIntegrationId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Integration`. May be used by Relay 1. */
  integrationEdge?: Maybe<IntegrationsEdge>;
};


/** The output of our delete `Integration` mutation. */
export type DeleteIntegrationPayloadintegrationEdgeArgs = {
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
};

/** All input for the `deleteIntegration` mutation. */
export type DeleteIntegrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Integration` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteIntegrationById` mutation. */
export type DeleteIntegrationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Internalization` mutation. */
export type DeleteInternalizationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Internalization` that was deleted by this mutation. */
  internalization?: Maybe<Internalization>;
  deletedInternalizationId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Internalization`. May be used by Relay 1. */
  internalizationEdge?: Maybe<InternalizationsEdge>;
};


/** The output of our delete `Internalization` mutation. */
export type DeleteInternalizationPayloadinternalizationEdgeArgs = {
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
};

/** All input for the `deleteInternalization` mutation. */
export type DeleteInternalizationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Internalization` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInternalizationById` mutation. */
export type DeleteInternalizationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Invitation` mutation. */
export type DeleteInvitationPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invitation` that was deleted by this mutation. */
  invitation?: Maybe<Invitation>;
  deletedInvitationId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invitation`. May be used by Relay 1. */
  invitationEdge?: Maybe<InvitationsEdge>;
};


/** The output of our delete `Invitation` mutation. */
export type DeleteInvitationPayloadinvitationEdgeArgs = {
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
};

/** All input for the `deleteInvitation` mutation. */
export type DeleteInvitationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invitation` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInvitationById` mutation. */
export type DeleteInvitationByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Invoice` mutation. */
export type DeleteInvoicePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Invoice` that was deleted by this mutation. */
  invoice?: Maybe<Invoice>;
  deletedInvoiceId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Invoice`. May be used by Relay 1. */
  invoiceEdge?: Maybe<InvoicesEdge>;
};


/** The output of our delete `Invoice` mutation. */
export type DeleteInvoicePayloadinvoiceEdgeArgs = {
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
};

/** All input for the `deleteInvoice` mutation. */
export type DeleteInvoiceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Invoice` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteInvoiceById` mutation. */
export type DeleteInvoiceByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Lead` mutation. */
export type DeleteLeadPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lead` that was deleted by this mutation. */
  lead?: Maybe<Lead>;
  deletedLeadId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Lead`. May be used by Relay 1. */
  leadEdge?: Maybe<LeadsEdge>;
};


/** The output of our delete `Lead` mutation. */
export type DeleteLeadPayloadleadEdgeArgs = {
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
};

/** All input for the `deleteLead` mutation. */
export type DeleteLeadInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lead` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLeadById` mutation. */
export type DeleteLeadByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Manufacturer` mutation. */
export type DeleteManufacturerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Manufacturer` that was deleted by this mutation. */
  manufacturer?: Maybe<Manufacturer>;
  deletedManufacturerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Manufacturer`. May be used by Relay 1. */
  manufacturerEdge?: Maybe<ManufacturersEdge>;
};


/** The output of our delete `Manufacturer` mutation. */
export type DeleteManufacturerPayloadmanufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
};

/** All input for the `deleteManufacturer` mutation. */
export type DeleteManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Manufacturer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteManufacturerById` mutation. */
export type DeleteManufacturerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Mediamanager` mutation. */
export type DeleteMediamanagerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Mediamanager` that was deleted by this mutation. */
  mediamanager?: Maybe<Mediamanager>;
  deletedMediamanagerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Mediamanager`. May be used by Relay 1. */
  mediamanagerEdge?: Maybe<MediamanagersEdge>;
};


/** The output of our delete `Mediamanager` mutation. */
export type DeleteMediamanagerPayloadmediamanagerEdgeArgs = {
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
};

/** All input for the `deleteMediamanager` mutation. */
export type DeleteMediamanagerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Mediamanager` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteMediamanagerById` mutation. */
export type DeleteMediamanagerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Meeting` mutation. */
export type DeleteMeetingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Meeting` that was deleted by this mutation. */
  meeting?: Maybe<Meeting>;
  deletedMeetingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Meeting`. May be used by Relay 1. */
  meetingEdge?: Maybe<MeetingsEdge>;
};


/** The output of our delete `Meeting` mutation. */
export type DeleteMeetingPayloadmeetingEdgeArgs = {
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
};

/** All input for the `deleteMeeting` mutation. */
export type DeleteMeetingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Meeting` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteMeetingById` mutation. */
export type DeleteMeetingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Message` mutation. */
export type DeleteMessagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Message` that was deleted by this mutation. */
  message?: Maybe<Message>;
  deletedMessageId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Message`. May be used by Relay 1. */
  messageEdge?: Maybe<MessagesEdge>;
};


/** The output of our delete `Message` mutation. */
export type DeleteMessagePayloadmessageEdgeArgs = {
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
};

/** All input for the `deleteMessage` mutation. */
export type DeleteMessageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Message` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteMessageById` mutation. */
export type DeleteMessageByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Newsletter` mutation. */
export type DeleteNewsletterPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Newsletter` that was deleted by this mutation. */
  newsletter?: Maybe<Newsletter>;
  deletedNewsletterId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Newsletter`. May be used by Relay 1. */
  newsletterEdge?: Maybe<NewslettersEdge>;
};


/** The output of our delete `Newsletter` mutation. */
export type DeleteNewsletterPayloadnewsletterEdgeArgs = {
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
};

/** All input for the `deleteNewsletter` mutation. */
export type DeleteNewsletterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Newsletter` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNewsletterById` mutation. */
export type DeleteNewsletterByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Ooto` mutation. */
export type DeleteOotoPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ooto` that was deleted by this mutation. */
  ooto?: Maybe<Ooto>;
  deletedOotoId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ooto`. May be used by Relay 1. */
  ootoEdge?: Maybe<OotosEdge>;
};


/** The output of our delete `Ooto` mutation. */
export type DeleteOotoPayloadootoEdgeArgs = {
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
};

/** All input for the `deleteOoto` mutation. */
export type DeleteOotoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Ooto` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOotoById` mutation. */
export type DeleteOotoByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Opportunity` mutation. */
export type DeleteOpportunityPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Opportunity` that was deleted by this mutation. */
  opportunity?: Maybe<Opportunity>;
  deletedOpportunityId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Opportunity`. May be used by Relay 1. */
  opportunityEdge?: Maybe<OpportunitiesEdge>;
};


/** The output of our delete `Opportunity` mutation. */
export type DeleteOpportunityPayloadopportunityEdgeArgs = {
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
};

/** All input for the `deleteOpportunity` mutation. */
export type DeleteOpportunityInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Opportunity` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOpportunityById` mutation. */
export type DeleteOpportunityByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Order` mutation. */
export type DeleteOrderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Order` that was deleted by this mutation. */
  order?: Maybe<Order>;
  deletedOrderId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Order`. May be used by Relay 1. */
  orderEdge?: Maybe<OrdersEdge>;
};


/** The output of our delete `Order` mutation. */
export type DeleteOrderPayloadorderEdgeArgs = {
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
};

/** All input for the `deleteOrder` mutation. */
export type DeleteOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Order` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrderById` mutation. */
export type DeleteOrderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Page` mutation. */
export type DeletePagePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Page` that was deleted by this mutation. */
  page?: Maybe<Page>;
  deletedPageId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Page`. May be used by Relay 1. */
  pageEdge?: Maybe<PagesEdge>;
};


/** The output of our delete `Page` mutation. */
export type DeletePagePayloadpageEdgeArgs = {
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
};

/** All input for the `deletePage` mutation. */
export type DeletePageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Page` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePageById` mutation. */
export type DeletePageByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Partner` mutation. */
export type DeletePartnerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Partner` that was deleted by this mutation. */
  partner?: Maybe<Partner>;
  deletedPartnerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Partner`. May be used by Relay 1. */
  partnerEdge?: Maybe<PartnersEdge>;
};


/** The output of our delete `Partner` mutation. */
export type DeletePartnerPayloadpartnerEdgeArgs = {
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
};

/** All input for the `deletePartner` mutation. */
export type DeletePartnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Partner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePartnerById` mutation. */
export type DeletePartnerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Payment` mutation. */
export type DeletePaymentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Payment` that was deleted by this mutation. */
  payment?: Maybe<Payment>;
  deletedPaymentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Payment`. May be used by Relay 1. */
  paymentEdge?: Maybe<PaymentsEdge>;
};


/** The output of our delete `Payment` mutation. */
export type DeletePaymentPayloadpaymentEdgeArgs = {
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
};

/** All input for the `deletePayment` mutation. */
export type DeletePaymentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Payment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePaymentById` mutation. */
export type DeletePaymentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Permission` that was deleted by this mutation. */
  permission?: Maybe<Permission>;
  deletedPermissionId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Permission`. May be used by Relay 1. */
  permissionEdge?: Maybe<PermissionsEdge>;
};


/** The output of our delete `Permission` mutation. */
export type DeletePermissionPayloadpermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
};

/** All input for the `deletePermission` mutation. */
export type DeletePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Permission` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePermissionById` mutation. */
export type DeletePermissionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Plugin` mutation. */
export type DeletePluginPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Plugin` that was deleted by this mutation. */
  plugin?: Maybe<Plugin>;
  deletedPluginId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Plugin`. May be used by Relay 1. */
  pluginEdge?: Maybe<PluginsEdge>;
};


/** The output of our delete `Plugin` mutation. */
export type DeletePluginPayloadpluginEdgeArgs = {
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
};

/** All input for the `deletePlugin` mutation. */
export type DeletePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Plugin` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePluginById` mutation. */
export type DeletePluginByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Poll` mutation. */
export type DeletePollPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Poll` that was deleted by this mutation. */
  poll?: Maybe<Poll>;
  deletedPollId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Poll`. May be used by Relay 1. */
  pollEdge?: Maybe<PollsEdge>;
};


/** The output of our delete `Poll` mutation. */
export type DeletePollPayloadpollEdgeArgs = {
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
};

/** All input for the `deletePoll` mutation. */
export type DeletePollInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Poll` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePollById` mutation. */
export type DeletePollByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ProductType` mutation. */
export type DeleteProductTypePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ProductType` that was deleted by this mutation. */
  productType?: Maybe<ProductType>;
  deletedProductTypeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ProductType`. May be used by Relay 1. */
  productTypeEdge?: Maybe<ProductTypesEdge>;
};


/** The output of our delete `ProductType` mutation. */
export type DeleteProductTypePayloadproductTypeEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
};

/** All input for the `deleteProductType` mutation. */
export type DeleteProductTypeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ProductType` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductTypeById` mutation. */
export type DeleteProductTypeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Product` mutation. */
export type DeleteProductPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Product` that was deleted by this mutation. */
  product?: Maybe<Product>;
  deletedProductId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Product`. May be used by Relay 1. */
  productEdge?: Maybe<ProductsEdge>;
};


/** The output of our delete `Product` mutation. */
export type DeleteProductPayloadproductEdgeArgs = {
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
};

/** All input for the `deleteProduct` mutation. */
export type DeleteProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Product` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProductById` mutation. */
export type DeleteProductByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Project` mutation. */
export type DeleteProjectPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Project` that was deleted by this mutation. */
  project?: Maybe<Project>;
  deletedProjectId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Project`. May be used by Relay 1. */
  projectEdge?: Maybe<ProjectsEdge>;
};


/** The output of our delete `Project` mutation. */
export type DeleteProjectPayloadprojectEdgeArgs = {
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
};

/** All input for the `deleteProject` mutation. */
export type DeleteProjectInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Project` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProjectById` mutation. */
export type DeleteProjectByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Provider` mutation. */
export type DeleteProviderPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Provider` that was deleted by this mutation. */
  provider?: Maybe<Provider>;
  deletedProviderId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Provider`. May be used by Relay 1. */
  providerEdge?: Maybe<ProvidersEdge>;
};


/** The output of our delete `Provider` mutation. */
export type DeleteProviderPayloadproviderEdgeArgs = {
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
};

/** All input for the `deleteProvider` mutation. */
export type DeleteProviderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Provider` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteProviderById` mutation. */
export type DeleteProviderByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Quote` mutation. */
export type DeleteQuotePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Quote` that was deleted by this mutation. */
  quote?: Maybe<Quote>;
  deletedQuoteId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Quote`. May be used by Relay 1. */
  quoteEdge?: Maybe<QuotesEdge>;
};


/** The output of our delete `Quote` mutation. */
export type DeleteQuotePayloadquoteEdgeArgs = {
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
};

/** All input for the `deleteQuote` mutation. */
export type DeleteQuoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Quote` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteQuoteById` mutation. */
export type DeleteQuoteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Rating` mutation. */
export type DeleteRatingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Rating` that was deleted by this mutation. */
  rating?: Maybe<Rating>;
  deletedRatingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Rating`. May be used by Relay 1. */
  ratingEdge?: Maybe<RatingsEdge>;
};


/** The output of our delete `Rating` mutation. */
export type DeleteRatingPayloadratingEdgeArgs = {
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
};

/** All input for the `deleteRating` mutation. */
export type DeleteRatingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Rating` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRatingById` mutation. */
export type DeleteRatingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Report` mutation. */
export type DeleteReportPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Report` that was deleted by this mutation. */
  report?: Maybe<Report>;
  deletedReportId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Report`. May be used by Relay 1. */
  reportEdge?: Maybe<ReportsEdge>;
};


/** The output of our delete `Report` mutation. */
export type DeleteReportPayloadreportEdgeArgs = {
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
};

/** All input for the `deleteReport` mutation. */
export type DeleteReportInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Report` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReportById` mutation. */
export type DeleteReportByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Return` mutation. */
export type DeleteReturnPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Return` that was deleted by this mutation. */
  return?: Maybe<Return>;
  deletedReturnId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Return`. May be used by Relay 1. */
  returnEdge?: Maybe<ReturnsEdge>;
};


/** The output of our delete `Return` mutation. */
export type DeleteReturnPayloadreturnEdgeArgs = {
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
};

/** All input for the `deleteReturn` mutation. */
export type DeleteReturnInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Return` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReturnById` mutation. */
export type DeleteReturnByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Review` mutation. */
export type DeleteReviewPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was deleted by this mutation. */
  review?: Maybe<Review>;
  deletedReviewId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our delete `Review` mutation. */
export type DeleteReviewPayloadreviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the `deleteReview` mutation. */
export type DeleteReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Review` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReviewById` mutation. */
export type DeleteReviewByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Reward` mutation. */
export type DeleteRewardPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Reward` that was deleted by this mutation. */
  reward?: Maybe<Reward>;
  deletedRewardId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Reward`. May be used by Relay 1. */
  rewardEdge?: Maybe<RewardsEdge>;
};


/** The output of our delete `Reward` mutation. */
export type DeleteRewardPayloadrewardEdgeArgs = {
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
};

/** All input for the `deleteReward` mutation. */
export type DeleteRewardInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Reward` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRewardById` mutation. */
export type DeleteRewardByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Role` mutation. */
export type DeleteRolePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Role` that was deleted by this mutation. */
  role?: Maybe<Role>;
  deletedRoleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Role`. May be used by Relay 1. */
  roleEdge?: Maybe<RolesEdge>;
};


/** The output of our delete `Role` mutation. */
export type DeleteRolePayloadroleEdgeArgs = {
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
};

/** All input for the `deleteRole` mutation. */
export type DeleteRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Role` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteRoleById` mutation. */
export type DeleteRoleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Scheduler` mutation. */
export type DeleteSchedulerPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Scheduler` that was deleted by this mutation. */
  scheduler?: Maybe<Scheduler>;
  deletedSchedulerId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Scheduler`. May be used by Relay 1. */
  schedulerEdge?: Maybe<SchedulersEdge>;
};


/** The output of our delete `Scheduler` mutation. */
export type DeleteSchedulerPayloadschedulerEdgeArgs = {
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
};

/** All input for the `deleteScheduler` mutation. */
export type DeleteSchedulerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Scheduler` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSchedulerById` mutation. */
export type DeleteSchedulerByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Segment` mutation. */
export type DeleteSegmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Segment` that was deleted by this mutation. */
  segment?: Maybe<Segment>;
  deletedSegmentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Segment`. May be used by Relay 1. */
  segmentEdge?: Maybe<SegmentsEdge>;
};


/** The output of our delete `Segment` mutation. */
export type DeleteSegmentPayloadsegmentEdgeArgs = {
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
};

/** All input for the `deleteSegment` mutation. */
export type DeleteSegmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Segment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSegmentById` mutation. */
export type DeleteSegmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Setting` mutation. */
export type DeleteSettingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Setting` that was deleted by this mutation. */
  setting?: Maybe<Setting>;
  deletedSettingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Setting`. May be used by Relay 1. */
  settingEdge?: Maybe<SettingsEdge>;
};


/** The output of our delete `Setting` mutation. */
export type DeleteSettingPayloadsettingEdgeArgs = {
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
};

/** All input for the `deleteSetting` mutation. */
export type DeleteSettingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Setting` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSettingById` mutation. */
export type DeleteSettingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Shipment` mutation. */
export type DeleteShipmentPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Shipment` that was deleted by this mutation. */
  shipment?: Maybe<Shipment>;
  deletedShipmentId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Shipment`. May be used by Relay 1. */
  shipmentEdge?: Maybe<ShipmentsEdge>;
};


/** The output of our delete `Shipment` mutation. */
export type DeleteShipmentPayloadshipmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
};

/** All input for the `deleteShipment` mutation. */
export type DeleteShipmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Shipment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteShipmentById` mutation. */
export type DeleteShipmentByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `SpecialDiscount` mutation. */
export type DeleteSpecialDiscountPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SpecialDiscount` that was deleted by this mutation. */
  specialDiscount?: Maybe<SpecialDiscount>;
  deletedSpecialDiscountId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `SpecialDiscount`. May be used by Relay 1. */
  specialDiscountEdge?: Maybe<SpecialDiscountsEdge>;
};


/** The output of our delete `SpecialDiscount` mutation. */
export type DeleteSpecialDiscountPayloadspecialDiscountEdgeArgs = {
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
};

/** All input for the `deleteSpecialDiscount` mutation. */
export type DeleteSpecialDiscountInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SpecialDiscount` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSpecialDiscountById` mutation. */
export type DeleteSpecialDiscountByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `State` mutation. */
export type DeleteStatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `State` that was deleted by this mutation. */
  state?: Maybe<State>;
  deletedStateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `State`. May be used by Relay 1. */
  stateEdge?: Maybe<StatesEdge>;
};


/** The output of our delete `State` mutation. */
export type DeleteStatePayloadstateEdgeArgs = {
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
};

/** All input for the `deleteState` mutation. */
export type DeleteStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `State` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStateById` mutation. */
export type DeleteStateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Statistic` mutation. */
export type DeleteStatisticPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Statistic` that was deleted by this mutation. */
  statistic?: Maybe<Statistic>;
  deletedStatisticId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Statistic`. May be used by Relay 1. */
  statisticEdge?: Maybe<StatisticsEdge>;
};


/** The output of our delete `Statistic` mutation. */
export type DeleteStatisticPayloadstatisticEdgeArgs = {
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
};

/** All input for the `deleteStatistic` mutation. */
export type DeleteStatisticInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Statistic` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStatisticById` mutation. */
export type DeleteStatisticByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Stock` mutation. */
export type DeleteStockPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Stock` that was deleted by this mutation. */
  stock?: Maybe<Stock>;
  deletedStockId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Stock`. May be used by Relay 1. */
  stockEdge?: Maybe<StocksEdge>;
};


/** The output of our delete `Stock` mutation. */
export type DeleteStockPayloadstockEdgeArgs = {
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
};

/** All input for the `deleteStock` mutation. */
export type DeleteStockInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Stock` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStockById` mutation. */
export type DeleteStockByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Survey` mutation. */
export type DeleteSurveyPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Survey` that was deleted by this mutation. */
  survey?: Maybe<Survey>;
  deletedSurveyId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Survey`. May be used by Relay 1. */
  surveyEdge?: Maybe<SurveysEdge>;
};


/** The output of our delete `Survey` mutation. */
export type DeleteSurveyPayloadsurveyEdgeArgs = {
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
};

/** All input for the `deleteSurvey` mutation. */
export type DeleteSurveyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Survey` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSurveyById` mutation. */
export type DeleteSurveyByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Tag` mutation. */
export type DeleteTagPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Tag` that was deleted by this mutation. */
  tag?: Maybe<Tag>;
  deletedTagId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Tag`. May be used by Relay 1. */
  tagEdge?: Maybe<TagsEdge>;
};


/** The output of our delete `Tag` mutation. */
export type DeleteTagPayloadtagEdgeArgs = {
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
};

/** All input for the `deleteTag` mutation. */
export type DeleteTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTagById` mutation. */
export type DeleteTagByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Target` mutation. */
export type DeleteTargetPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Target` that was deleted by this mutation. */
  target?: Maybe<Target>;
  deletedTargetId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Target`. May be used by Relay 1. */
  targetEdge?: Maybe<TargetsEdge>;
};


/** The output of our delete `Target` mutation. */
export type DeleteTargetPayloadtargetEdgeArgs = {
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
};

/** All input for the `deleteTarget` mutation. */
export type DeleteTargetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Target` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTargetById` mutation. */
export type DeleteTargetByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `TaxCategory` mutation. */
export type DeleteTaxCategoryPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxCategory` that was deleted by this mutation. */
  taxCategory?: Maybe<TaxCategory>;
  deletedTaxCategoryId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxCategory`. May be used by Relay 1. */
  taxCategoryEdge?: Maybe<TaxCategoriesEdge>;
};


/** The output of our delete `TaxCategory` mutation. */
export type DeleteTaxCategoryPayloadtaxCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
};

/** All input for the `deleteTaxCategory` mutation. */
export type DeleteTaxCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxCategory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTaxCategoryById` mutation. */
export type DeleteTaxCategoryByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `TaxRate` mutation. */
export type DeleteTaxRatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRate` that was deleted by this mutation. */
  taxRate?: Maybe<TaxRate>;
  deletedTaxRateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRate`. May be used by Relay 1. */
  taxRateEdge?: Maybe<TaxRatesEdge>;
};


/** The output of our delete `TaxRate` mutation. */
export type DeleteTaxRatePayloadtaxRateEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
};

/** All input for the `deleteTaxRate` mutation. */
export type DeleteTaxRateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxRate` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTaxRateById` mutation. */
export type DeleteTaxRateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `TaxRule` mutation. */
export type DeleteTaxRulePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TaxRule` that was deleted by this mutation. */
  taxRule?: Maybe<TaxRule>;
  deletedTaxRuleId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TaxRule`. May be used by Relay 1. */
  taxRuleEdge?: Maybe<TaxRulesEdge>;
};


/** The output of our delete `TaxRule` mutation. */
export type DeleteTaxRulePayloadtaxRuleEdgeArgs = {
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
};

/** All input for the `deleteTaxRule` mutation. */
export type DeleteTaxRuleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TaxRule` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTaxRuleById` mutation. */
export type DeleteTaxRuleByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was deleted by this mutation. */
  template?: Maybe<Template>;
  deletedTemplateId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayloadtemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the `deleteTemplate` mutation. */
export type DeleteTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Template` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTemplateById` mutation. */
export type DeleteTemplateByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Theme` mutation. */
export type DeleteThemePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Theme` that was deleted by this mutation. */
  theme?: Maybe<Theme>;
  deletedThemeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Theme`. May be used by Relay 1. */
  themeEdge?: Maybe<ThemesEdge>;
};


/** The output of our delete `Theme` mutation. */
export type DeleteThemePayloadthemeEdgeArgs = {
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
};

/** All input for the `deleteTheme` mutation. */
export type DeleteThemeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Theme` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteThemeById` mutation. */
export type DeleteThemeByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Ticketing` mutation. */
export type DeleteTicketingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Ticketing` that was deleted by this mutation. */
  ticketing?: Maybe<Ticketing>;
  deletedTicketingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Ticketing`. May be used by Relay 1. */
  ticketingEdge?: Maybe<TicketingsEdge>;
};


/** The output of our delete `Ticketing` mutation. */
export type DeleteTicketingPayloadticketingEdgeArgs = {
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
};

/** All input for the `deleteTicketing` mutation. */
export type DeleteTicketingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Ticketing` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTicketingById` mutation. */
export type DeleteTicketingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Training` mutation. */
export type DeleteTrainingPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Training` that was deleted by this mutation. */
  training?: Maybe<Training>;
  deletedTrainingId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Training`. May be used by Relay 1. */
  trainingEdge?: Maybe<TrainingsEdge>;
};


/** The output of our delete `Training` mutation. */
export type DeleteTrainingPayloadtrainingEdgeArgs = {
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
};

/** All input for the `deleteTraining` mutation. */
export type DeleteTrainingInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Training` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTrainingById` mutation. */
export type DeleteTrainingByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Transaction` mutation. */
export type DeleteTransactionPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Transaction` that was deleted by this mutation. */
  transaction?: Maybe<Transaction>;
  deletedTransactionId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Transaction`. May be used by Relay 1. */
  transactionEdge?: Maybe<TransactionsEdge>;
};


/** The output of our delete `Transaction` mutation. */
export type DeleteTransactionPayloadtransactionEdgeArgs = {
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
};

/** All input for the `deleteTransaction` mutation. */
export type DeleteTransactionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Transaction` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTransactionById` mutation. */
export type DeleteTransactionByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `UploadFile` mutation. */
export type DeleteUploadFilePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UploadFile` that was deleted by this mutation. */
  uploadFile?: Maybe<UploadFile>;
  deletedUploadFileId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `UploadFile`. May be used by Relay 1. */
  uploadFileEdge?: Maybe<UploadFilesEdge>;
};


/** The output of our delete `UploadFile` mutation. */
export type DeleteUploadFilePayloaduploadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
};

/** All input for the `deleteUploadFile` mutation. */
export type DeleteUploadFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UploadFile` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUploadFileById` mutation. */
export type DeleteUploadFileByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  deletedUserId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloaduserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserById` mutation. */
export type DeleteUserByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Vendor` mutation. */
export type DeleteVendorPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Vendor` that was deleted by this mutation. */
  vendor?: Maybe<Vendor>;
  deletedVendorId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Vendor`. May be used by Relay 1. */
  vendorEdge?: Maybe<VendorsEdge>;
};


/** The output of our delete `Vendor` mutation. */
export type DeleteVendorPayloadvendorEdgeArgs = {
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
};

/** All input for the `deleteVendor` mutation. */
export type DeleteVendorInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Vendor` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVendorById` mutation. */
export type DeleteVendorByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Visit` mutation. */
export type DeleteVisitPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Visit` that was deleted by this mutation. */
  visit?: Maybe<Visit>;
  deletedVisitId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Visit`. May be used by Relay 1. */
  visitEdge?: Maybe<VisitsEdge>;
};


/** The output of our delete `Visit` mutation. */
export type DeleteVisitPayloadvisitEdgeArgs = {
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
};

/** All input for the `deleteVisit` mutation. */
export type DeleteVisitInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Visit` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteVisitById` mutation. */
export type DeleteVisitByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Warehouse` mutation. */
export type DeleteWarehousePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Warehouse` that was deleted by this mutation. */
  warehouse?: Maybe<Warehouse>;
  deletedWarehouseId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Warehouse`. May be used by Relay 1. */
  warehouseEdge?: Maybe<WarehousesEdge>;
};


/** The output of our delete `Warehouse` mutation. */
export type DeleteWarehousePayloadwarehouseEdgeArgs = {
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
};

/** All input for the `deleteWarehouse` mutation. */
export type DeleteWarehouseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Warehouse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWarehouseById` mutation. */
export type DeleteWarehouseByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Webhook` mutation. */
export type DeleteWebhookPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Webhook` that was deleted by this mutation. */
  webhook?: Maybe<Webhook>;
  deletedWebhookId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Webhook`. May be used by Relay 1. */
  webhookEdge?: Maybe<WebhooksEdge>;
};


/** The output of our delete `Webhook` mutation. */
export type DeleteWebhookPayloadwebhookEdgeArgs = {
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
};

/** All input for the `deleteWebhook` mutation. */
export type DeleteWebhookInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Webhook` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWebhookById` mutation. */
export type DeleteWebhookByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Website` mutation. */
export type DeleteWebsitePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Website` that was deleted by this mutation. */
  website?: Maybe<Website>;
  deletedWebsiteId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Website`. May be used by Relay 1. */
  websiteEdge?: Maybe<WebsitesEdge>;
};


/** The output of our delete `Website` mutation. */
export type DeleteWebsitePayloadwebsiteEdgeArgs = {
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
};

/** All input for the `deleteWebsite` mutation. */
export type DeleteWebsiteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Website` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWebsiteById` mutation. */
export type DeleteWebsiteByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Wishlist` mutation. */
export type DeleteWishlistPayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Wishlist` that was deleted by this mutation. */
  wishlist?: Maybe<Wishlist>;
  deletedWishlistId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Wishlist`. May be used by Relay 1. */
  wishlistEdge?: Maybe<WishlistsEdge>;
};


/** The output of our delete `Wishlist` mutation. */
export type DeleteWishlistPayloadwishlistEdgeArgs = {
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
};

/** All input for the `deleteWishlist` mutation. */
export type DeleteWishlistInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Wishlist` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWishlistById` mutation. */
export type DeleteWishlistByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Workspace` mutation. */
export type DeleteWorkspacePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Workspace` that was deleted by this mutation. */
  workspace?: Maybe<Workspace>;
  deletedWorkspaceId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Workspace`. May be used by Relay 1. */
  workspaceEdge?: Maybe<WorkspacesEdge>;
};


/** The output of our delete `Workspace` mutation. */
export type DeleteWorkspacePayloadworkspaceEdgeArgs = {
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
};

/** All input for the `deleteWorkspace` mutation. */
export type DeleteWorkspaceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Workspace` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteWorkspaceById` mutation. */
export type DeleteWorkspaceByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/** The output of our delete `Zone` mutation. */
export type DeleteZonePayload = {
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Zone` that was deleted by this mutation. */
  zone?: Maybe<Zone>;
  deletedZoneId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Zone`. May be used by Relay 1. */
  zoneEdge?: Maybe<ZonesEdge>;
};


/** The output of our delete `Zone` mutation. */
export type DeleteZonePayloadzoneEdgeArgs = {
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
};

/** All input for the `deleteZone` mutation. */
export type DeleteZoneInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Zone` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteZoneById` mutation. */
export type DeleteZoneByIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['BigInt'];
};

/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type Subscription = {
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form. (live)
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live) */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. (live) */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `Account`. (live) */
  allAccounts?: Maybe<AccountsConnection>;
  /** Reads a set of `Account`. (live) */
  allAccountsList?: Maybe<Array<Account>>;
  /** Reads and enables pagination through a set of `Agreement`. (live) */
  allAgreements?: Maybe<AgreementsConnection>;
  /** Reads a set of `Agreement`. (live) */
  allAgreementsList?: Maybe<Array<Agreement>>;
  /** Reads and enables pagination through a set of `Analytic`. (live) */
  allAnalytics?: Maybe<AnalyticsConnection>;
  /** Reads a set of `Analytic`. (live) */
  allAnalyticsList?: Maybe<Array<Analytic>>;
  /** Reads and enables pagination through a set of `Apitoken`. (live) */
  allApitokens?: Maybe<ApitokensConnection>;
  /** Reads a set of `Apitoken`. (live) */
  allApitokensList?: Maybe<Array<Apitoken>>;
  /** Reads and enables pagination through a set of `Article`. (live) */
  allArticles?: Maybe<ArticlesConnection>;
  /** Reads a set of `Article`. (live) */
  allArticlesList?: Maybe<Array<Article>>;
  /** Reads and enables pagination through a set of `Attribute`. (live) */
  allAttributes?: Maybe<AttributesConnection>;
  /** Reads a set of `Attribute`. (live) */
  allAttributesList?: Maybe<Array<Attribute>>;
  /** Reads and enables pagination through a set of `Brand`. (live) */
  allBrands?: Maybe<BrandsConnection>;
  /** Reads a set of `Brand`. (live) */
  allBrandsList?: Maybe<Array<Brand>>;
  /** Reads and enables pagination through a set of `CartPriceRule`. (live) */
  allCartPriceRules?: Maybe<CartPriceRulesConnection>;
  /** Reads a set of `CartPriceRule`. (live) */
  allCartPriceRulesList?: Maybe<Array<CartPriceRule>>;
  /** Reads and enables pagination through a set of `Case`. (live) */
  allCases?: Maybe<CasesConnection>;
  /** Reads a set of `Case`. (live) */
  allCasesList?: Maybe<Array<Case>>;
  /** Reads and enables pagination through a set of `CatalogPriceRule`. (live) */
  allCatalogPriceRules?: Maybe<CatalogPriceRulesConnection>;
  /** Reads a set of `CatalogPriceRule`. (live) */
  allCatalogPriceRulesList?: Maybe<Array<CatalogPriceRule>>;
  /** Reads and enables pagination through a set of `Category`. (live) */
  allCategories?: Maybe<CategoriesConnection>;
  /** Reads a set of `Category`. (live) */
  allCategoriesList?: Maybe<Array<Category>>;
  /** Reads and enables pagination through a set of `Channel`. (live) */
  allChannels?: Maybe<ChannelsConnection>;
  /** Reads a set of `Channel`. (live) */
  allChannelsList?: Maybe<Array<Channel>>;
  /** Reads and enables pagination through a set of `Checklist`. (live) */
  allChecklists?: Maybe<ChecklistsConnection>;
  /** Reads a set of `Checklist`. (live) */
  allChecklistsList?: Maybe<Array<Checklist>>;
  /** Reads and enables pagination through a set of `City`. (live) */
  allCities?: Maybe<CitiesConnection>;
  /** Reads a set of `City`. (live) */
  allCitiesList?: Maybe<Array<City>>;
  /** Reads and enables pagination through a set of `Collection`. (live) */
  allCollections?: Maybe<CollectionsConnection>;
  /** Reads a set of `Collection`. (live) */
  allCollectionsList?: Maybe<Array<Collection>>;
  /** Reads and enables pagination through a set of `Comment`. (live) */
  allComments?: Maybe<CommentsConnection>;
  /** Reads a set of `Comment`. (live) */
  allCommentsList?: Maybe<Array<Comment>>;
  /** Reads and enables pagination through a set of `ContentType`. (live) */
  allContentTypes?: Maybe<ContentTypesConnection>;
  /** Reads a set of `ContentType`. (live) */
  allContentTypesList?: Maybe<Array<ContentType>>;
  /** Reads and enables pagination through a set of `Contract`. (live) */
  allContracts?: Maybe<ContractsConnection>;
  /** Reads a set of `Contract`. (live) */
  allContractsList?: Maybe<Array<Contract>>;
  /** Reads and enables pagination through a set of `Country`. (live) */
  allCountries?: Maybe<CountriesConnection>;
  /** Reads a set of `Country`. (live) */
  allCountriesList?: Maybe<Array<Country>>;
  /** Reads and enables pagination through a set of `Coupon`. (live) */
  allCoupons?: Maybe<CouponsConnection>;
  /** Reads a set of `Coupon`. (live) */
  allCouponsList?: Maybe<Array<Coupon>>;
  /** Reads and enables pagination through a set of `CreditMemo`. (live) */
  allCreditMemos?: Maybe<CreditMemosConnection>;
  /** Reads a set of `CreditMemo`. (live) */
  allCreditMemosList?: Maybe<Array<CreditMemo>>;
  /** Reads and enables pagination through a set of `Currency`. (live) */
  allCurrencies?: Maybe<CurrenciesConnection>;
  /** Reads a set of `Currency`. (live) */
  allCurrenciesList?: Maybe<Array<Currency>>;
  /** Reads and enables pagination through a set of `CurrencyRate`. (live) */
  allCurrencyRates?: Maybe<CurrencyRatesConnection>;
  /** Reads a set of `CurrencyRate`. (live) */
  allCurrencyRatesList?: Maybe<Array<CurrencyRate>>;
  /** Reads and enables pagination through a set of `CurrencySymbol`. (live) */
  allCurrencySymbols?: Maybe<CurrencySymbolsConnection>;
  /** Reads a set of `CurrencySymbol`. (live) */
  allCurrencySymbolsList?: Maybe<Array<CurrencySymbol>>;
  /** Reads and enables pagination through a set of `CustomerGroup`. (live) */
  allCustomerGroups?: Maybe<CustomerGroupsConnection>;
  /** Reads a set of `CustomerGroup`. (live) */
  allCustomerGroupsList?: Maybe<Array<CustomerGroup>>;
  /** Reads and enables pagination through a set of `Customer`. (live) */
  allCustomers?: Maybe<CustomersConnection>;
  /** Reads a set of `Customer`. (live) */
  allCustomersList?: Maybe<Array<Customer>>;
  /** Reads and enables pagination through a set of `Customization`. (live) */
  allCustomizations?: Maybe<CustomizationsConnection>;
  /** Reads a set of `Customization`. (live) */
  allCustomizationsList?: Maybe<Array<Customization>>;
  /** Reads and enables pagination through a set of `Dashboard`. (live) */
  allDashboards?: Maybe<DashboardsConnection>;
  /** Reads a set of `Dashboard`. (live) */
  allDashboardsList?: Maybe<Array<Dashboard>>;
  /** Reads and enables pagination through a set of `Deepdive`. (live) */
  allDeepdives?: Maybe<DeepdivesConnection>;
  /** Reads a set of `Deepdive`. (live) */
  allDeepdivesList?: Maybe<Array<Deepdive>>;
  /** Reads and enables pagination through a set of `Digiboard`. (live) */
  allDigiboards?: Maybe<DigiboardsConnection>;
  /** Reads a set of `Digiboard`. (live) */
  allDigiboardsList?: Maybe<Array<Digiboard>>;
  /** Reads and enables pagination through a set of `Email`. (live) */
  allEmails?: Maybe<EmailsConnection>;
  /** Reads a set of `Email`. (live) */
  allEmailsList?: Maybe<Array<Email>>;
  /** Reads and enables pagination through a set of `Endofshift`. (live) */
  allEndofshifts?: Maybe<EndofshiftsConnection>;
  /** Reads a set of `Endofshift`. (live) */
  allEndofshiftsList?: Maybe<Array<Endofshift>>;
  /** Reads and enables pagination through a set of `Event`. (live) */
  allEvents?: Maybe<EventsConnection>;
  /** Reads a set of `Event`. (live) */
  allEventsList?: Maybe<Array<Event>>;
  /** Reads and enables pagination through a set of `Fullfillment`. (live) */
  allFullfillments?: Maybe<FullfillmentsConnection>;
  /** Reads a set of `Fullfillment`. (live) */
  allFullfillmentsList?: Maybe<Array<Fullfillment>>;
  /** Reads and enables pagination through a set of `GiftCertificate`. (live) */
  allGiftCertificates?: Maybe<GiftCertificatesConnection>;
  /** Reads a set of `GiftCertificate`. (live) */
  allGiftCertificatesList?: Maybe<Array<GiftCertificate>>;
  /** Reads and enables pagination through a set of `Glossary`. (live) */
  allGlossaries?: Maybe<GlossariesConnection>;
  /** Reads a set of `Glossary`. (live) */
  allGlossariesList?: Maybe<Array<Glossary>>;
  /** Reads and enables pagination through a set of `Importm`. (live) */
  allImportms?: Maybe<ImportmsConnection>;
  /** Reads a set of `Importm`. (live) */
  allImportmsList?: Maybe<Array<Importm>>;
  /** Reads and enables pagination through a set of `Integration`. (live) */
  allIntegrations?: Maybe<IntegrationsConnection>;
  /** Reads a set of `Integration`. (live) */
  allIntegrationsList?: Maybe<Array<Integration>>;
  /** Reads and enables pagination through a set of `Internalization`. (live) */
  allInternalizations?: Maybe<InternalizationsConnection>;
  /** Reads a set of `Internalization`. (live) */
  allInternalizationsList?: Maybe<Array<Internalization>>;
  /** Reads and enables pagination through a set of `Invitation`. (live) */
  allInvitations?: Maybe<InvitationsConnection>;
  /** Reads a set of `Invitation`. (live) */
  allInvitationsList?: Maybe<Array<Invitation>>;
  /** Reads and enables pagination through a set of `Invoice`. (live) */
  allInvoices?: Maybe<InvoicesConnection>;
  /** Reads a set of `Invoice`. (live) */
  allInvoicesList?: Maybe<Array<Invoice>>;
  /** Reads and enables pagination through a set of `Lead`. (live) */
  allLeads?: Maybe<LeadsConnection>;
  /** Reads a set of `Lead`. (live) */
  allLeadsList?: Maybe<Array<Lead>>;
  /** Reads and enables pagination through a set of `Manufacturer`. (live) */
  allManufacturers?: Maybe<ManufacturersConnection>;
  /** Reads a set of `Manufacturer`. (live) */
  allManufacturersList?: Maybe<Array<Manufacturer>>;
  /** Reads and enables pagination through a set of `Mediamanager`. (live) */
  allMediamanagers?: Maybe<MediamanagersConnection>;
  /** Reads a set of `Mediamanager`. (live) */
  allMediamanagersList?: Maybe<Array<Mediamanager>>;
  /** Reads and enables pagination through a set of `Meeting`. (live) */
  allMeetings?: Maybe<MeetingsConnection>;
  /** Reads a set of `Meeting`. (live) */
  allMeetingsList?: Maybe<Array<Meeting>>;
  /** Reads and enables pagination through a set of `Message`. (live) */
  allMessages?: Maybe<MessagesConnection>;
  /** Reads a set of `Message`. (live) */
  allMessagesList?: Maybe<Array<Message>>;
  /** Reads and enables pagination through a set of `Newsletter`. (live) */
  allNewsletters?: Maybe<NewslettersConnection>;
  /** Reads a set of `Newsletter`. (live) */
  allNewslettersList?: Maybe<Array<Newsletter>>;
  /** Reads and enables pagination through a set of `Ooto`. (live) */
  allOotos?: Maybe<OotosConnection>;
  /** Reads a set of `Ooto`. (live) */
  allOotosList?: Maybe<Array<Ooto>>;
  /** Reads and enables pagination through a set of `Opportunity`. (live) */
  allOpportunities?: Maybe<OpportunitiesConnection>;
  /** Reads a set of `Opportunity`. (live) */
  allOpportunitiesList?: Maybe<Array<Opportunity>>;
  /** Reads and enables pagination through a set of `Order`. (live) */
  allOrders?: Maybe<OrdersConnection>;
  /** Reads a set of `Order`. (live) */
  allOrdersList?: Maybe<Array<Order>>;
  /** Reads and enables pagination through a set of `Page`. (live) */
  allPages?: Maybe<PagesConnection>;
  /** Reads a set of `Page`. (live) */
  allPagesList?: Maybe<Array<Page>>;
  /** Reads and enables pagination through a set of `Partner`. (live) */
  allPartners?: Maybe<PartnersConnection>;
  /** Reads a set of `Partner`. (live) */
  allPartnersList?: Maybe<Array<Partner>>;
  /** Reads and enables pagination through a set of `Payment`. (live) */
  allPayments?: Maybe<PaymentsConnection>;
  /** Reads a set of `Payment`. (live) */
  allPaymentsList?: Maybe<Array<Payment>>;
  /** Reads and enables pagination through a set of `Permission`. (live) */
  allPermissions?: Maybe<PermissionsConnection>;
  /** Reads a set of `Permission`. (live) */
  allPermissionsList?: Maybe<Array<Permission>>;
  /** Reads and enables pagination through a set of `Plugin`. (live) */
  allPlugins?: Maybe<PluginsConnection>;
  /** Reads a set of `Plugin`. (live) */
  allPluginsList?: Maybe<Array<Plugin>>;
  /** Reads and enables pagination through a set of `Poll`. (live) */
  allPolls?: Maybe<PollsConnection>;
  /** Reads a set of `Poll`. (live) */
  allPollsList?: Maybe<Array<Poll>>;
  /** Reads and enables pagination through a set of `ProductType`. (live) */
  allProductTypes?: Maybe<ProductTypesConnection>;
  /** Reads a set of `ProductType`. (live) */
  allProductTypesList?: Maybe<Array<ProductType>>;
  /** Reads and enables pagination through a set of `Product`. (live) */
  allProducts?: Maybe<ProductsConnection>;
  /** Reads a set of `Product`. (live) */
  allProductsList?: Maybe<Array<Product>>;
  /** Reads and enables pagination through a set of `Project`. (live) */
  allProjects?: Maybe<ProjectsConnection>;
  /** Reads a set of `Project`. (live) */
  allProjectsList?: Maybe<Array<Project>>;
  /** Reads and enables pagination through a set of `Provider`. (live) */
  allProviders?: Maybe<ProvidersConnection>;
  /** Reads a set of `Provider`. (live) */
  allProvidersList?: Maybe<Array<Provider>>;
  /** Reads and enables pagination through a set of `Quote`. (live) */
  allQuotes?: Maybe<QuotesConnection>;
  /** Reads a set of `Quote`. (live) */
  allQuotesList?: Maybe<Array<Quote>>;
  /** Reads and enables pagination through a set of `Rating`. (live) */
  allRatings?: Maybe<RatingsConnection>;
  /** Reads a set of `Rating`. (live) */
  allRatingsList?: Maybe<Array<Rating>>;
  /** Reads and enables pagination through a set of `Report`. (live) */
  allReports?: Maybe<ReportsConnection>;
  /** Reads a set of `Report`. (live) */
  allReportsList?: Maybe<Array<Report>>;
  /** Reads and enables pagination through a set of `Return`. (live) */
  allReturns?: Maybe<ReturnsConnection>;
  /** Reads a set of `Return`. (live) */
  allReturnsList?: Maybe<Array<Return>>;
  /** Reads and enables pagination through a set of `Review`. (live) */
  allReviews?: Maybe<ReviewsConnection>;
  /** Reads a set of `Review`. (live) */
  allReviewsList?: Maybe<Array<Review>>;
  /** Reads and enables pagination through a set of `Reward`. (live) */
  allRewards?: Maybe<RewardsConnection>;
  /** Reads a set of `Reward`. (live) */
  allRewardsList?: Maybe<Array<Reward>>;
  /** Reads and enables pagination through a set of `Role`. (live) */
  allRoles?: Maybe<RolesConnection>;
  /** Reads a set of `Role`. (live) */
  allRolesList?: Maybe<Array<Role>>;
  /** Reads and enables pagination through a set of `Scheduler`. (live) */
  allSchedulers?: Maybe<SchedulersConnection>;
  /** Reads a set of `Scheduler`. (live) */
  allSchedulersList?: Maybe<Array<Scheduler>>;
  /** Reads and enables pagination through a set of `Segment`. (live) */
  allSegments?: Maybe<SegmentsConnection>;
  /** Reads a set of `Segment`. (live) */
  allSegmentsList?: Maybe<Array<Segment>>;
  /** Reads and enables pagination through a set of `Setting`. (live) */
  allSettings?: Maybe<SettingsConnection>;
  /** Reads a set of `Setting`. (live) */
  allSettingsList?: Maybe<Array<Setting>>;
  /** Reads and enables pagination through a set of `Shipment`. (live) */
  allShipments?: Maybe<ShipmentsConnection>;
  /** Reads a set of `Shipment`. (live) */
  allShipmentsList?: Maybe<Array<Shipment>>;
  /** Reads and enables pagination through a set of `SpecialDiscount`. (live) */
  allSpecialDiscounts?: Maybe<SpecialDiscountsConnection>;
  /** Reads a set of `SpecialDiscount`. (live) */
  allSpecialDiscountsList?: Maybe<Array<SpecialDiscount>>;
  /** Reads and enables pagination through a set of `State`. (live) */
  allStates?: Maybe<StatesConnection>;
  /** Reads a set of `State`. (live) */
  allStatesList?: Maybe<Array<State>>;
  /** Reads and enables pagination through a set of `Statistic`. (live) */
  allStatistics?: Maybe<StatisticsConnection>;
  /** Reads a set of `Statistic`. (live) */
  allStatisticsList?: Maybe<Array<Statistic>>;
  /** Reads and enables pagination through a set of `Stock`. (live) */
  allStocks?: Maybe<StocksConnection>;
  /** Reads a set of `Stock`. (live) */
  allStocksList?: Maybe<Array<Stock>>;
  /** Reads and enables pagination through a set of `Survey`. (live) */
  allSurveys?: Maybe<SurveysConnection>;
  /** Reads a set of `Survey`. (live) */
  allSurveysList?: Maybe<Array<Survey>>;
  /** Reads and enables pagination through a set of `Tag`. (live) */
  allTags?: Maybe<TagsConnection>;
  /** Reads a set of `Tag`. (live) */
  allTagsList?: Maybe<Array<Tag>>;
  /** Reads and enables pagination through a set of `Target`. (live) */
  allTargets?: Maybe<TargetsConnection>;
  /** Reads a set of `Target`. (live) */
  allTargetsList?: Maybe<Array<Target>>;
  /** Reads and enables pagination through a set of `TaxCategory`. (live) */
  allTaxCategories?: Maybe<TaxCategoriesConnection>;
  /** Reads a set of `TaxCategory`. (live) */
  allTaxCategoriesList?: Maybe<Array<TaxCategory>>;
  /** Reads and enables pagination through a set of `TaxRate`. (live) */
  allTaxRates?: Maybe<TaxRatesConnection>;
  /** Reads a set of `TaxRate`. (live) */
  allTaxRatesList?: Maybe<Array<TaxRate>>;
  /** Reads and enables pagination through a set of `TaxRule`. (live) */
  allTaxRules?: Maybe<TaxRulesConnection>;
  /** Reads a set of `TaxRule`. (live) */
  allTaxRulesList?: Maybe<Array<TaxRule>>;
  /** Reads and enables pagination through a set of `Template`. (live) */
  allTemplates?: Maybe<TemplatesConnection>;
  /** Reads a set of `Template`. (live) */
  allTemplatesList?: Maybe<Array<Template>>;
  /** Reads and enables pagination through a set of `Theme`. (live) */
  allThemes?: Maybe<ThemesConnection>;
  /** Reads a set of `Theme`. (live) */
  allThemesList?: Maybe<Array<Theme>>;
  /** Reads and enables pagination through a set of `Ticketing`. (live) */
  allTicketings?: Maybe<TicketingsConnection>;
  /** Reads a set of `Ticketing`. (live) */
  allTicketingsList?: Maybe<Array<Ticketing>>;
  /** Reads and enables pagination through a set of `Training`. (live) */
  allTrainings?: Maybe<TrainingsConnection>;
  /** Reads a set of `Training`. (live) */
  allTrainingsList?: Maybe<Array<Training>>;
  /** Reads and enables pagination through a set of `Transaction`. (live) */
  allTransactions?: Maybe<TransactionsConnection>;
  /** Reads a set of `Transaction`. (live) */
  allTransactionsList?: Maybe<Array<Transaction>>;
  /** Reads and enables pagination through a set of `UploadFile`. (live) */
  allUploadFiles?: Maybe<UploadFilesConnection>;
  /** Reads a set of `UploadFile`. (live) */
  allUploadFilesList?: Maybe<Array<UploadFile>>;
  /** Reads and enables pagination through a set of `User`. (live) */
  allUsers?: Maybe<UsersConnection>;
  /** Reads a set of `User`. (live) */
  allUsersList?: Maybe<Array<User>>;
  /** Reads and enables pagination through a set of `Vendor`. (live) */
  allVendors?: Maybe<VendorsConnection>;
  /** Reads a set of `Vendor`. (live) */
  allVendorsList?: Maybe<Array<Vendor>>;
  /** Reads and enables pagination through a set of `Visit`. (live) */
  allVisits?: Maybe<VisitsConnection>;
  /** Reads a set of `Visit`. (live) */
  allVisitsList?: Maybe<Array<Visit>>;
  /** Reads and enables pagination through a set of `Warehouse`. (live) */
  allWarehouses?: Maybe<WarehousesConnection>;
  /** Reads a set of `Warehouse`. (live) */
  allWarehousesList?: Maybe<Array<Warehouse>>;
  /** Reads and enables pagination through a set of `Webhook`. (live) */
  allWebhooks?: Maybe<WebhooksConnection>;
  /** Reads a set of `Webhook`. (live) */
  allWebhooksList?: Maybe<Array<Webhook>>;
  /** Reads and enables pagination through a set of `Website`. (live) */
  allWebsites?: Maybe<WebsitesConnection>;
  /** Reads a set of `Website`. (live) */
  allWebsitesList?: Maybe<Array<Website>>;
  /** Reads and enables pagination through a set of `Wishlist`. (live) */
  allWishlists?: Maybe<WishlistsConnection>;
  /** Reads a set of `Wishlist`. (live) */
  allWishlistsList?: Maybe<Array<Wishlist>>;
  /** Reads and enables pagination through a set of `Workspace`. (live) */
  allWorkspaces?: Maybe<WorkspacesConnection>;
  /** Reads a set of `Workspace`. (live) */
  allWorkspacesList?: Maybe<Array<Workspace>>;
  /** Reads and enables pagination through a set of `Zone`. (live) */
  allZones?: Maybe<ZonesConnection>;
  /** Reads a set of `Zone`. (live) */
  allZonesList?: Maybe<Array<Zone>>;
  /**  (live) */
  accountById?: Maybe<Account>;
  /**  (live) */
  agreementById?: Maybe<Agreement>;
  /**  (live) */
  analyticById?: Maybe<Analytic>;
  /**  (live) */
  apitokenById?: Maybe<Apitoken>;
  /**  (live) */
  articleById?: Maybe<Article>;
  /**  (live) */
  attributeById?: Maybe<Attribute>;
  /**  (live) */
  brandById?: Maybe<Brand>;
  /**  (live) */
  cartPriceRuleById?: Maybe<CartPriceRule>;
  /**  (live) */
  caseById?: Maybe<Case>;
  /**  (live) */
  catalogPriceRuleById?: Maybe<CatalogPriceRule>;
  /**  (live) */
  categoryById?: Maybe<Category>;
  /**  (live) */
  channelById?: Maybe<Channel>;
  /**  (live) */
  checklistById?: Maybe<Checklist>;
  /**  (live) */
  cityById?: Maybe<City>;
  /**  (live) */
  collectionById?: Maybe<Collection>;
  /**  (live) */
  commentById?: Maybe<Comment>;
  /**  (live) */
  contentTypeById?: Maybe<ContentType>;
  /**  (live) */
  contractById?: Maybe<Contract>;
  /**  (live) */
  countryById?: Maybe<Country>;
  /**  (live) */
  couponById?: Maybe<Coupon>;
  /**  (live) */
  creditMemoByCreditMemoAndId?: Maybe<CreditMemo>;
  /**  (live) */
  currencyById?: Maybe<Currency>;
  /**  (live) */
  currencyRateByImportService?: Maybe<CurrencyRate>;
  /**  (live) */
  currencySymbolBySymbol?: Maybe<CurrencySymbol>;
  /**  (live) */
  customerGroupById?: Maybe<CustomerGroup>;
  /**  (live) */
  customerById?: Maybe<Customer>;
  /**  (live) */
  customizationById?: Maybe<Customization>;
  /**  (live) */
  dashboardById?: Maybe<Dashboard>;
  /**  (live) */
  deepdiveById?: Maybe<Deepdive>;
  /**  (live) */
  digiboardById?: Maybe<Digiboard>;
  /**  (live) */
  emailById?: Maybe<Email>;
  /**  (live) */
  endofshiftById?: Maybe<Endofshift>;
  /**  (live) */
  eventById?: Maybe<Event>;
  /**  (live) */
  fullfillmentById?: Maybe<Fullfillment>;
  /**  (live) */
  giftCertificateById?: Maybe<GiftCertificate>;
  /**  (live) */
  glossaryById?: Maybe<Glossary>;
  /**  (live) */
  importmById?: Maybe<Importm>;
  /**  (live) */
  integrationById?: Maybe<Integration>;
  /**  (live) */
  internalizationById?: Maybe<Internalization>;
  /**  (live) */
  invitationById?: Maybe<Invitation>;
  /**  (live) */
  invoiceById?: Maybe<Invoice>;
  /**  (live) */
  leadById?: Maybe<Lead>;
  /**  (live) */
  manufacturerById?: Maybe<Manufacturer>;
  /**  (live) */
  mediamanagerById?: Maybe<Mediamanager>;
  /**  (live) */
  meetingById?: Maybe<Meeting>;
  /**  (live) */
  messageById?: Maybe<Message>;
  /**  (live) */
  newsletterById?: Maybe<Newsletter>;
  /**  (live) */
  ootoById?: Maybe<Ooto>;
  /**  (live) */
  opportunityById?: Maybe<Opportunity>;
  /**  (live) */
  orderById?: Maybe<Order>;
  /**  (live) */
  pageById?: Maybe<Page>;
  /**  (live) */
  partnerById?: Maybe<Partner>;
  /**  (live) */
  paymentById?: Maybe<Payment>;
  /**  (live) */
  permissionById?: Maybe<Permission>;
  /**  (live) */
  pluginById?: Maybe<Plugin>;
  /**  (live) */
  pollById?: Maybe<Poll>;
  /**  (live) */
  productTypeById?: Maybe<ProductType>;
  /**  (live) */
  productById?: Maybe<Product>;
  /**  (live) */
  projectById?: Maybe<Project>;
  /**  (live) */
  providerById?: Maybe<Provider>;
  /**  (live) */
  quoteById?: Maybe<Quote>;
  /**  (live) */
  ratingById?: Maybe<Rating>;
  /**  (live) */
  reportById?: Maybe<Report>;
  /**  (live) */
  returnById?: Maybe<Return>;
  /**  (live) */
  reviewById?: Maybe<Review>;
  /**  (live) */
  rewardById?: Maybe<Reward>;
  /**  (live) */
  roleById?: Maybe<Role>;
  /**  (live) */
  schedulerById?: Maybe<Scheduler>;
  /**  (live) */
  segmentById?: Maybe<Segment>;
  /**  (live) */
  settingById?: Maybe<Setting>;
  /**  (live) */
  shipmentById?: Maybe<Shipment>;
  /**  (live) */
  specialDiscountById?: Maybe<SpecialDiscount>;
  /**  (live) */
  stateById?: Maybe<State>;
  /**  (live) */
  statisticById?: Maybe<Statistic>;
  /**  (live) */
  stockById?: Maybe<Stock>;
  /**  (live) */
  surveyById?: Maybe<Survey>;
  /**  (live) */
  tagById?: Maybe<Tag>;
  /**  (live) */
  targetById?: Maybe<Target>;
  /**  (live) */
  taxCategoryById?: Maybe<TaxCategory>;
  /**  (live) */
  taxRateById?: Maybe<TaxRate>;
  /**  (live) */
  taxRuleById?: Maybe<TaxRule>;
  /**  (live) */
  templateById?: Maybe<Template>;
  /**  (live) */
  themeById?: Maybe<Theme>;
  /**  (live) */
  ticketingById?: Maybe<Ticketing>;
  /**  (live) */
  trainingById?: Maybe<Training>;
  /**  (live) */
  transactionById?: Maybe<Transaction>;
  /**  (live) */
  uploadFileById?: Maybe<UploadFile>;
  /**  (live) */
  userById?: Maybe<User>;
  /**  (live) */
  vendorById?: Maybe<Vendor>;
  /**  (live) */
  visitById?: Maybe<Visit>;
  /**  (live) */
  warehouseById?: Maybe<Warehouse>;
  /**  (live) */
  webhookById?: Maybe<Webhook>;
  /**  (live) */
  websiteById?: Maybe<Website>;
  /**  (live) */
  wishlistById?: Maybe<Wishlist>;
  /**  (live) */
  workspaceById?: Maybe<Workspace>;
  /**  (live) */
  zoneById?: Maybe<Zone>;
  /** Reads a single `Account` using its globally unique `ID`. (live) */
  account?: Maybe<Account>;
  /** Reads a single `Agreement` using its globally unique `ID`. (live) */
  agreement?: Maybe<Agreement>;
  /** Reads a single `Analytic` using its globally unique `ID`. (live) */
  analytic?: Maybe<Analytic>;
  /** Reads a single `Apitoken` using its globally unique `ID`. (live) */
  apitoken?: Maybe<Apitoken>;
  /** Reads a single `Article` using its globally unique `ID`. (live) */
  article?: Maybe<Article>;
  /** Reads a single `Attribute` using its globally unique `ID`. (live) */
  attribute?: Maybe<Attribute>;
  /** Reads a single `Brand` using its globally unique `ID`. (live) */
  brand?: Maybe<Brand>;
  /** Reads a single `CartPriceRule` using its globally unique `ID`. (live) */
  cartPriceRule?: Maybe<CartPriceRule>;
  /** Reads a single `Case` using its globally unique `ID`. (live) */
  case?: Maybe<Case>;
  /** Reads a single `CatalogPriceRule` using its globally unique `ID`. (live) */
  catalogPriceRule?: Maybe<CatalogPriceRule>;
  /** Reads a single `Category` using its globally unique `ID`. (live) */
  category?: Maybe<Category>;
  /** Reads a single `Channel` using its globally unique `ID`. (live) */
  channel?: Maybe<Channel>;
  /** Reads a single `Checklist` using its globally unique `ID`. (live) */
  checklist?: Maybe<Checklist>;
  /** Reads a single `City` using its globally unique `ID`. (live) */
  city?: Maybe<City>;
  /** Reads a single `Collection` using its globally unique `ID`. (live) */
  collection?: Maybe<Collection>;
  /** Reads a single `Comment` using its globally unique `ID`. (live) */
  comment?: Maybe<Comment>;
  /** Reads a single `ContentType` using its globally unique `ID`. (live) */
  contentType?: Maybe<ContentType>;
  /** Reads a single `Contract` using its globally unique `ID`. (live) */
  contract?: Maybe<Contract>;
  /** Reads a single `Country` using its globally unique `ID`. (live) */
  country?: Maybe<Country>;
  /** Reads a single `Coupon` using its globally unique `ID`. (live) */
  coupon?: Maybe<Coupon>;
  /** Reads a single `CreditMemo` using its globally unique `ID`. (live) */
  creditMemo?: Maybe<CreditMemo>;
  /** Reads a single `Currency` using its globally unique `ID`. (live) */
  currency?: Maybe<Currency>;
  /** Reads a single `CurrencyRate` using its globally unique `ID`. (live) */
  currencyRate?: Maybe<CurrencyRate>;
  /** Reads a single `CurrencySymbol` using its globally unique `ID`. (live) */
  currencySymbol?: Maybe<CurrencySymbol>;
  /** Reads a single `CustomerGroup` using its globally unique `ID`. (live) */
  customerGroup?: Maybe<CustomerGroup>;
  /** Reads a single `Customer` using its globally unique `ID`. (live) */
  customer?: Maybe<Customer>;
  /** Reads a single `Customization` using its globally unique `ID`. (live) */
  customization?: Maybe<Customization>;
  /** Reads a single `Dashboard` using its globally unique `ID`. (live) */
  dashboard?: Maybe<Dashboard>;
  /** Reads a single `Deepdive` using its globally unique `ID`. (live) */
  deepdive?: Maybe<Deepdive>;
  /** Reads a single `Digiboard` using its globally unique `ID`. (live) */
  digiboard?: Maybe<Digiboard>;
  /** Reads a single `Email` using its globally unique `ID`. (live) */
  email?: Maybe<Email>;
  /** Reads a single `Endofshift` using its globally unique `ID`. (live) */
  endofshift?: Maybe<Endofshift>;
  /** Reads a single `Event` using its globally unique `ID`. (live) */
  event?: Maybe<Event>;
  /** Reads a single `Fullfillment` using its globally unique `ID`. (live) */
  fullfillment?: Maybe<Fullfillment>;
  /** Reads a single `GiftCertificate` using its globally unique `ID`. (live) */
  giftCertificate?: Maybe<GiftCertificate>;
  /** Reads a single `Glossary` using its globally unique `ID`. (live) */
  glossary?: Maybe<Glossary>;
  /** Reads a single `Importm` using its globally unique `ID`. (live) */
  importm?: Maybe<Importm>;
  /** Reads a single `Integration` using its globally unique `ID`. (live) */
  integration?: Maybe<Integration>;
  /** Reads a single `Internalization` using its globally unique `ID`. (live) */
  internalization?: Maybe<Internalization>;
  /** Reads a single `Invitation` using its globally unique `ID`. (live) */
  invitation?: Maybe<Invitation>;
  /** Reads a single `Invoice` using its globally unique `ID`. (live) */
  invoice?: Maybe<Invoice>;
  /** Reads a single `Lead` using its globally unique `ID`. (live) */
  lead?: Maybe<Lead>;
  /** Reads a single `Manufacturer` using its globally unique `ID`. (live) */
  manufacturer?: Maybe<Manufacturer>;
  /** Reads a single `Mediamanager` using its globally unique `ID`. (live) */
  mediamanager?: Maybe<Mediamanager>;
  /** Reads a single `Meeting` using its globally unique `ID`. (live) */
  meeting?: Maybe<Meeting>;
  /** Reads a single `Message` using its globally unique `ID`. (live) */
  message?: Maybe<Message>;
  /** Reads a single `Newsletter` using its globally unique `ID`. (live) */
  newsletter?: Maybe<Newsletter>;
  /** Reads a single `Ooto` using its globally unique `ID`. (live) */
  ooto?: Maybe<Ooto>;
  /** Reads a single `Opportunity` using its globally unique `ID`. (live) */
  opportunity?: Maybe<Opportunity>;
  /** Reads a single `Order` using its globally unique `ID`. (live) */
  order?: Maybe<Order>;
  /** Reads a single `Page` using its globally unique `ID`. (live) */
  page?: Maybe<Page>;
  /** Reads a single `Partner` using its globally unique `ID`. (live) */
  partner?: Maybe<Partner>;
  /** Reads a single `Payment` using its globally unique `ID`. (live) */
  payment?: Maybe<Payment>;
  /** Reads a single `Permission` using its globally unique `ID`. (live) */
  permission?: Maybe<Permission>;
  /** Reads a single `Plugin` using its globally unique `ID`. (live) */
  plugin?: Maybe<Plugin>;
  /** Reads a single `Poll` using its globally unique `ID`. (live) */
  poll?: Maybe<Poll>;
  /** Reads a single `ProductType` using its globally unique `ID`. (live) */
  productType?: Maybe<ProductType>;
  /** Reads a single `Product` using its globally unique `ID`. (live) */
  product?: Maybe<Product>;
  /** Reads a single `Project` using its globally unique `ID`. (live) */
  project?: Maybe<Project>;
  /** Reads a single `Provider` using its globally unique `ID`. (live) */
  provider?: Maybe<Provider>;
  /** Reads a single `Quote` using its globally unique `ID`. (live) */
  quote?: Maybe<Quote>;
  /** Reads a single `Rating` using its globally unique `ID`. (live) */
  rating?: Maybe<Rating>;
  /** Reads a single `Report` using its globally unique `ID`. (live) */
  report?: Maybe<Report>;
  /** Reads a single `Return` using its globally unique `ID`. (live) */
  return?: Maybe<Return>;
  /** Reads a single `Review` using its globally unique `ID`. (live) */
  review?: Maybe<Review>;
  /** Reads a single `Reward` using its globally unique `ID`. (live) */
  reward?: Maybe<Reward>;
  /** Reads a single `Role` using its globally unique `ID`. (live) */
  role?: Maybe<Role>;
  /** Reads a single `Scheduler` using its globally unique `ID`. (live) */
  scheduler?: Maybe<Scheduler>;
  /** Reads a single `Segment` using its globally unique `ID`. (live) */
  segment?: Maybe<Segment>;
  /** Reads a single `Setting` using its globally unique `ID`. (live) */
  setting?: Maybe<Setting>;
  /** Reads a single `Shipment` using its globally unique `ID`. (live) */
  shipment?: Maybe<Shipment>;
  /** Reads a single `SpecialDiscount` using its globally unique `ID`. (live) */
  specialDiscount?: Maybe<SpecialDiscount>;
  /** Reads a single `State` using its globally unique `ID`. (live) */
  state?: Maybe<State>;
  /** Reads a single `Statistic` using its globally unique `ID`. (live) */
  statistic?: Maybe<Statistic>;
  /** Reads a single `Stock` using its globally unique `ID`. (live) */
  stock?: Maybe<Stock>;
  /** Reads a single `Survey` using its globally unique `ID`. (live) */
  survey?: Maybe<Survey>;
  /** Reads a single `Tag` using its globally unique `ID`. (live) */
  tag?: Maybe<Tag>;
  /** Reads a single `Target` using its globally unique `ID`. (live) */
  target?: Maybe<Target>;
  /** Reads a single `TaxCategory` using its globally unique `ID`. (live) */
  taxCategory?: Maybe<TaxCategory>;
  /** Reads a single `TaxRate` using its globally unique `ID`. (live) */
  taxRate?: Maybe<TaxRate>;
  /** Reads a single `TaxRule` using its globally unique `ID`. (live) */
  taxRule?: Maybe<TaxRule>;
  /** Reads a single `Template` using its globally unique `ID`. (live) */
  template?: Maybe<Template>;
  /** Reads a single `Theme` using its globally unique `ID`. (live) */
  theme?: Maybe<Theme>;
  /** Reads a single `Ticketing` using its globally unique `ID`. (live) */
  ticketing?: Maybe<Ticketing>;
  /** Reads a single `Training` using its globally unique `ID`. (live) */
  training?: Maybe<Training>;
  /** Reads a single `Transaction` using its globally unique `ID`. (live) */
  transaction?: Maybe<Transaction>;
  /** Reads a single `UploadFile` using its globally unique `ID`. (live) */
  uploadFile?: Maybe<UploadFile>;
  /** Reads a single `User` using its globally unique `ID`. (live) */
  user?: Maybe<User>;
  /** Reads a single `Vendor` using its globally unique `ID`. (live) */
  vendor?: Maybe<Vendor>;
  /** Reads a single `Visit` using its globally unique `ID`. (live) */
  visit?: Maybe<Visit>;
  /** Reads a single `Warehouse` using its globally unique `ID`. (live) */
  warehouse?: Maybe<Warehouse>;
  /** Reads a single `Webhook` using its globally unique `ID`. (live) */
  webhook?: Maybe<Webhook>;
  /** Reads a single `Website` using its globally unique `ID`. (live) */
  website?: Maybe<Website>;
  /** Reads a single `Wishlist` using its globally unique `ID`. (live) */
  wishlist?: Maybe<Wishlist>;
  /** Reads a single `Workspace` using its globally unique `ID`. (live) */
  workspace?: Maybe<Workspace>;
  /** Reads a single `Zone` using its globally unique `ID`. (live) */
  zone?: Maybe<Zone>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionnodeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAccountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  condition?: InputMaybe<AccountCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAccountsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AccountsOrderBy>>;
  condition?: InputMaybe<AccountCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAgreementsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
  condition?: InputMaybe<AgreementCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAgreementsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AgreementsOrderBy>>;
  condition?: InputMaybe<AgreementCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAnalyticsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
  condition?: InputMaybe<AnalyticCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAnalyticsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AnalyticsOrderBy>>;
  condition?: InputMaybe<AnalyticCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallApitokensArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
  condition?: InputMaybe<ApitokenCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallApitokensListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ApitokensOrderBy>>;
  condition?: InputMaybe<ApitokenCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallArticlesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
  condition?: InputMaybe<ArticleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallArticlesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ArticlesOrderBy>>;
  condition?: InputMaybe<ArticleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAttributesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
  condition?: InputMaybe<AttributeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallAttributesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<AttributesOrderBy>>;
  condition?: InputMaybe<AttributeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallBrandsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
  condition?: InputMaybe<BrandCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallBrandsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<BrandsOrderBy>>;
  condition?: InputMaybe<BrandCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCartPriceRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
  condition?: InputMaybe<CartPriceRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCartPriceRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CartPriceRulesOrderBy>>;
  condition?: InputMaybe<CartPriceRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCasesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
  condition?: InputMaybe<CaseCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCasesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CasesOrderBy>>;
  condition?: InputMaybe<CaseCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCatalogPriceRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
  condition?: InputMaybe<CatalogPriceRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCatalogPriceRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CatalogPriceRulesOrderBy>>;
  condition?: InputMaybe<CatalogPriceRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
  condition?: InputMaybe<CategoryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCategoriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CategoriesOrderBy>>;
  condition?: InputMaybe<CategoryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallChannelsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
  condition?: InputMaybe<ChannelCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallChannelsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ChannelsOrderBy>>;
  condition?: InputMaybe<ChannelCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallChecklistsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
  condition?: InputMaybe<ChecklistCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallChecklistsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ChecklistsOrderBy>>;
  condition?: InputMaybe<ChecklistCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  condition?: InputMaybe<CityCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCitiesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CitiesOrderBy>>;
  condition?: InputMaybe<CityCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCollectionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
  condition?: InputMaybe<CollectionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCollectionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CollectionsOrderBy>>;
  condition?: InputMaybe<CollectionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCommentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
  condition?: InputMaybe<CommentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCommentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CommentsOrderBy>>;
  condition?: InputMaybe<CommentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallContentTypesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
  condition?: InputMaybe<ContentTypeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallContentTypesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ContentTypesOrderBy>>;
  condition?: InputMaybe<ContentTypeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallContractsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
  condition?: InputMaybe<ContractCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallContractsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ContractsOrderBy>>;
  condition?: InputMaybe<ContractCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCountriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  condition?: InputMaybe<CountryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCountriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CountriesOrderBy>>;
  condition?: InputMaybe<CountryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCouponsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
  condition?: InputMaybe<CouponCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCouponsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CouponsOrderBy>>;
  condition?: InputMaybe<CouponCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCreditMemosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
  condition?: InputMaybe<CreditMemoCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCreditMemosListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CreditMemosOrderBy>>;
  condition?: InputMaybe<CreditMemoCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrenciesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
  condition?: InputMaybe<CurrencyCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrenciesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrenciesOrderBy>>;
  condition?: InputMaybe<CurrencyCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrencyRatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
  condition?: InputMaybe<CurrencyRateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrencyRatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencyRatesOrderBy>>;
  condition?: InputMaybe<CurrencyRateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrencySymbolsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
  condition?: InputMaybe<CurrencySymbolCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCurrencySymbolsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CurrencySymbolsOrderBy>>;
  condition?: InputMaybe<CurrencySymbolCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomerGroupsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
  condition?: InputMaybe<CustomerGroupCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomerGroupsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomerGroupsOrderBy>>;
  condition?: InputMaybe<CustomerGroupCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
  condition?: InputMaybe<CustomerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomersOrderBy>>;
  condition?: InputMaybe<CustomerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomizationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
  condition?: InputMaybe<CustomizationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallCustomizationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<CustomizationsOrderBy>>;
  condition?: InputMaybe<CustomizationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDashboardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
  condition?: InputMaybe<DashboardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDashboardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DashboardsOrderBy>>;
  condition?: InputMaybe<DashboardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDeepdivesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
  condition?: InputMaybe<DeepdiveCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDeepdivesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DeepdivesOrderBy>>;
  condition?: InputMaybe<DeepdiveCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDigiboardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
  condition?: InputMaybe<DigiboardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallDigiboardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<DigiboardsOrderBy>>;
  condition?: InputMaybe<DigiboardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEmailsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  condition?: InputMaybe<EmailCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEmailsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EmailsOrderBy>>;
  condition?: InputMaybe<EmailCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEndofshiftsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
  condition?: InputMaybe<EndofshiftCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEndofshiftsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EndofshiftsOrderBy>>;
  condition?: InputMaybe<EndofshiftCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  condition?: InputMaybe<EventCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallEventsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<EventsOrderBy>>;
  condition?: InputMaybe<EventCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallFullfillmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
  condition?: InputMaybe<FullfillmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallFullfillmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<FullfillmentsOrderBy>>;
  condition?: InputMaybe<FullfillmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallGiftCertificatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
  condition?: InputMaybe<GiftCertificateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallGiftCertificatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GiftCertificatesOrderBy>>;
  condition?: InputMaybe<GiftCertificateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallGlossariesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
  condition?: InputMaybe<GlossaryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallGlossariesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<GlossariesOrderBy>>;
  condition?: InputMaybe<GlossaryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallImportmsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
  condition?: InputMaybe<ImportmCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallImportmsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ImportmsOrderBy>>;
  condition?: InputMaybe<ImportmCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallIntegrationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
  condition?: InputMaybe<IntegrationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallIntegrationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<IntegrationsOrderBy>>;
  condition?: InputMaybe<IntegrationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInternalizationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
  condition?: InputMaybe<InternalizationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInternalizationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InternalizationsOrderBy>>;
  condition?: InputMaybe<InternalizationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInvitationsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
  condition?: InputMaybe<InvitationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInvitationsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InvitationsOrderBy>>;
  condition?: InputMaybe<InvitationCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInvoicesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
  condition?: InputMaybe<InvoiceCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallInvoicesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<InvoicesOrderBy>>;
  condition?: InputMaybe<InvoiceCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallLeadsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
  condition?: InputMaybe<LeadCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallLeadsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<LeadsOrderBy>>;
  condition?: InputMaybe<LeadCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallManufacturersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
  condition?: InputMaybe<ManufacturerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallManufacturersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ManufacturersOrderBy>>;
  condition?: InputMaybe<ManufacturerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMediamanagersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
  condition?: InputMaybe<MediamanagerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMediamanagersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MediamanagersOrderBy>>;
  condition?: InputMaybe<MediamanagerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMeetingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
  condition?: InputMaybe<MeetingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMeetingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MeetingsOrderBy>>;
  condition?: InputMaybe<MeetingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMessagesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  condition?: InputMaybe<MessageCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallMessagesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<MessagesOrderBy>>;
  condition?: InputMaybe<MessageCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallNewslettersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
  condition?: InputMaybe<NewsletterCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallNewslettersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<NewslettersOrderBy>>;
  condition?: InputMaybe<NewsletterCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOotosArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
  condition?: InputMaybe<OotoCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOotosListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OotosOrderBy>>;
  condition?: InputMaybe<OotoCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOpportunitiesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
  condition?: InputMaybe<OpportunityCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOpportunitiesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OpportunitiesOrderBy>>;
  condition?: InputMaybe<OpportunityCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOrdersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
  condition?: InputMaybe<OrderCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallOrdersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<OrdersOrderBy>>;
  condition?: InputMaybe<OrderCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPagesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
  condition?: InputMaybe<PageCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPagesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PagesOrderBy>>;
  condition?: InputMaybe<PageCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPartnersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
  condition?: InputMaybe<PartnerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPartnersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PartnersOrderBy>>;
  condition?: InputMaybe<PartnerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPaymentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
  condition?: InputMaybe<PaymentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPaymentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PaymentsOrderBy>>;
  condition?: InputMaybe<PaymentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPermissionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  condition?: InputMaybe<PermissionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPermissionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PermissionsOrderBy>>;
  condition?: InputMaybe<PermissionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPluginsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
  condition?: InputMaybe<PluginCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPluginsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PluginsOrderBy>>;
  condition?: InputMaybe<PluginCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPollsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
  condition?: InputMaybe<PollCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallPollsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<PollsOrderBy>>;
  condition?: InputMaybe<PollCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProductTypesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
  condition?: InputMaybe<ProductTypeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProductTypesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProductTypesOrderBy>>;
  condition?: InputMaybe<ProductTypeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProductsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
  condition?: InputMaybe<ProductCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProductsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProductsOrderBy>>;
  condition?: InputMaybe<ProductCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProjectsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  condition?: InputMaybe<ProjectCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProjectsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProjectsOrderBy>>;
  condition?: InputMaybe<ProjectCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProvidersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
  condition?: InputMaybe<ProviderCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallProvidersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ProvidersOrderBy>>;
  condition?: InputMaybe<ProviderCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallQuotesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  condition?: InputMaybe<QuoteCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallQuotesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<QuotesOrderBy>>;
  condition?: InputMaybe<QuoteCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRatingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
  condition?: InputMaybe<RatingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRatingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RatingsOrderBy>>;
  condition?: InputMaybe<RatingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReportsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
  condition?: InputMaybe<ReportCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReportsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReportsOrderBy>>;
  condition?: InputMaybe<ReportCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReturnsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
  condition?: InputMaybe<ReturnCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReturnsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReturnsOrderBy>>;
  condition?: InputMaybe<ReturnCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReviewsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
  condition?: InputMaybe<ReviewCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallReviewsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
  condition?: InputMaybe<ReviewCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRewardsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
  condition?: InputMaybe<RewardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRewardsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RewardsOrderBy>>;
  condition?: InputMaybe<RewardCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRolesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  condition?: InputMaybe<RoleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallRolesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<RolesOrderBy>>;
  condition?: InputMaybe<RoleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSchedulersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
  condition?: InputMaybe<SchedulerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSchedulersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SchedulersOrderBy>>;
  condition?: InputMaybe<SchedulerCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSegmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
  condition?: InputMaybe<SegmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSegmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SegmentsOrderBy>>;
  condition?: InputMaybe<SegmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSettingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
  condition?: InputMaybe<SettingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSettingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SettingsOrderBy>>;
  condition?: InputMaybe<SettingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallShipmentsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
  condition?: InputMaybe<ShipmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallShipmentsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ShipmentsOrderBy>>;
  condition?: InputMaybe<ShipmentCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSpecialDiscountsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
  condition?: InputMaybe<SpecialDiscountCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSpecialDiscountsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SpecialDiscountsOrderBy>>;
  condition?: InputMaybe<SpecialDiscountCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
  condition?: InputMaybe<StateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StatesOrderBy>>;
  condition?: InputMaybe<StateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStatisticsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
  condition?: InputMaybe<StatisticCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStatisticsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StatisticsOrderBy>>;
  condition?: InputMaybe<StatisticCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStocksArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
  condition?: InputMaybe<StockCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallStocksListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<StocksOrderBy>>;
  condition?: InputMaybe<StockCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSurveysArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
  condition?: InputMaybe<SurveyCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallSurveysListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<SurveysOrderBy>>;
  condition?: InputMaybe<SurveyCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTagsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
  condition?: InputMaybe<TagCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTagsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TagsOrderBy>>;
  condition?: InputMaybe<TagCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTargetsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
  condition?: InputMaybe<TargetCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTargetsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TargetsOrderBy>>;
  condition?: InputMaybe<TargetCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxCategoriesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
  condition?: InputMaybe<TaxCategoryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxCategoriesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxCategoriesOrderBy>>;
  condition?: InputMaybe<TaxCategoryCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxRatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
  condition?: InputMaybe<TaxRateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxRatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxRatesOrderBy>>;
  condition?: InputMaybe<TaxRateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxRulesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
  condition?: InputMaybe<TaxRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTaxRulesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TaxRulesOrderBy>>;
  condition?: InputMaybe<TaxRuleCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTemplatesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
  condition?: InputMaybe<TemplateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTemplatesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
  condition?: InputMaybe<TemplateCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallThemesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
  condition?: InputMaybe<ThemeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallThemesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ThemesOrderBy>>;
  condition?: InputMaybe<ThemeCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTicketingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
  condition?: InputMaybe<TicketingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTicketingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TicketingsOrderBy>>;
  condition?: InputMaybe<TicketingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTrainingsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
  condition?: InputMaybe<TrainingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTrainingsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TrainingsOrderBy>>;
  condition?: InputMaybe<TrainingCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTransactionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
  condition?: InputMaybe<TransactionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallTransactionsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<TransactionsOrderBy>>;
  condition?: InputMaybe<TransactionCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallUploadFilesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
  condition?: InputMaybe<UploadFileCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallUploadFilesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UploadFilesOrderBy>>;
  condition?: InputMaybe<UploadFileCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallUsersArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  condition?: InputMaybe<UserCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallUsersListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
  condition?: InputMaybe<UserCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallVendorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
  condition?: InputMaybe<VendorCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallVendorsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VendorsOrderBy>>;
  condition?: InputMaybe<VendorCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallVisitsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
  condition?: InputMaybe<VisitCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallVisitsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<VisitsOrderBy>>;
  condition?: InputMaybe<VisitCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWarehousesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
  condition?: InputMaybe<WarehouseCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWarehousesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WarehousesOrderBy>>;
  condition?: InputMaybe<WarehouseCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWebhooksArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
  condition?: InputMaybe<WebhookCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWebhooksListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebhooksOrderBy>>;
  condition?: InputMaybe<WebhookCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWebsitesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
  condition?: InputMaybe<WebsiteCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWebsitesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WebsitesOrderBy>>;
  condition?: InputMaybe<WebsiteCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWishlistsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
  condition?: InputMaybe<WishlistCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWishlistsListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WishlistsOrderBy>>;
  condition?: InputMaybe<WishlistCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWorkspacesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
  condition?: InputMaybe<WorkspaceCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallWorkspacesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<WorkspacesOrderBy>>;
  condition?: InputMaybe<WorkspaceCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallZonesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
  condition?: InputMaybe<ZoneCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionallZonesListArgs = {
  first?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<ZonesOrderBy>>;
  condition?: InputMaybe<ZoneCondition>;
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionaccountByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionagreementByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionanalyticByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionapitokenByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionarticleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionattributeByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionbrandByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncartPriceRuleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncaseByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncatalogPriceRuleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncategoryByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionchannelByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionchecklistByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncityByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncollectionByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncommentByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncontentTypeByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncontractByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncountryByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncouponByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncreditMemoByCreditMemoAndIdArgs = {
  creditMemo: Scalars['String'];
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencyByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencyRateByImportServiceArgs = {
  importService: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencySymbolBySymbolArgs = {
  symbol: Scalars['String'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomerGroupByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomerByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomizationByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondashboardByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondeepdiveByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondigiboardByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionemailByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionendofshiftByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioneventByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionfullfillmentByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiongiftCertificateByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionglossaryByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionimportmByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionintegrationByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninternalizationByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninvitationByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninvoiceByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionleadByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmanufacturerByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmediamanagerByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmeetingByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmessageByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionnewsletterByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionootoByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionopportunityByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionorderByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpageByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpartnerByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpaymentByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpermissionByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpluginByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpollByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproductTypeByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproductByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionprojectByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproviderByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionquoteByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionratingByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreportByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreturnByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreviewByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionrewardByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionroleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionschedulerByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsegmentByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsettingByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionshipmentByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionspecialDiscountByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstateByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstatisticByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstockByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsurveyByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontagByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontargetByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxCategoryByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxRateByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxRuleByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontemplateByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionthemeByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionticketingByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontrainingByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontransactionByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionuploadFileByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionuserByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionvendorByIdArgs = {
  id: Scalars['Int'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionvisitByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwarehouseByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwebhookByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwebsiteByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwishlistByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionworkspaceByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionzoneByIdArgs = {
  id: Scalars['BigInt'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionaccountArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionagreementArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionanalyticArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionapitokenArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionarticleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionattributeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionbrandArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncartPriceRuleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncaseArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncatalogPriceRuleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncategoryArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionchannelArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionchecklistArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncityArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncollectionArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncommentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncontentTypeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncontractArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncountryArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncouponArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncreditMemoArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencyArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencyRateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncurrencySymbolArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomerGroupArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioncustomizationArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondashboardArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondeepdiveArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiondigiboardArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionemailArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionendofshiftArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioneventArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionfullfillmentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiongiftCertificateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionglossaryArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionimportmArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionintegrationArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninternalizationArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninvitationArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptioninvoiceArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionleadArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmanufacturerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmediamanagerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmeetingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionmessageArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionnewsletterArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionootoArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionopportunityArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionorderArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpageArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpartnerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpaymentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpermissionArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpluginArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionpollArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproductTypeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproductArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionprojectArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionproviderArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionquoteArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionratingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreportArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreturnArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionreviewArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionrewardArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionroleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionschedulerArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsegmentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsettingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionshipmentArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionspecialDiscountArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstatisticArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionstockArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionsurveyArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontagArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontargetArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxCategoryArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxRateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontaxRuleArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontemplateArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionthemeArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionticketingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontrainingArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptiontransactionArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionuploadFileArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionuserArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionvendorArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionvisitArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwarehouseArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwebhookArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwebsiteArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionwishlistArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionworkspaceArgs = {
  nodeId: Scalars['ID'];
};


/**
 * The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.
 *
 * #### Live Queries
 *
 * Live query fields are differentiated by containing `(live)` at the end of their
 * description, they are added for each field in the `Query` type. When you
 * subscribe to a live query field, the selection set will be evaluated and sent to
 * the client, and then most things\* that would cause the output of the selection
 * set to change will trigger the selection set to be re-evaluated and the results
 * to be re-sent to the client.
 *
 * _(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_
 *
 * Live queries can be very expensive, so try and keep them small and focussed.
 *
 * #### Events
 *
 * Event fields will run their selection set when, and only when, the specified
 * server-side event occurs. This makes them a lot more efficient than Live
 * Queries, but it is still recommended that you keep payloads fairly small.
 */
export type SubscriptionzoneArgs = {
  nodeId: Scalars['ID'];
};

  export type QuerySdk = {
      /** Exposes the root query type nested one level down. This is helpful for Relay 1
which can only query top level fields if they are in a particular form. **/
  query: InContextSdkMethod<Query['query'], {}, MeshContext>,
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. **/
  nodeId: InContextSdkMethod<Query['nodeId'], {}, MeshContext>,
  /** Fetches an object given its globally unique `ID`. **/
  node: InContextSdkMethod<Query['node'], QuerynodeArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Account`. **/
  allAccounts: InContextSdkMethod<Query['allAccounts'], QueryallAccountsArgs, MeshContext>,
  /** Reads a set of `Account`. **/
  allAccountsList: InContextSdkMethod<Query['allAccountsList'], QueryallAccountsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Agreement`. **/
  allAgreements: InContextSdkMethod<Query['allAgreements'], QueryallAgreementsArgs, MeshContext>,
  /** Reads a set of `Agreement`. **/
  allAgreementsList: InContextSdkMethod<Query['allAgreementsList'], QueryallAgreementsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Analytic`. **/
  allAnalytics: InContextSdkMethod<Query['allAnalytics'], QueryallAnalyticsArgs, MeshContext>,
  /** Reads a set of `Analytic`. **/
  allAnalyticsList: InContextSdkMethod<Query['allAnalyticsList'], QueryallAnalyticsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Apitoken`. **/
  allApitokens: InContextSdkMethod<Query['allApitokens'], QueryallApitokensArgs, MeshContext>,
  /** Reads a set of `Apitoken`. **/
  allApitokensList: InContextSdkMethod<Query['allApitokensList'], QueryallApitokensListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Article`. **/
  allArticles: InContextSdkMethod<Query['allArticles'], QueryallArticlesArgs, MeshContext>,
  /** Reads a set of `Article`. **/
  allArticlesList: InContextSdkMethod<Query['allArticlesList'], QueryallArticlesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Attribute`. **/
  allAttributes: InContextSdkMethod<Query['allAttributes'], QueryallAttributesArgs, MeshContext>,
  /** Reads a set of `Attribute`. **/
  allAttributesList: InContextSdkMethod<Query['allAttributesList'], QueryallAttributesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Brand`. **/
  allBrands: InContextSdkMethod<Query['allBrands'], QueryallBrandsArgs, MeshContext>,
  /** Reads a set of `Brand`. **/
  allBrandsList: InContextSdkMethod<Query['allBrandsList'], QueryallBrandsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CartPriceRule`. **/
  allCartPriceRules: InContextSdkMethod<Query['allCartPriceRules'], QueryallCartPriceRulesArgs, MeshContext>,
  /** Reads a set of `CartPriceRule`. **/
  allCartPriceRulesList: InContextSdkMethod<Query['allCartPriceRulesList'], QueryallCartPriceRulesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Case`. **/
  allCases: InContextSdkMethod<Query['allCases'], QueryallCasesArgs, MeshContext>,
  /** Reads a set of `Case`. **/
  allCasesList: InContextSdkMethod<Query['allCasesList'], QueryallCasesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CatalogPriceRule`. **/
  allCatalogPriceRules: InContextSdkMethod<Query['allCatalogPriceRules'], QueryallCatalogPriceRulesArgs, MeshContext>,
  /** Reads a set of `CatalogPriceRule`. **/
  allCatalogPriceRulesList: InContextSdkMethod<Query['allCatalogPriceRulesList'], QueryallCatalogPriceRulesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Category`. **/
  allCategories: InContextSdkMethod<Query['allCategories'], QueryallCategoriesArgs, MeshContext>,
  /** Reads a set of `Category`. **/
  allCategoriesList: InContextSdkMethod<Query['allCategoriesList'], QueryallCategoriesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Channel`. **/
  allChannels: InContextSdkMethod<Query['allChannels'], QueryallChannelsArgs, MeshContext>,
  /** Reads a set of `Channel`. **/
  allChannelsList: InContextSdkMethod<Query['allChannelsList'], QueryallChannelsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Checklist`. **/
  allChecklists: InContextSdkMethod<Query['allChecklists'], QueryallChecklistsArgs, MeshContext>,
  /** Reads a set of `Checklist`. **/
  allChecklistsList: InContextSdkMethod<Query['allChecklistsList'], QueryallChecklistsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `City`. **/
  allCities: InContextSdkMethod<Query['allCities'], QueryallCitiesArgs, MeshContext>,
  /** Reads a set of `City`. **/
  allCitiesList: InContextSdkMethod<Query['allCitiesList'], QueryallCitiesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Collection`. **/
  allCollections: InContextSdkMethod<Query['allCollections'], QueryallCollectionsArgs, MeshContext>,
  /** Reads a set of `Collection`. **/
  allCollectionsList: InContextSdkMethod<Query['allCollectionsList'], QueryallCollectionsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Comment`. **/
  allComments: InContextSdkMethod<Query['allComments'], QueryallCommentsArgs, MeshContext>,
  /** Reads a set of `Comment`. **/
  allCommentsList: InContextSdkMethod<Query['allCommentsList'], QueryallCommentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `ContentType`. **/
  allContentTypes: InContextSdkMethod<Query['allContentTypes'], QueryallContentTypesArgs, MeshContext>,
  /** Reads a set of `ContentType`. **/
  allContentTypesList: InContextSdkMethod<Query['allContentTypesList'], QueryallContentTypesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Contract`. **/
  allContracts: InContextSdkMethod<Query['allContracts'], QueryallContractsArgs, MeshContext>,
  /** Reads a set of `Contract`. **/
  allContractsList: InContextSdkMethod<Query['allContractsList'], QueryallContractsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Country`. **/
  allCountries: InContextSdkMethod<Query['allCountries'], QueryallCountriesArgs, MeshContext>,
  /** Reads a set of `Country`. **/
  allCountriesList: InContextSdkMethod<Query['allCountriesList'], QueryallCountriesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Coupon`. **/
  allCoupons: InContextSdkMethod<Query['allCoupons'], QueryallCouponsArgs, MeshContext>,
  /** Reads a set of `Coupon`. **/
  allCouponsList: InContextSdkMethod<Query['allCouponsList'], QueryallCouponsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CreditMemo`. **/
  allCreditMemos: InContextSdkMethod<Query['allCreditMemos'], QueryallCreditMemosArgs, MeshContext>,
  /** Reads a set of `CreditMemo`. **/
  allCreditMemosList: InContextSdkMethod<Query['allCreditMemosList'], QueryallCreditMemosListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Currency`. **/
  allCurrencies: InContextSdkMethod<Query['allCurrencies'], QueryallCurrenciesArgs, MeshContext>,
  /** Reads a set of `Currency`. **/
  allCurrenciesList: InContextSdkMethod<Query['allCurrenciesList'], QueryallCurrenciesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CurrencyRate`. **/
  allCurrencyRates: InContextSdkMethod<Query['allCurrencyRates'], QueryallCurrencyRatesArgs, MeshContext>,
  /** Reads a set of `CurrencyRate`. **/
  allCurrencyRatesList: InContextSdkMethod<Query['allCurrencyRatesList'], QueryallCurrencyRatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CurrencySymbol`. **/
  allCurrencySymbols: InContextSdkMethod<Query['allCurrencySymbols'], QueryallCurrencySymbolsArgs, MeshContext>,
  /** Reads a set of `CurrencySymbol`. **/
  allCurrencySymbolsList: InContextSdkMethod<Query['allCurrencySymbolsList'], QueryallCurrencySymbolsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CustomerGroup`. **/
  allCustomerGroups: InContextSdkMethod<Query['allCustomerGroups'], QueryallCustomerGroupsArgs, MeshContext>,
  /** Reads a set of `CustomerGroup`. **/
  allCustomerGroupsList: InContextSdkMethod<Query['allCustomerGroupsList'], QueryallCustomerGroupsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Customer`. **/
  allCustomers: InContextSdkMethod<Query['allCustomers'], QueryallCustomersArgs, MeshContext>,
  /** Reads a set of `Customer`. **/
  allCustomersList: InContextSdkMethod<Query['allCustomersList'], QueryallCustomersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Customization`. **/
  allCustomizations: InContextSdkMethod<Query['allCustomizations'], QueryallCustomizationsArgs, MeshContext>,
  /** Reads a set of `Customization`. **/
  allCustomizationsList: InContextSdkMethod<Query['allCustomizationsList'], QueryallCustomizationsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Dashboard`. **/
  allDashboards: InContextSdkMethod<Query['allDashboards'], QueryallDashboardsArgs, MeshContext>,
  /** Reads a set of `Dashboard`. **/
  allDashboardsList: InContextSdkMethod<Query['allDashboardsList'], QueryallDashboardsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Deepdive`. **/
  allDeepdives: InContextSdkMethod<Query['allDeepdives'], QueryallDeepdivesArgs, MeshContext>,
  /** Reads a set of `Deepdive`. **/
  allDeepdivesList: InContextSdkMethod<Query['allDeepdivesList'], QueryallDeepdivesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Digiboard`. **/
  allDigiboards: InContextSdkMethod<Query['allDigiboards'], QueryallDigiboardsArgs, MeshContext>,
  /** Reads a set of `Digiboard`. **/
  allDigiboardsList: InContextSdkMethod<Query['allDigiboardsList'], QueryallDigiboardsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Email`. **/
  allEmails: InContextSdkMethod<Query['allEmails'], QueryallEmailsArgs, MeshContext>,
  /** Reads a set of `Email`. **/
  allEmailsList: InContextSdkMethod<Query['allEmailsList'], QueryallEmailsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Endofshift`. **/
  allEndofshifts: InContextSdkMethod<Query['allEndofshifts'], QueryallEndofshiftsArgs, MeshContext>,
  /** Reads a set of `Endofshift`. **/
  allEndofshiftsList: InContextSdkMethod<Query['allEndofshiftsList'], QueryallEndofshiftsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Event`. **/
  allEvents: InContextSdkMethod<Query['allEvents'], QueryallEventsArgs, MeshContext>,
  /** Reads a set of `Event`. **/
  allEventsList: InContextSdkMethod<Query['allEventsList'], QueryallEventsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Fullfillment`. **/
  allFullfillments: InContextSdkMethod<Query['allFullfillments'], QueryallFullfillmentsArgs, MeshContext>,
  /** Reads a set of `Fullfillment`. **/
  allFullfillmentsList: InContextSdkMethod<Query['allFullfillmentsList'], QueryallFullfillmentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `GiftCertificate`. **/
  allGiftCertificates: InContextSdkMethod<Query['allGiftCertificates'], QueryallGiftCertificatesArgs, MeshContext>,
  /** Reads a set of `GiftCertificate`. **/
  allGiftCertificatesList: InContextSdkMethod<Query['allGiftCertificatesList'], QueryallGiftCertificatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Glossary`. **/
  allGlossaries: InContextSdkMethod<Query['allGlossaries'], QueryallGlossariesArgs, MeshContext>,
  /** Reads a set of `Glossary`. **/
  allGlossariesList: InContextSdkMethod<Query['allGlossariesList'], QueryallGlossariesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Importm`. **/
  allImportms: InContextSdkMethod<Query['allImportms'], QueryallImportmsArgs, MeshContext>,
  /** Reads a set of `Importm`. **/
  allImportmsList: InContextSdkMethod<Query['allImportmsList'], QueryallImportmsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Integration`. **/
  allIntegrations: InContextSdkMethod<Query['allIntegrations'], QueryallIntegrationsArgs, MeshContext>,
  /** Reads a set of `Integration`. **/
  allIntegrationsList: InContextSdkMethod<Query['allIntegrationsList'], QueryallIntegrationsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Internalization`. **/
  allInternalizations: InContextSdkMethod<Query['allInternalizations'], QueryallInternalizationsArgs, MeshContext>,
  /** Reads a set of `Internalization`. **/
  allInternalizationsList: InContextSdkMethod<Query['allInternalizationsList'], QueryallInternalizationsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Invitation`. **/
  allInvitations: InContextSdkMethod<Query['allInvitations'], QueryallInvitationsArgs, MeshContext>,
  /** Reads a set of `Invitation`. **/
  allInvitationsList: InContextSdkMethod<Query['allInvitationsList'], QueryallInvitationsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Invoice`. **/
  allInvoices: InContextSdkMethod<Query['allInvoices'], QueryallInvoicesArgs, MeshContext>,
  /** Reads a set of `Invoice`. **/
  allInvoicesList: InContextSdkMethod<Query['allInvoicesList'], QueryallInvoicesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Lead`. **/
  allLeads: InContextSdkMethod<Query['allLeads'], QueryallLeadsArgs, MeshContext>,
  /** Reads a set of `Lead`. **/
  allLeadsList: InContextSdkMethod<Query['allLeadsList'], QueryallLeadsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Manufacturer`. **/
  allManufacturers: InContextSdkMethod<Query['allManufacturers'], QueryallManufacturersArgs, MeshContext>,
  /** Reads a set of `Manufacturer`. **/
  allManufacturersList: InContextSdkMethod<Query['allManufacturersList'], QueryallManufacturersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Mediamanager`. **/
  allMediamanagers: InContextSdkMethod<Query['allMediamanagers'], QueryallMediamanagersArgs, MeshContext>,
  /** Reads a set of `Mediamanager`. **/
  allMediamanagersList: InContextSdkMethod<Query['allMediamanagersList'], QueryallMediamanagersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Meeting`. **/
  allMeetings: InContextSdkMethod<Query['allMeetings'], QueryallMeetingsArgs, MeshContext>,
  /** Reads a set of `Meeting`. **/
  allMeetingsList: InContextSdkMethod<Query['allMeetingsList'], QueryallMeetingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Message`. **/
  allMessages: InContextSdkMethod<Query['allMessages'], QueryallMessagesArgs, MeshContext>,
  /** Reads a set of `Message`. **/
  allMessagesList: InContextSdkMethod<Query['allMessagesList'], QueryallMessagesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Newsletter`. **/
  allNewsletters: InContextSdkMethod<Query['allNewsletters'], QueryallNewslettersArgs, MeshContext>,
  /** Reads a set of `Newsletter`. **/
  allNewslettersList: InContextSdkMethod<Query['allNewslettersList'], QueryallNewslettersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Ooto`. **/
  allOotos: InContextSdkMethod<Query['allOotos'], QueryallOotosArgs, MeshContext>,
  /** Reads a set of `Ooto`. **/
  allOotosList: InContextSdkMethod<Query['allOotosList'], QueryallOotosListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Opportunity`. **/
  allOpportunities: InContextSdkMethod<Query['allOpportunities'], QueryallOpportunitiesArgs, MeshContext>,
  /** Reads a set of `Opportunity`. **/
  allOpportunitiesList: InContextSdkMethod<Query['allOpportunitiesList'], QueryallOpportunitiesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Order`. **/
  allOrders: InContextSdkMethod<Query['allOrders'], QueryallOrdersArgs, MeshContext>,
  /** Reads a set of `Order`. **/
  allOrdersList: InContextSdkMethod<Query['allOrdersList'], QueryallOrdersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Page`. **/
  allPages: InContextSdkMethod<Query['allPages'], QueryallPagesArgs, MeshContext>,
  /** Reads a set of `Page`. **/
  allPagesList: InContextSdkMethod<Query['allPagesList'], QueryallPagesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Partner`. **/
  allPartners: InContextSdkMethod<Query['allPartners'], QueryallPartnersArgs, MeshContext>,
  /** Reads a set of `Partner`. **/
  allPartnersList: InContextSdkMethod<Query['allPartnersList'], QueryallPartnersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Payment`. **/
  allPayments: InContextSdkMethod<Query['allPayments'], QueryallPaymentsArgs, MeshContext>,
  /** Reads a set of `Payment`. **/
  allPaymentsList: InContextSdkMethod<Query['allPaymentsList'], QueryallPaymentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Permission`. **/
  allPermissions: InContextSdkMethod<Query['allPermissions'], QueryallPermissionsArgs, MeshContext>,
  /** Reads a set of `Permission`. **/
  allPermissionsList: InContextSdkMethod<Query['allPermissionsList'], QueryallPermissionsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Plugin`. **/
  allPlugins: InContextSdkMethod<Query['allPlugins'], QueryallPluginsArgs, MeshContext>,
  /** Reads a set of `Plugin`. **/
  allPluginsList: InContextSdkMethod<Query['allPluginsList'], QueryallPluginsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Poll`. **/
  allPolls: InContextSdkMethod<Query['allPolls'], QueryallPollsArgs, MeshContext>,
  /** Reads a set of `Poll`. **/
  allPollsList: InContextSdkMethod<Query['allPollsList'], QueryallPollsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `ProductType`. **/
  allProductTypes: InContextSdkMethod<Query['allProductTypes'], QueryallProductTypesArgs, MeshContext>,
  /** Reads a set of `ProductType`. **/
  allProductTypesList: InContextSdkMethod<Query['allProductTypesList'], QueryallProductTypesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Product`. **/
  allProducts: InContextSdkMethod<Query['allProducts'], QueryallProductsArgs, MeshContext>,
  /** Reads a set of `Product`. **/
  allProductsList: InContextSdkMethod<Query['allProductsList'], QueryallProductsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Project`. **/
  allProjects: InContextSdkMethod<Query['allProjects'], QueryallProjectsArgs, MeshContext>,
  /** Reads a set of `Project`. **/
  allProjectsList: InContextSdkMethod<Query['allProjectsList'], QueryallProjectsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Provider`. **/
  allProviders: InContextSdkMethod<Query['allProviders'], QueryallProvidersArgs, MeshContext>,
  /** Reads a set of `Provider`. **/
  allProvidersList: InContextSdkMethod<Query['allProvidersList'], QueryallProvidersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Quote`. **/
  allQuotes: InContextSdkMethod<Query['allQuotes'], QueryallQuotesArgs, MeshContext>,
  /** Reads a set of `Quote`. **/
  allQuotesList: InContextSdkMethod<Query['allQuotesList'], QueryallQuotesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Rating`. **/
  allRatings: InContextSdkMethod<Query['allRatings'], QueryallRatingsArgs, MeshContext>,
  /** Reads a set of `Rating`. **/
  allRatingsList: InContextSdkMethod<Query['allRatingsList'], QueryallRatingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Report`. **/
  allReports: InContextSdkMethod<Query['allReports'], QueryallReportsArgs, MeshContext>,
  /** Reads a set of `Report`. **/
  allReportsList: InContextSdkMethod<Query['allReportsList'], QueryallReportsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Return`. **/
  allReturns: InContextSdkMethod<Query['allReturns'], QueryallReturnsArgs, MeshContext>,
  /** Reads a set of `Return`. **/
  allReturnsList: InContextSdkMethod<Query['allReturnsList'], QueryallReturnsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Review`. **/
  allReviews: InContextSdkMethod<Query['allReviews'], QueryallReviewsArgs, MeshContext>,
  /** Reads a set of `Review`. **/
  allReviewsList: InContextSdkMethod<Query['allReviewsList'], QueryallReviewsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Reward`. **/
  allRewards: InContextSdkMethod<Query['allRewards'], QueryallRewardsArgs, MeshContext>,
  /** Reads a set of `Reward`. **/
  allRewardsList: InContextSdkMethod<Query['allRewardsList'], QueryallRewardsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Role`. **/
  allRoles: InContextSdkMethod<Query['allRoles'], QueryallRolesArgs, MeshContext>,
  /** Reads a set of `Role`. **/
  allRolesList: InContextSdkMethod<Query['allRolesList'], QueryallRolesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Scheduler`. **/
  allSchedulers: InContextSdkMethod<Query['allSchedulers'], QueryallSchedulersArgs, MeshContext>,
  /** Reads a set of `Scheduler`. **/
  allSchedulersList: InContextSdkMethod<Query['allSchedulersList'], QueryallSchedulersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Segment`. **/
  allSegments: InContextSdkMethod<Query['allSegments'], QueryallSegmentsArgs, MeshContext>,
  /** Reads a set of `Segment`. **/
  allSegmentsList: InContextSdkMethod<Query['allSegmentsList'], QueryallSegmentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Setting`. **/
  allSettings: InContextSdkMethod<Query['allSettings'], QueryallSettingsArgs, MeshContext>,
  /** Reads a set of `Setting`. **/
  allSettingsList: InContextSdkMethod<Query['allSettingsList'], QueryallSettingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Shipment`. **/
  allShipments: InContextSdkMethod<Query['allShipments'], QueryallShipmentsArgs, MeshContext>,
  /** Reads a set of `Shipment`. **/
  allShipmentsList: InContextSdkMethod<Query['allShipmentsList'], QueryallShipmentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `SpecialDiscount`. **/
  allSpecialDiscounts: InContextSdkMethod<Query['allSpecialDiscounts'], QueryallSpecialDiscountsArgs, MeshContext>,
  /** Reads a set of `SpecialDiscount`. **/
  allSpecialDiscountsList: InContextSdkMethod<Query['allSpecialDiscountsList'], QueryallSpecialDiscountsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `State`. **/
  allStates: InContextSdkMethod<Query['allStates'], QueryallStatesArgs, MeshContext>,
  /** Reads a set of `State`. **/
  allStatesList: InContextSdkMethod<Query['allStatesList'], QueryallStatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Statistic`. **/
  allStatistics: InContextSdkMethod<Query['allStatistics'], QueryallStatisticsArgs, MeshContext>,
  /** Reads a set of `Statistic`. **/
  allStatisticsList: InContextSdkMethod<Query['allStatisticsList'], QueryallStatisticsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Stock`. **/
  allStocks: InContextSdkMethod<Query['allStocks'], QueryallStocksArgs, MeshContext>,
  /** Reads a set of `Stock`. **/
  allStocksList: InContextSdkMethod<Query['allStocksList'], QueryallStocksListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Survey`. **/
  allSurveys: InContextSdkMethod<Query['allSurveys'], QueryallSurveysArgs, MeshContext>,
  /** Reads a set of `Survey`. **/
  allSurveysList: InContextSdkMethod<Query['allSurveysList'], QueryallSurveysListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Tag`. **/
  allTags: InContextSdkMethod<Query['allTags'], QueryallTagsArgs, MeshContext>,
  /** Reads a set of `Tag`. **/
  allTagsList: InContextSdkMethod<Query['allTagsList'], QueryallTagsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Target`. **/
  allTargets: InContextSdkMethod<Query['allTargets'], QueryallTargetsArgs, MeshContext>,
  /** Reads a set of `Target`. **/
  allTargetsList: InContextSdkMethod<Query['allTargetsList'], QueryallTargetsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `TaxCategory`. **/
  allTaxCategories: InContextSdkMethod<Query['allTaxCategories'], QueryallTaxCategoriesArgs, MeshContext>,
  /** Reads a set of `TaxCategory`. **/
  allTaxCategoriesList: InContextSdkMethod<Query['allTaxCategoriesList'], QueryallTaxCategoriesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `TaxRate`. **/
  allTaxRates: InContextSdkMethod<Query['allTaxRates'], QueryallTaxRatesArgs, MeshContext>,
  /** Reads a set of `TaxRate`. **/
  allTaxRatesList: InContextSdkMethod<Query['allTaxRatesList'], QueryallTaxRatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `TaxRule`. **/
  allTaxRules: InContextSdkMethod<Query['allTaxRules'], QueryallTaxRulesArgs, MeshContext>,
  /** Reads a set of `TaxRule`. **/
  allTaxRulesList: InContextSdkMethod<Query['allTaxRulesList'], QueryallTaxRulesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Template`. **/
  allTemplates: InContextSdkMethod<Query['allTemplates'], QueryallTemplatesArgs, MeshContext>,
  /** Reads a set of `Template`. **/
  allTemplatesList: InContextSdkMethod<Query['allTemplatesList'], QueryallTemplatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Theme`. **/
  allThemes: InContextSdkMethod<Query['allThemes'], QueryallThemesArgs, MeshContext>,
  /** Reads a set of `Theme`. **/
  allThemesList: InContextSdkMethod<Query['allThemesList'], QueryallThemesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Ticketing`. **/
  allTicketings: InContextSdkMethod<Query['allTicketings'], QueryallTicketingsArgs, MeshContext>,
  /** Reads a set of `Ticketing`. **/
  allTicketingsList: InContextSdkMethod<Query['allTicketingsList'], QueryallTicketingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Training`. **/
  allTrainings: InContextSdkMethod<Query['allTrainings'], QueryallTrainingsArgs, MeshContext>,
  /** Reads a set of `Training`. **/
  allTrainingsList: InContextSdkMethod<Query['allTrainingsList'], QueryallTrainingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Transaction`. **/
  allTransactions: InContextSdkMethod<Query['allTransactions'], QueryallTransactionsArgs, MeshContext>,
  /** Reads a set of `Transaction`. **/
  allTransactionsList: InContextSdkMethod<Query['allTransactionsList'], QueryallTransactionsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `UploadFile`. **/
  allUploadFiles: InContextSdkMethod<Query['allUploadFiles'], QueryallUploadFilesArgs, MeshContext>,
  /** Reads a set of `UploadFile`. **/
  allUploadFilesList: InContextSdkMethod<Query['allUploadFilesList'], QueryallUploadFilesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `User`. **/
  allUsers: InContextSdkMethod<Query['allUsers'], QueryallUsersArgs, MeshContext>,
  /** Reads a set of `User`. **/
  allUsersList: InContextSdkMethod<Query['allUsersList'], QueryallUsersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Vendor`. **/
  allVendors: InContextSdkMethod<Query['allVendors'], QueryallVendorsArgs, MeshContext>,
  /** Reads a set of `Vendor`. **/
  allVendorsList: InContextSdkMethod<Query['allVendorsList'], QueryallVendorsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Visit`. **/
  allVisits: InContextSdkMethod<Query['allVisits'], QueryallVisitsArgs, MeshContext>,
  /** Reads a set of `Visit`. **/
  allVisitsList: InContextSdkMethod<Query['allVisitsList'], QueryallVisitsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Warehouse`. **/
  allWarehouses: InContextSdkMethod<Query['allWarehouses'], QueryallWarehousesArgs, MeshContext>,
  /** Reads a set of `Warehouse`. **/
  allWarehousesList: InContextSdkMethod<Query['allWarehousesList'], QueryallWarehousesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Webhook`. **/
  allWebhooks: InContextSdkMethod<Query['allWebhooks'], QueryallWebhooksArgs, MeshContext>,
  /** Reads a set of `Webhook`. **/
  allWebhooksList: InContextSdkMethod<Query['allWebhooksList'], QueryallWebhooksListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Website`. **/
  allWebsites: InContextSdkMethod<Query['allWebsites'], QueryallWebsitesArgs, MeshContext>,
  /** Reads a set of `Website`. **/
  allWebsitesList: InContextSdkMethod<Query['allWebsitesList'], QueryallWebsitesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Wishlist`. **/
  allWishlists: InContextSdkMethod<Query['allWishlists'], QueryallWishlistsArgs, MeshContext>,
  /** Reads a set of `Wishlist`. **/
  allWishlistsList: InContextSdkMethod<Query['allWishlistsList'], QueryallWishlistsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Workspace`. **/
  allWorkspaces: InContextSdkMethod<Query['allWorkspaces'], QueryallWorkspacesArgs, MeshContext>,
  /** Reads a set of `Workspace`. **/
  allWorkspacesList: InContextSdkMethod<Query['allWorkspacesList'], QueryallWorkspacesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Zone`. **/
  allZones: InContextSdkMethod<Query['allZones'], QueryallZonesArgs, MeshContext>,
  /** Reads a set of `Zone`. **/
  allZonesList: InContextSdkMethod<Query['allZonesList'], QueryallZonesListArgs, MeshContext>,
  /** undefined **/
  accountById: InContextSdkMethod<Query['accountById'], QueryaccountByIdArgs, MeshContext>,
  /** undefined **/
  agreementById: InContextSdkMethod<Query['agreementById'], QueryagreementByIdArgs, MeshContext>,
  /** undefined **/
  analyticById: InContextSdkMethod<Query['analyticById'], QueryanalyticByIdArgs, MeshContext>,
  /** undefined **/
  apitokenById: InContextSdkMethod<Query['apitokenById'], QueryapitokenByIdArgs, MeshContext>,
  /** undefined **/
  articleById: InContextSdkMethod<Query['articleById'], QueryarticleByIdArgs, MeshContext>,
  /** undefined **/
  attributeById: InContextSdkMethod<Query['attributeById'], QueryattributeByIdArgs, MeshContext>,
  /** undefined **/
  brandById: InContextSdkMethod<Query['brandById'], QuerybrandByIdArgs, MeshContext>,
  /** undefined **/
  cartPriceRuleById: InContextSdkMethod<Query['cartPriceRuleById'], QuerycartPriceRuleByIdArgs, MeshContext>,
  /** undefined **/
  caseById: InContextSdkMethod<Query['caseById'], QuerycaseByIdArgs, MeshContext>,
  /** undefined **/
  catalogPriceRuleById: InContextSdkMethod<Query['catalogPriceRuleById'], QuerycatalogPriceRuleByIdArgs, MeshContext>,
  /** undefined **/
  categoryById: InContextSdkMethod<Query['categoryById'], QuerycategoryByIdArgs, MeshContext>,
  /** undefined **/
  channelById: InContextSdkMethod<Query['channelById'], QuerychannelByIdArgs, MeshContext>,
  /** undefined **/
  checklistById: InContextSdkMethod<Query['checklistById'], QuerychecklistByIdArgs, MeshContext>,
  /** undefined **/
  cityById: InContextSdkMethod<Query['cityById'], QuerycityByIdArgs, MeshContext>,
  /** undefined **/
  collectionById: InContextSdkMethod<Query['collectionById'], QuerycollectionByIdArgs, MeshContext>,
  /** undefined **/
  commentById: InContextSdkMethod<Query['commentById'], QuerycommentByIdArgs, MeshContext>,
  /** undefined **/
  contentTypeById: InContextSdkMethod<Query['contentTypeById'], QuerycontentTypeByIdArgs, MeshContext>,
  /** undefined **/
  contractById: InContextSdkMethod<Query['contractById'], QuerycontractByIdArgs, MeshContext>,
  /** undefined **/
  countryById: InContextSdkMethod<Query['countryById'], QuerycountryByIdArgs, MeshContext>,
  /** undefined **/
  couponById: InContextSdkMethod<Query['couponById'], QuerycouponByIdArgs, MeshContext>,
  /** undefined **/
  creditMemoByCreditMemoAndId: InContextSdkMethod<Query['creditMemoByCreditMemoAndId'], QuerycreditMemoByCreditMemoAndIdArgs, MeshContext>,
  /** undefined **/
  currencyById: InContextSdkMethod<Query['currencyById'], QuerycurrencyByIdArgs, MeshContext>,
  /** undefined **/
  currencyRateByImportService: InContextSdkMethod<Query['currencyRateByImportService'], QuerycurrencyRateByImportServiceArgs, MeshContext>,
  /** undefined **/
  currencySymbolBySymbol: InContextSdkMethod<Query['currencySymbolBySymbol'], QuerycurrencySymbolBySymbolArgs, MeshContext>,
  /** undefined **/
  customerGroupById: InContextSdkMethod<Query['customerGroupById'], QuerycustomerGroupByIdArgs, MeshContext>,
  /** undefined **/
  customerById: InContextSdkMethod<Query['customerById'], QuerycustomerByIdArgs, MeshContext>,
  /** undefined **/
  customizationById: InContextSdkMethod<Query['customizationById'], QuerycustomizationByIdArgs, MeshContext>,
  /** undefined **/
  dashboardById: InContextSdkMethod<Query['dashboardById'], QuerydashboardByIdArgs, MeshContext>,
  /** undefined **/
  deepdiveById: InContextSdkMethod<Query['deepdiveById'], QuerydeepdiveByIdArgs, MeshContext>,
  /** undefined **/
  digiboardById: InContextSdkMethod<Query['digiboardById'], QuerydigiboardByIdArgs, MeshContext>,
  /** undefined **/
  emailById: InContextSdkMethod<Query['emailById'], QueryemailByIdArgs, MeshContext>,
  /** undefined **/
  endofshiftById: InContextSdkMethod<Query['endofshiftById'], QueryendofshiftByIdArgs, MeshContext>,
  /** undefined **/
  eventById: InContextSdkMethod<Query['eventById'], QueryeventByIdArgs, MeshContext>,
  /** undefined **/
  fullfillmentById: InContextSdkMethod<Query['fullfillmentById'], QueryfullfillmentByIdArgs, MeshContext>,
  /** undefined **/
  giftCertificateById: InContextSdkMethod<Query['giftCertificateById'], QuerygiftCertificateByIdArgs, MeshContext>,
  /** undefined **/
  glossaryById: InContextSdkMethod<Query['glossaryById'], QueryglossaryByIdArgs, MeshContext>,
  /** undefined **/
  importmById: InContextSdkMethod<Query['importmById'], QueryimportmByIdArgs, MeshContext>,
  /** undefined **/
  integrationById: InContextSdkMethod<Query['integrationById'], QueryintegrationByIdArgs, MeshContext>,
  /** undefined **/
  internalizationById: InContextSdkMethod<Query['internalizationById'], QueryinternalizationByIdArgs, MeshContext>,
  /** undefined **/
  invitationById: InContextSdkMethod<Query['invitationById'], QueryinvitationByIdArgs, MeshContext>,
  /** undefined **/
  invoiceById: InContextSdkMethod<Query['invoiceById'], QueryinvoiceByIdArgs, MeshContext>,
  /** undefined **/
  leadById: InContextSdkMethod<Query['leadById'], QueryleadByIdArgs, MeshContext>,
  /** undefined **/
  manufacturerById: InContextSdkMethod<Query['manufacturerById'], QuerymanufacturerByIdArgs, MeshContext>,
  /** undefined **/
  mediamanagerById: InContextSdkMethod<Query['mediamanagerById'], QuerymediamanagerByIdArgs, MeshContext>,
  /** undefined **/
  meetingById: InContextSdkMethod<Query['meetingById'], QuerymeetingByIdArgs, MeshContext>,
  /** undefined **/
  messageById: InContextSdkMethod<Query['messageById'], QuerymessageByIdArgs, MeshContext>,
  /** undefined **/
  newsletterById: InContextSdkMethod<Query['newsletterById'], QuerynewsletterByIdArgs, MeshContext>,
  /** undefined **/
  ootoById: InContextSdkMethod<Query['ootoById'], QueryootoByIdArgs, MeshContext>,
  /** undefined **/
  opportunityById: InContextSdkMethod<Query['opportunityById'], QueryopportunityByIdArgs, MeshContext>,
  /** undefined **/
  orderById: InContextSdkMethod<Query['orderById'], QueryorderByIdArgs, MeshContext>,
  /** undefined **/
  pageById: InContextSdkMethod<Query['pageById'], QuerypageByIdArgs, MeshContext>,
  /** undefined **/
  partnerById: InContextSdkMethod<Query['partnerById'], QuerypartnerByIdArgs, MeshContext>,
  /** undefined **/
  paymentById: InContextSdkMethod<Query['paymentById'], QuerypaymentByIdArgs, MeshContext>,
  /** undefined **/
  permissionById: InContextSdkMethod<Query['permissionById'], QuerypermissionByIdArgs, MeshContext>,
  /** undefined **/
  pluginById: InContextSdkMethod<Query['pluginById'], QuerypluginByIdArgs, MeshContext>,
  /** undefined **/
  pollById: InContextSdkMethod<Query['pollById'], QuerypollByIdArgs, MeshContext>,
  /** undefined **/
  productTypeById: InContextSdkMethod<Query['productTypeById'], QueryproductTypeByIdArgs, MeshContext>,
  /** undefined **/
  productById: InContextSdkMethod<Query['productById'], QueryproductByIdArgs, MeshContext>,
  /** undefined **/
  projectById: InContextSdkMethod<Query['projectById'], QueryprojectByIdArgs, MeshContext>,
  /** undefined **/
  providerById: InContextSdkMethod<Query['providerById'], QueryproviderByIdArgs, MeshContext>,
  /** undefined **/
  quoteById: InContextSdkMethod<Query['quoteById'], QueryquoteByIdArgs, MeshContext>,
  /** undefined **/
  ratingById: InContextSdkMethod<Query['ratingById'], QueryratingByIdArgs, MeshContext>,
  /** undefined **/
  reportById: InContextSdkMethod<Query['reportById'], QueryreportByIdArgs, MeshContext>,
  /** undefined **/
  returnById: InContextSdkMethod<Query['returnById'], QueryreturnByIdArgs, MeshContext>,
  /** undefined **/
  reviewById: InContextSdkMethod<Query['reviewById'], QueryreviewByIdArgs, MeshContext>,
  /** undefined **/
  rewardById: InContextSdkMethod<Query['rewardById'], QueryrewardByIdArgs, MeshContext>,
  /** undefined **/
  roleById: InContextSdkMethod<Query['roleById'], QueryroleByIdArgs, MeshContext>,
  /** undefined **/
  schedulerById: InContextSdkMethod<Query['schedulerById'], QueryschedulerByIdArgs, MeshContext>,
  /** undefined **/
  segmentById: InContextSdkMethod<Query['segmentById'], QuerysegmentByIdArgs, MeshContext>,
  /** undefined **/
  settingById: InContextSdkMethod<Query['settingById'], QuerysettingByIdArgs, MeshContext>,
  /** undefined **/
  shipmentById: InContextSdkMethod<Query['shipmentById'], QueryshipmentByIdArgs, MeshContext>,
  /** undefined **/
  specialDiscountById: InContextSdkMethod<Query['specialDiscountById'], QueryspecialDiscountByIdArgs, MeshContext>,
  /** undefined **/
  stateById: InContextSdkMethod<Query['stateById'], QuerystateByIdArgs, MeshContext>,
  /** undefined **/
  statisticById: InContextSdkMethod<Query['statisticById'], QuerystatisticByIdArgs, MeshContext>,
  /** undefined **/
  stockById: InContextSdkMethod<Query['stockById'], QuerystockByIdArgs, MeshContext>,
  /** undefined **/
  surveyById: InContextSdkMethod<Query['surveyById'], QuerysurveyByIdArgs, MeshContext>,
  /** undefined **/
  tagById: InContextSdkMethod<Query['tagById'], QuerytagByIdArgs, MeshContext>,
  /** undefined **/
  targetById: InContextSdkMethod<Query['targetById'], QuerytargetByIdArgs, MeshContext>,
  /** undefined **/
  taxCategoryById: InContextSdkMethod<Query['taxCategoryById'], QuerytaxCategoryByIdArgs, MeshContext>,
  /** undefined **/
  taxRateById: InContextSdkMethod<Query['taxRateById'], QuerytaxRateByIdArgs, MeshContext>,
  /** undefined **/
  taxRuleById: InContextSdkMethod<Query['taxRuleById'], QuerytaxRuleByIdArgs, MeshContext>,
  /** undefined **/
  templateById: InContextSdkMethod<Query['templateById'], QuerytemplateByIdArgs, MeshContext>,
  /** undefined **/
  themeById: InContextSdkMethod<Query['themeById'], QuerythemeByIdArgs, MeshContext>,
  /** undefined **/
  ticketingById: InContextSdkMethod<Query['ticketingById'], QueryticketingByIdArgs, MeshContext>,
  /** undefined **/
  trainingById: InContextSdkMethod<Query['trainingById'], QuerytrainingByIdArgs, MeshContext>,
  /** undefined **/
  transactionById: InContextSdkMethod<Query['transactionById'], QuerytransactionByIdArgs, MeshContext>,
  /** undefined **/
  uploadFileById: InContextSdkMethod<Query['uploadFileById'], QueryuploadFileByIdArgs, MeshContext>,
  /** undefined **/
  userById: InContextSdkMethod<Query['userById'], QueryuserByIdArgs, MeshContext>,
  /** undefined **/
  vendorById: InContextSdkMethod<Query['vendorById'], QueryvendorByIdArgs, MeshContext>,
  /** undefined **/
  visitById: InContextSdkMethod<Query['visitById'], QueryvisitByIdArgs, MeshContext>,
  /** undefined **/
  warehouseById: InContextSdkMethod<Query['warehouseById'], QuerywarehouseByIdArgs, MeshContext>,
  /** undefined **/
  webhookById: InContextSdkMethod<Query['webhookById'], QuerywebhookByIdArgs, MeshContext>,
  /** undefined **/
  websiteById: InContextSdkMethod<Query['websiteById'], QuerywebsiteByIdArgs, MeshContext>,
  /** undefined **/
  wishlistById: InContextSdkMethod<Query['wishlistById'], QuerywishlistByIdArgs, MeshContext>,
  /** undefined **/
  workspaceById: InContextSdkMethod<Query['workspaceById'], QueryworkspaceByIdArgs, MeshContext>,
  /** undefined **/
  zoneById: InContextSdkMethod<Query['zoneById'], QueryzoneByIdArgs, MeshContext>,
  /** Reads a single `Account` using its globally unique `ID`. **/
  account: InContextSdkMethod<Query['account'], QueryaccountArgs, MeshContext>,
  /** Reads a single `Agreement` using its globally unique `ID`. **/
  agreement: InContextSdkMethod<Query['agreement'], QueryagreementArgs, MeshContext>,
  /** Reads a single `Analytic` using its globally unique `ID`. **/
  analytic: InContextSdkMethod<Query['analytic'], QueryanalyticArgs, MeshContext>,
  /** Reads a single `Apitoken` using its globally unique `ID`. **/
  apitoken: InContextSdkMethod<Query['apitoken'], QueryapitokenArgs, MeshContext>,
  /** Reads a single `Article` using its globally unique `ID`. **/
  article: InContextSdkMethod<Query['article'], QueryarticleArgs, MeshContext>,
  /** Reads a single `Attribute` using its globally unique `ID`. **/
  attribute: InContextSdkMethod<Query['attribute'], QueryattributeArgs, MeshContext>,
  /** Reads a single `Brand` using its globally unique `ID`. **/
  brand: InContextSdkMethod<Query['brand'], QuerybrandArgs, MeshContext>,
  /** Reads a single `CartPriceRule` using its globally unique `ID`. **/
  cartPriceRule: InContextSdkMethod<Query['cartPriceRule'], QuerycartPriceRuleArgs, MeshContext>,
  /** Reads a single `Case` using its globally unique `ID`. **/
  case: InContextSdkMethod<Query['case'], QuerycaseArgs, MeshContext>,
  /** Reads a single `CatalogPriceRule` using its globally unique `ID`. **/
  catalogPriceRule: InContextSdkMethod<Query['catalogPriceRule'], QuerycatalogPriceRuleArgs, MeshContext>,
  /** Reads a single `Category` using its globally unique `ID`. **/
  category: InContextSdkMethod<Query['category'], QuerycategoryArgs, MeshContext>,
  /** Reads a single `Channel` using its globally unique `ID`. **/
  channel: InContextSdkMethod<Query['channel'], QuerychannelArgs, MeshContext>,
  /** Reads a single `Checklist` using its globally unique `ID`. **/
  checklist: InContextSdkMethod<Query['checklist'], QuerychecklistArgs, MeshContext>,
  /** Reads a single `City` using its globally unique `ID`. **/
  city: InContextSdkMethod<Query['city'], QuerycityArgs, MeshContext>,
  /** Reads a single `Collection` using its globally unique `ID`. **/
  collection: InContextSdkMethod<Query['collection'], QuerycollectionArgs, MeshContext>,
  /** Reads a single `Comment` using its globally unique `ID`. **/
  comment: InContextSdkMethod<Query['comment'], QuerycommentArgs, MeshContext>,
  /** Reads a single `ContentType` using its globally unique `ID`. **/
  contentType: InContextSdkMethod<Query['contentType'], QuerycontentTypeArgs, MeshContext>,
  /** Reads a single `Contract` using its globally unique `ID`. **/
  contract: InContextSdkMethod<Query['contract'], QuerycontractArgs, MeshContext>,
  /** Reads a single `Country` using its globally unique `ID`. **/
  country: InContextSdkMethod<Query['country'], QuerycountryArgs, MeshContext>,
  /** Reads a single `Coupon` using its globally unique `ID`. **/
  coupon: InContextSdkMethod<Query['coupon'], QuerycouponArgs, MeshContext>,
  /** Reads a single `CreditMemo` using its globally unique `ID`. **/
  creditMemo: InContextSdkMethod<Query['creditMemo'], QuerycreditMemoArgs, MeshContext>,
  /** Reads a single `Currency` using its globally unique `ID`. **/
  currency: InContextSdkMethod<Query['currency'], QuerycurrencyArgs, MeshContext>,
  /** Reads a single `CurrencyRate` using its globally unique `ID`. **/
  currencyRate: InContextSdkMethod<Query['currencyRate'], QuerycurrencyRateArgs, MeshContext>,
  /** Reads a single `CurrencySymbol` using its globally unique `ID`. **/
  currencySymbol: InContextSdkMethod<Query['currencySymbol'], QuerycurrencySymbolArgs, MeshContext>,
  /** Reads a single `CustomerGroup` using its globally unique `ID`. **/
  customerGroup: InContextSdkMethod<Query['customerGroup'], QuerycustomerGroupArgs, MeshContext>,
  /** Reads a single `Customer` using its globally unique `ID`. **/
  customer: InContextSdkMethod<Query['customer'], QuerycustomerArgs, MeshContext>,
  /** Reads a single `Customization` using its globally unique `ID`. **/
  customization: InContextSdkMethod<Query['customization'], QuerycustomizationArgs, MeshContext>,
  /** Reads a single `Dashboard` using its globally unique `ID`. **/
  dashboard: InContextSdkMethod<Query['dashboard'], QuerydashboardArgs, MeshContext>,
  /** Reads a single `Deepdive` using its globally unique `ID`. **/
  deepdive: InContextSdkMethod<Query['deepdive'], QuerydeepdiveArgs, MeshContext>,
  /** Reads a single `Digiboard` using its globally unique `ID`. **/
  digiboard: InContextSdkMethod<Query['digiboard'], QuerydigiboardArgs, MeshContext>,
  /** Reads a single `Email` using its globally unique `ID`. **/
  email: InContextSdkMethod<Query['email'], QueryemailArgs, MeshContext>,
  /** Reads a single `Endofshift` using its globally unique `ID`. **/
  endofshift: InContextSdkMethod<Query['endofshift'], QueryendofshiftArgs, MeshContext>,
  /** Reads a single `Event` using its globally unique `ID`. **/
  event: InContextSdkMethod<Query['event'], QueryeventArgs, MeshContext>,
  /** Reads a single `Fullfillment` using its globally unique `ID`. **/
  fullfillment: InContextSdkMethod<Query['fullfillment'], QueryfullfillmentArgs, MeshContext>,
  /** Reads a single `GiftCertificate` using its globally unique `ID`. **/
  giftCertificate: InContextSdkMethod<Query['giftCertificate'], QuerygiftCertificateArgs, MeshContext>,
  /** Reads a single `Glossary` using its globally unique `ID`. **/
  glossary: InContextSdkMethod<Query['glossary'], QueryglossaryArgs, MeshContext>,
  /** Reads a single `Importm` using its globally unique `ID`. **/
  importm: InContextSdkMethod<Query['importm'], QueryimportmArgs, MeshContext>,
  /** Reads a single `Integration` using its globally unique `ID`. **/
  integration: InContextSdkMethod<Query['integration'], QueryintegrationArgs, MeshContext>,
  /** Reads a single `Internalization` using its globally unique `ID`. **/
  internalization: InContextSdkMethod<Query['internalization'], QueryinternalizationArgs, MeshContext>,
  /** Reads a single `Invitation` using its globally unique `ID`. **/
  invitation: InContextSdkMethod<Query['invitation'], QueryinvitationArgs, MeshContext>,
  /** Reads a single `Invoice` using its globally unique `ID`. **/
  invoice: InContextSdkMethod<Query['invoice'], QueryinvoiceArgs, MeshContext>,
  /** Reads a single `Lead` using its globally unique `ID`. **/
  lead: InContextSdkMethod<Query['lead'], QueryleadArgs, MeshContext>,
  /** Reads a single `Manufacturer` using its globally unique `ID`. **/
  manufacturer: InContextSdkMethod<Query['manufacturer'], QuerymanufacturerArgs, MeshContext>,
  /** Reads a single `Mediamanager` using its globally unique `ID`. **/
  mediamanager: InContextSdkMethod<Query['mediamanager'], QuerymediamanagerArgs, MeshContext>,
  /** Reads a single `Meeting` using its globally unique `ID`. **/
  meeting: InContextSdkMethod<Query['meeting'], QuerymeetingArgs, MeshContext>,
  /** Reads a single `Message` using its globally unique `ID`. **/
  message: InContextSdkMethod<Query['message'], QuerymessageArgs, MeshContext>,
  /** Reads a single `Newsletter` using its globally unique `ID`. **/
  newsletter: InContextSdkMethod<Query['newsletter'], QuerynewsletterArgs, MeshContext>,
  /** Reads a single `Ooto` using its globally unique `ID`. **/
  ooto: InContextSdkMethod<Query['ooto'], QueryootoArgs, MeshContext>,
  /** Reads a single `Opportunity` using its globally unique `ID`. **/
  opportunity: InContextSdkMethod<Query['opportunity'], QueryopportunityArgs, MeshContext>,
  /** Reads a single `Order` using its globally unique `ID`. **/
  order: InContextSdkMethod<Query['order'], QueryorderArgs, MeshContext>,
  /** Reads a single `Page` using its globally unique `ID`. **/
  page: InContextSdkMethod<Query['page'], QuerypageArgs, MeshContext>,
  /** Reads a single `Partner` using its globally unique `ID`. **/
  partner: InContextSdkMethod<Query['partner'], QuerypartnerArgs, MeshContext>,
  /** Reads a single `Payment` using its globally unique `ID`. **/
  payment: InContextSdkMethod<Query['payment'], QuerypaymentArgs, MeshContext>,
  /** Reads a single `Permission` using its globally unique `ID`. **/
  permission: InContextSdkMethod<Query['permission'], QuerypermissionArgs, MeshContext>,
  /** Reads a single `Plugin` using its globally unique `ID`. **/
  plugin: InContextSdkMethod<Query['plugin'], QuerypluginArgs, MeshContext>,
  /** Reads a single `Poll` using its globally unique `ID`. **/
  poll: InContextSdkMethod<Query['poll'], QuerypollArgs, MeshContext>,
  /** Reads a single `ProductType` using its globally unique `ID`. **/
  productType: InContextSdkMethod<Query['productType'], QueryproductTypeArgs, MeshContext>,
  /** Reads a single `Product` using its globally unique `ID`. **/
  product: InContextSdkMethod<Query['product'], QueryproductArgs, MeshContext>,
  /** Reads a single `Project` using its globally unique `ID`. **/
  project: InContextSdkMethod<Query['project'], QueryprojectArgs, MeshContext>,
  /** Reads a single `Provider` using its globally unique `ID`. **/
  provider: InContextSdkMethod<Query['provider'], QueryproviderArgs, MeshContext>,
  /** Reads a single `Quote` using its globally unique `ID`. **/
  quote: InContextSdkMethod<Query['quote'], QueryquoteArgs, MeshContext>,
  /** Reads a single `Rating` using its globally unique `ID`. **/
  rating: InContextSdkMethod<Query['rating'], QueryratingArgs, MeshContext>,
  /** Reads a single `Report` using its globally unique `ID`. **/
  report: InContextSdkMethod<Query['report'], QueryreportArgs, MeshContext>,
  /** Reads a single `Return` using its globally unique `ID`. **/
  return: InContextSdkMethod<Query['return'], QueryreturnArgs, MeshContext>,
  /** Reads a single `Review` using its globally unique `ID`. **/
  review: InContextSdkMethod<Query['review'], QueryreviewArgs, MeshContext>,
  /** Reads a single `Reward` using its globally unique `ID`. **/
  reward: InContextSdkMethod<Query['reward'], QueryrewardArgs, MeshContext>,
  /** Reads a single `Role` using its globally unique `ID`. **/
  role: InContextSdkMethod<Query['role'], QueryroleArgs, MeshContext>,
  /** Reads a single `Scheduler` using its globally unique `ID`. **/
  scheduler: InContextSdkMethod<Query['scheduler'], QueryschedulerArgs, MeshContext>,
  /** Reads a single `Segment` using its globally unique `ID`. **/
  segment: InContextSdkMethod<Query['segment'], QuerysegmentArgs, MeshContext>,
  /** Reads a single `Setting` using its globally unique `ID`. **/
  setting: InContextSdkMethod<Query['setting'], QuerysettingArgs, MeshContext>,
  /** Reads a single `Shipment` using its globally unique `ID`. **/
  shipment: InContextSdkMethod<Query['shipment'], QueryshipmentArgs, MeshContext>,
  /** Reads a single `SpecialDiscount` using its globally unique `ID`. **/
  specialDiscount: InContextSdkMethod<Query['specialDiscount'], QueryspecialDiscountArgs, MeshContext>,
  /** Reads a single `State` using its globally unique `ID`. **/
  state: InContextSdkMethod<Query['state'], QuerystateArgs, MeshContext>,
  /** Reads a single `Statistic` using its globally unique `ID`. **/
  statistic: InContextSdkMethod<Query['statistic'], QuerystatisticArgs, MeshContext>,
  /** Reads a single `Stock` using its globally unique `ID`. **/
  stock: InContextSdkMethod<Query['stock'], QuerystockArgs, MeshContext>,
  /** Reads a single `Survey` using its globally unique `ID`. **/
  survey: InContextSdkMethod<Query['survey'], QuerysurveyArgs, MeshContext>,
  /** Reads a single `Tag` using its globally unique `ID`. **/
  tag: InContextSdkMethod<Query['tag'], QuerytagArgs, MeshContext>,
  /** Reads a single `Target` using its globally unique `ID`. **/
  target: InContextSdkMethod<Query['target'], QuerytargetArgs, MeshContext>,
  /** Reads a single `TaxCategory` using its globally unique `ID`. **/
  taxCategory: InContextSdkMethod<Query['taxCategory'], QuerytaxCategoryArgs, MeshContext>,
  /** Reads a single `TaxRate` using its globally unique `ID`. **/
  taxRate: InContextSdkMethod<Query['taxRate'], QuerytaxRateArgs, MeshContext>,
  /** Reads a single `TaxRule` using its globally unique `ID`. **/
  taxRule: InContextSdkMethod<Query['taxRule'], QuerytaxRuleArgs, MeshContext>,
  /** Reads a single `Template` using its globally unique `ID`. **/
  template: InContextSdkMethod<Query['template'], QuerytemplateArgs, MeshContext>,
  /** Reads a single `Theme` using its globally unique `ID`. **/
  theme: InContextSdkMethod<Query['theme'], QuerythemeArgs, MeshContext>,
  /** Reads a single `Ticketing` using its globally unique `ID`. **/
  ticketing: InContextSdkMethod<Query['ticketing'], QueryticketingArgs, MeshContext>,
  /** Reads a single `Training` using its globally unique `ID`. **/
  training: InContextSdkMethod<Query['training'], QuerytrainingArgs, MeshContext>,
  /** Reads a single `Transaction` using its globally unique `ID`. **/
  transaction: InContextSdkMethod<Query['transaction'], QuerytransactionArgs, MeshContext>,
  /** Reads a single `UploadFile` using its globally unique `ID`. **/
  uploadFile: InContextSdkMethod<Query['uploadFile'], QueryuploadFileArgs, MeshContext>,
  /** Reads a single `User` using its globally unique `ID`. **/
  user: InContextSdkMethod<Query['user'], QueryuserArgs, MeshContext>,
  /** Reads a single `Vendor` using its globally unique `ID`. **/
  vendor: InContextSdkMethod<Query['vendor'], QueryvendorArgs, MeshContext>,
  /** Reads a single `Visit` using its globally unique `ID`. **/
  visit: InContextSdkMethod<Query['visit'], QueryvisitArgs, MeshContext>,
  /** Reads a single `Warehouse` using its globally unique `ID`. **/
  warehouse: InContextSdkMethod<Query['warehouse'], QuerywarehouseArgs, MeshContext>,
  /** Reads a single `Webhook` using its globally unique `ID`. **/
  webhook: InContextSdkMethod<Query['webhook'], QuerywebhookArgs, MeshContext>,
  /** Reads a single `Website` using its globally unique `ID`. **/
  website: InContextSdkMethod<Query['website'], QuerywebsiteArgs, MeshContext>,
  /** Reads a single `Wishlist` using its globally unique `ID`. **/
  wishlist: InContextSdkMethod<Query['wishlist'], QuerywishlistArgs, MeshContext>,
  /** Reads a single `Workspace` using its globally unique `ID`. **/
  workspace: InContextSdkMethod<Query['workspace'], QueryworkspaceArgs, MeshContext>,
  /** Reads a single `Zone` using its globally unique `ID`. **/
  zone: InContextSdkMethod<Query['zone'], QueryzoneArgs, MeshContext>
  };

  export type MutationSdk = {
      /** Creates a single `Account`. **/
  createAccount: InContextSdkMethod<Mutation['createAccount'], MutationcreateAccountArgs, MeshContext>,
  /** Creates a single `Agreement`. **/
  createAgreement: InContextSdkMethod<Mutation['createAgreement'], MutationcreateAgreementArgs, MeshContext>,
  /** Creates a single `Analytic`. **/
  createAnalytic: InContextSdkMethod<Mutation['createAnalytic'], MutationcreateAnalyticArgs, MeshContext>,
  /** Creates a single `Apitoken`. **/
  createApitoken: InContextSdkMethod<Mutation['createApitoken'], MutationcreateApitokenArgs, MeshContext>,
  /** Creates a single `Article`. **/
  createArticle: InContextSdkMethod<Mutation['createArticle'], MutationcreateArticleArgs, MeshContext>,
  /** Creates a single `Attribute`. **/
  createAttribute: InContextSdkMethod<Mutation['createAttribute'], MutationcreateAttributeArgs, MeshContext>,
  /** Creates a single `Brand`. **/
  createBrand: InContextSdkMethod<Mutation['createBrand'], MutationcreateBrandArgs, MeshContext>,
  /** Creates a single `CartPriceRule`. **/
  createCartPriceRule: InContextSdkMethod<Mutation['createCartPriceRule'], MutationcreateCartPriceRuleArgs, MeshContext>,
  /** Creates a single `Case`. **/
  createCase: InContextSdkMethod<Mutation['createCase'], MutationcreateCaseArgs, MeshContext>,
  /** Creates a single `CatalogPriceRule`. **/
  createCatalogPriceRule: InContextSdkMethod<Mutation['createCatalogPriceRule'], MutationcreateCatalogPriceRuleArgs, MeshContext>,
  /** Creates a single `Category`. **/
  createCategory: InContextSdkMethod<Mutation['createCategory'], MutationcreateCategoryArgs, MeshContext>,
  /** Creates a single `Channel`. **/
  createChannel: InContextSdkMethod<Mutation['createChannel'], MutationcreateChannelArgs, MeshContext>,
  /** Creates a single `Checklist`. **/
  createChecklist: InContextSdkMethod<Mutation['createChecklist'], MutationcreateChecklistArgs, MeshContext>,
  /** Creates a single `City`. **/
  createCity: InContextSdkMethod<Mutation['createCity'], MutationcreateCityArgs, MeshContext>,
  /** Creates a single `Collection`. **/
  createCollection: InContextSdkMethod<Mutation['createCollection'], MutationcreateCollectionArgs, MeshContext>,
  /** Creates a single `Comment`. **/
  createComment: InContextSdkMethod<Mutation['createComment'], MutationcreateCommentArgs, MeshContext>,
  /** Creates a single `ContentType`. **/
  createContentType: InContextSdkMethod<Mutation['createContentType'], MutationcreateContentTypeArgs, MeshContext>,
  /** Creates a single `Contract`. **/
  createContract: InContextSdkMethod<Mutation['createContract'], MutationcreateContractArgs, MeshContext>,
  /** Creates a single `Country`. **/
  createCountry: InContextSdkMethod<Mutation['createCountry'], MutationcreateCountryArgs, MeshContext>,
  /** Creates a single `Coupon`. **/
  createCoupon: InContextSdkMethod<Mutation['createCoupon'], MutationcreateCouponArgs, MeshContext>,
  /** Creates a single `CreditMemo`. **/
  createCreditMemo: InContextSdkMethod<Mutation['createCreditMemo'], MutationcreateCreditMemoArgs, MeshContext>,
  /** Creates a single `Currency`. **/
  createCurrency: InContextSdkMethod<Mutation['createCurrency'], MutationcreateCurrencyArgs, MeshContext>,
  /** Creates a single `CurrencyRate`. **/
  createCurrencyRate: InContextSdkMethod<Mutation['createCurrencyRate'], MutationcreateCurrencyRateArgs, MeshContext>,
  /** Creates a single `CurrencySymbol`. **/
  createCurrencySymbol: InContextSdkMethod<Mutation['createCurrencySymbol'], MutationcreateCurrencySymbolArgs, MeshContext>,
  /** Creates a single `CustomerGroup`. **/
  createCustomerGroup: InContextSdkMethod<Mutation['createCustomerGroup'], MutationcreateCustomerGroupArgs, MeshContext>,
  /** Creates a single `Customer`. **/
  createCustomer: InContextSdkMethod<Mutation['createCustomer'], MutationcreateCustomerArgs, MeshContext>,
  /** Creates a single `Customization`. **/
  createCustomization: InContextSdkMethod<Mutation['createCustomization'], MutationcreateCustomizationArgs, MeshContext>,
  /** Creates a single `Dashboard`. **/
  createDashboard: InContextSdkMethod<Mutation['createDashboard'], MutationcreateDashboardArgs, MeshContext>,
  /** Creates a single `Deepdive`. **/
  createDeepdive: InContextSdkMethod<Mutation['createDeepdive'], MutationcreateDeepdiveArgs, MeshContext>,
  /** Creates a single `Digiboard`. **/
  createDigiboard: InContextSdkMethod<Mutation['createDigiboard'], MutationcreateDigiboardArgs, MeshContext>,
  /** Creates a single `Email`. **/
  createEmail: InContextSdkMethod<Mutation['createEmail'], MutationcreateEmailArgs, MeshContext>,
  /** Creates a single `Endofshift`. **/
  createEndofshift: InContextSdkMethod<Mutation['createEndofshift'], MutationcreateEndofshiftArgs, MeshContext>,
  /** Creates a single `Event`. **/
  createEvent: InContextSdkMethod<Mutation['createEvent'], MutationcreateEventArgs, MeshContext>,
  /** Creates a single `Fullfillment`. **/
  createFullfillment: InContextSdkMethod<Mutation['createFullfillment'], MutationcreateFullfillmentArgs, MeshContext>,
  /** Creates a single `GiftCertificate`. **/
  createGiftCertificate: InContextSdkMethod<Mutation['createGiftCertificate'], MutationcreateGiftCertificateArgs, MeshContext>,
  /** Creates a single `Glossary`. **/
  createGlossary: InContextSdkMethod<Mutation['createGlossary'], MutationcreateGlossaryArgs, MeshContext>,
  /** Creates a single `Importm`. **/
  createImportm: InContextSdkMethod<Mutation['createImportm'], MutationcreateImportmArgs, MeshContext>,
  /** Creates a single `Integration`. **/
  createIntegration: InContextSdkMethod<Mutation['createIntegration'], MutationcreateIntegrationArgs, MeshContext>,
  /** Creates a single `Internalization`. **/
  createInternalization: InContextSdkMethod<Mutation['createInternalization'], MutationcreateInternalizationArgs, MeshContext>,
  /** Creates a single `Invitation`. **/
  createInvitation: InContextSdkMethod<Mutation['createInvitation'], MutationcreateInvitationArgs, MeshContext>,
  /** Creates a single `Invoice`. **/
  createInvoice: InContextSdkMethod<Mutation['createInvoice'], MutationcreateInvoiceArgs, MeshContext>,
  /** Creates a single `Lead`. **/
  createLead: InContextSdkMethod<Mutation['createLead'], MutationcreateLeadArgs, MeshContext>,
  /** Creates a single `Manufacturer`. **/
  createManufacturer: InContextSdkMethod<Mutation['createManufacturer'], MutationcreateManufacturerArgs, MeshContext>,
  /** Creates a single `Mediamanager`. **/
  createMediamanager: InContextSdkMethod<Mutation['createMediamanager'], MutationcreateMediamanagerArgs, MeshContext>,
  /** Creates a single `Meeting`. **/
  createMeeting: InContextSdkMethod<Mutation['createMeeting'], MutationcreateMeetingArgs, MeshContext>,
  /** Creates a single `Message`. **/
  createMessage: InContextSdkMethod<Mutation['createMessage'], MutationcreateMessageArgs, MeshContext>,
  /** Creates a single `Newsletter`. **/
  createNewsletter: InContextSdkMethod<Mutation['createNewsletter'], MutationcreateNewsletterArgs, MeshContext>,
  /** Creates a single `Ooto`. **/
  createOoto: InContextSdkMethod<Mutation['createOoto'], MutationcreateOotoArgs, MeshContext>,
  /** Creates a single `Opportunity`. **/
  createOpportunity: InContextSdkMethod<Mutation['createOpportunity'], MutationcreateOpportunityArgs, MeshContext>,
  /** Creates a single `Order`. **/
  createOrder: InContextSdkMethod<Mutation['createOrder'], MutationcreateOrderArgs, MeshContext>,
  /** Creates a single `Page`. **/
  createPage: InContextSdkMethod<Mutation['createPage'], MutationcreatePageArgs, MeshContext>,
  /** Creates a single `Partner`. **/
  createPartner: InContextSdkMethod<Mutation['createPartner'], MutationcreatePartnerArgs, MeshContext>,
  /** Creates a single `Payment`. **/
  createPayment: InContextSdkMethod<Mutation['createPayment'], MutationcreatePaymentArgs, MeshContext>,
  /** Creates a single `Permission`. **/
  createPermission: InContextSdkMethod<Mutation['createPermission'], MutationcreatePermissionArgs, MeshContext>,
  /** Creates a single `Plugin`. **/
  createPlugin: InContextSdkMethod<Mutation['createPlugin'], MutationcreatePluginArgs, MeshContext>,
  /** Creates a single `Poll`. **/
  createPoll: InContextSdkMethod<Mutation['createPoll'], MutationcreatePollArgs, MeshContext>,
  /** Creates a single `ProductType`. **/
  createProductType: InContextSdkMethod<Mutation['createProductType'], MutationcreateProductTypeArgs, MeshContext>,
  /** Creates a single `Product`. **/
  createProduct: InContextSdkMethod<Mutation['createProduct'], MutationcreateProductArgs, MeshContext>,
  /** Creates a single `Project`. **/
  createProject: InContextSdkMethod<Mutation['createProject'], MutationcreateProjectArgs, MeshContext>,
  /** Creates a single `Provider`. **/
  createProvider: InContextSdkMethod<Mutation['createProvider'], MutationcreateProviderArgs, MeshContext>,
  /** Creates a single `Quote`. **/
  createQuote: InContextSdkMethod<Mutation['createQuote'], MutationcreateQuoteArgs, MeshContext>,
  /** Creates a single `Rating`. **/
  createRating: InContextSdkMethod<Mutation['createRating'], MutationcreateRatingArgs, MeshContext>,
  /** Creates a single `Report`. **/
  createReport: InContextSdkMethod<Mutation['createReport'], MutationcreateReportArgs, MeshContext>,
  /** Creates a single `Return`. **/
  createReturn: InContextSdkMethod<Mutation['createReturn'], MutationcreateReturnArgs, MeshContext>,
  /** Creates a single `Review`. **/
  createReview: InContextSdkMethod<Mutation['createReview'], MutationcreateReviewArgs, MeshContext>,
  /** Creates a single `Reward`. **/
  createReward: InContextSdkMethod<Mutation['createReward'], MutationcreateRewardArgs, MeshContext>,
  /** Creates a single `Role`. **/
  createRole: InContextSdkMethod<Mutation['createRole'], MutationcreateRoleArgs, MeshContext>,
  /** Creates a single `Scheduler`. **/
  createScheduler: InContextSdkMethod<Mutation['createScheduler'], MutationcreateSchedulerArgs, MeshContext>,
  /** Creates a single `Segment`. **/
  createSegment: InContextSdkMethod<Mutation['createSegment'], MutationcreateSegmentArgs, MeshContext>,
  /** Creates a single `Setting`. **/
  createSetting: InContextSdkMethod<Mutation['createSetting'], MutationcreateSettingArgs, MeshContext>,
  /** Creates a single `Shipment`. **/
  createShipment: InContextSdkMethod<Mutation['createShipment'], MutationcreateShipmentArgs, MeshContext>,
  /** Creates a single `SpecialDiscount`. **/
  createSpecialDiscount: InContextSdkMethod<Mutation['createSpecialDiscount'], MutationcreateSpecialDiscountArgs, MeshContext>,
  /** Creates a single `State`. **/
  createState: InContextSdkMethod<Mutation['createState'], MutationcreateStateArgs, MeshContext>,
  /** Creates a single `Statistic`. **/
  createStatistic: InContextSdkMethod<Mutation['createStatistic'], MutationcreateStatisticArgs, MeshContext>,
  /** Creates a single `Stock`. **/
  createStock: InContextSdkMethod<Mutation['createStock'], MutationcreateStockArgs, MeshContext>,
  /** Creates a single `Survey`. **/
  createSurvey: InContextSdkMethod<Mutation['createSurvey'], MutationcreateSurveyArgs, MeshContext>,
  /** Creates a single `Tag`. **/
  createTag: InContextSdkMethod<Mutation['createTag'], MutationcreateTagArgs, MeshContext>,
  /** Creates a single `Target`. **/
  createTarget: InContextSdkMethod<Mutation['createTarget'], MutationcreateTargetArgs, MeshContext>,
  /** Creates a single `TaxCategory`. **/
  createTaxCategory: InContextSdkMethod<Mutation['createTaxCategory'], MutationcreateTaxCategoryArgs, MeshContext>,
  /** Creates a single `TaxRate`. **/
  createTaxRate: InContextSdkMethod<Mutation['createTaxRate'], MutationcreateTaxRateArgs, MeshContext>,
  /** Creates a single `TaxRule`. **/
  createTaxRule: InContextSdkMethod<Mutation['createTaxRule'], MutationcreateTaxRuleArgs, MeshContext>,
  /** Creates a single `Template`. **/
  createTemplate: InContextSdkMethod<Mutation['createTemplate'], MutationcreateTemplateArgs, MeshContext>,
  /** Creates a single `Theme`. **/
  createTheme: InContextSdkMethod<Mutation['createTheme'], MutationcreateThemeArgs, MeshContext>,
  /** Creates a single `Ticketing`. **/
  createTicketing: InContextSdkMethod<Mutation['createTicketing'], MutationcreateTicketingArgs, MeshContext>,
  /** Creates a single `Training`. **/
  createTraining: InContextSdkMethod<Mutation['createTraining'], MutationcreateTrainingArgs, MeshContext>,
  /** Creates a single `Transaction`. **/
  createTransaction: InContextSdkMethod<Mutation['createTransaction'], MutationcreateTransactionArgs, MeshContext>,
  /** Creates a single `UploadFile`. **/
  createUploadFile: InContextSdkMethod<Mutation['createUploadFile'], MutationcreateUploadFileArgs, MeshContext>,
  /** Creates a single `User`. **/
  createUser: InContextSdkMethod<Mutation['createUser'], MutationcreateUserArgs, MeshContext>,
  /** Creates a single `Vendor`. **/
  createVendor: InContextSdkMethod<Mutation['createVendor'], MutationcreateVendorArgs, MeshContext>,
  /** Creates a single `Visit`. **/
  createVisit: InContextSdkMethod<Mutation['createVisit'], MutationcreateVisitArgs, MeshContext>,
  /** Creates a single `Warehouse`. **/
  createWarehouse: InContextSdkMethod<Mutation['createWarehouse'], MutationcreateWarehouseArgs, MeshContext>,
  /** Creates a single `Webhook`. **/
  createWebhook: InContextSdkMethod<Mutation['createWebhook'], MutationcreateWebhookArgs, MeshContext>,
  /** Creates a single `Website`. **/
  createWebsite: InContextSdkMethod<Mutation['createWebsite'], MutationcreateWebsiteArgs, MeshContext>,
  /** Creates a single `Wishlist`. **/
  createWishlist: InContextSdkMethod<Mutation['createWishlist'], MutationcreateWishlistArgs, MeshContext>,
  /** Creates a single `Workspace`. **/
  createWorkspace: InContextSdkMethod<Mutation['createWorkspace'], MutationcreateWorkspaceArgs, MeshContext>,
  /** Creates a single `Zone`. **/
  createZone: InContextSdkMethod<Mutation['createZone'], MutationcreateZoneArgs, MeshContext>,
  /** Updates a single `Account` using its globally unique id and a patch. **/
  updateAccount: InContextSdkMethod<Mutation['updateAccount'], MutationupdateAccountArgs, MeshContext>,
  /** Updates a single `Account` using a unique key and a patch. **/
  updateAccountById: InContextSdkMethod<Mutation['updateAccountById'], MutationupdateAccountByIdArgs, MeshContext>,
  /** Updates a single `Agreement` using its globally unique id and a patch. **/
  updateAgreement: InContextSdkMethod<Mutation['updateAgreement'], MutationupdateAgreementArgs, MeshContext>,
  /** Updates a single `Agreement` using a unique key and a patch. **/
  updateAgreementById: InContextSdkMethod<Mutation['updateAgreementById'], MutationupdateAgreementByIdArgs, MeshContext>,
  /** Updates a single `Analytic` using its globally unique id and a patch. **/
  updateAnalytic: InContextSdkMethod<Mutation['updateAnalytic'], MutationupdateAnalyticArgs, MeshContext>,
  /** Updates a single `Analytic` using a unique key and a patch. **/
  updateAnalyticById: InContextSdkMethod<Mutation['updateAnalyticById'], MutationupdateAnalyticByIdArgs, MeshContext>,
  /** Updates a single `Apitoken` using its globally unique id and a patch. **/
  updateApitoken: InContextSdkMethod<Mutation['updateApitoken'], MutationupdateApitokenArgs, MeshContext>,
  /** Updates a single `Apitoken` using a unique key and a patch. **/
  updateApitokenById: InContextSdkMethod<Mutation['updateApitokenById'], MutationupdateApitokenByIdArgs, MeshContext>,
  /** Updates a single `Article` using its globally unique id and a patch. **/
  updateArticle: InContextSdkMethod<Mutation['updateArticle'], MutationupdateArticleArgs, MeshContext>,
  /** Updates a single `Article` using a unique key and a patch. **/
  updateArticleById: InContextSdkMethod<Mutation['updateArticleById'], MutationupdateArticleByIdArgs, MeshContext>,
  /** Updates a single `Attribute` using its globally unique id and a patch. **/
  updateAttribute: InContextSdkMethod<Mutation['updateAttribute'], MutationupdateAttributeArgs, MeshContext>,
  /** Updates a single `Attribute` using a unique key and a patch. **/
  updateAttributeById: InContextSdkMethod<Mutation['updateAttributeById'], MutationupdateAttributeByIdArgs, MeshContext>,
  /** Updates a single `Brand` using its globally unique id and a patch. **/
  updateBrand: InContextSdkMethod<Mutation['updateBrand'], MutationupdateBrandArgs, MeshContext>,
  /** Updates a single `Brand` using a unique key and a patch. **/
  updateBrandById: InContextSdkMethod<Mutation['updateBrandById'], MutationupdateBrandByIdArgs, MeshContext>,
  /** Updates a single `CartPriceRule` using its globally unique id and a patch. **/
  updateCartPriceRule: InContextSdkMethod<Mutation['updateCartPriceRule'], MutationupdateCartPriceRuleArgs, MeshContext>,
  /** Updates a single `CartPriceRule` using a unique key and a patch. **/
  updateCartPriceRuleById: InContextSdkMethod<Mutation['updateCartPriceRuleById'], MutationupdateCartPriceRuleByIdArgs, MeshContext>,
  /** Updates a single `Case` using its globally unique id and a patch. **/
  updateCase: InContextSdkMethod<Mutation['updateCase'], MutationupdateCaseArgs, MeshContext>,
  /** Updates a single `Case` using a unique key and a patch. **/
  updateCaseById: InContextSdkMethod<Mutation['updateCaseById'], MutationupdateCaseByIdArgs, MeshContext>,
  /** Updates a single `CatalogPriceRule` using its globally unique id and a patch. **/
  updateCatalogPriceRule: InContextSdkMethod<Mutation['updateCatalogPriceRule'], MutationupdateCatalogPriceRuleArgs, MeshContext>,
  /** Updates a single `CatalogPriceRule` using a unique key and a patch. **/
  updateCatalogPriceRuleById: InContextSdkMethod<Mutation['updateCatalogPriceRuleById'], MutationupdateCatalogPriceRuleByIdArgs, MeshContext>,
  /** Updates a single `Category` using its globally unique id and a patch. **/
  updateCategory: InContextSdkMethod<Mutation['updateCategory'], MutationupdateCategoryArgs, MeshContext>,
  /** Updates a single `Category` using a unique key and a patch. **/
  updateCategoryById: InContextSdkMethod<Mutation['updateCategoryById'], MutationupdateCategoryByIdArgs, MeshContext>,
  /** Updates a single `Channel` using its globally unique id and a patch. **/
  updateChannel: InContextSdkMethod<Mutation['updateChannel'], MutationupdateChannelArgs, MeshContext>,
  /** Updates a single `Channel` using a unique key and a patch. **/
  updateChannelById: InContextSdkMethod<Mutation['updateChannelById'], MutationupdateChannelByIdArgs, MeshContext>,
  /** Updates a single `Checklist` using its globally unique id and a patch. **/
  updateChecklist: InContextSdkMethod<Mutation['updateChecklist'], MutationupdateChecklistArgs, MeshContext>,
  /** Updates a single `Checklist` using a unique key and a patch. **/
  updateChecklistById: InContextSdkMethod<Mutation['updateChecklistById'], MutationupdateChecklistByIdArgs, MeshContext>,
  /** Updates a single `City` using its globally unique id and a patch. **/
  updateCity: InContextSdkMethod<Mutation['updateCity'], MutationupdateCityArgs, MeshContext>,
  /** Updates a single `City` using a unique key and a patch. **/
  updateCityById: InContextSdkMethod<Mutation['updateCityById'], MutationupdateCityByIdArgs, MeshContext>,
  /** Updates a single `Collection` using its globally unique id and a patch. **/
  updateCollection: InContextSdkMethod<Mutation['updateCollection'], MutationupdateCollectionArgs, MeshContext>,
  /** Updates a single `Collection` using a unique key and a patch. **/
  updateCollectionById: InContextSdkMethod<Mutation['updateCollectionById'], MutationupdateCollectionByIdArgs, MeshContext>,
  /** Updates a single `Comment` using its globally unique id and a patch. **/
  updateComment: InContextSdkMethod<Mutation['updateComment'], MutationupdateCommentArgs, MeshContext>,
  /** Updates a single `Comment` using a unique key and a patch. **/
  updateCommentById: InContextSdkMethod<Mutation['updateCommentById'], MutationupdateCommentByIdArgs, MeshContext>,
  /** Updates a single `ContentType` using its globally unique id and a patch. **/
  updateContentType: InContextSdkMethod<Mutation['updateContentType'], MutationupdateContentTypeArgs, MeshContext>,
  /** Updates a single `ContentType` using a unique key and a patch. **/
  updateContentTypeById: InContextSdkMethod<Mutation['updateContentTypeById'], MutationupdateContentTypeByIdArgs, MeshContext>,
  /** Updates a single `Contract` using its globally unique id and a patch. **/
  updateContract: InContextSdkMethod<Mutation['updateContract'], MutationupdateContractArgs, MeshContext>,
  /** Updates a single `Contract` using a unique key and a patch. **/
  updateContractById: InContextSdkMethod<Mutation['updateContractById'], MutationupdateContractByIdArgs, MeshContext>,
  /** Updates a single `Country` using its globally unique id and a patch. **/
  updateCountry: InContextSdkMethod<Mutation['updateCountry'], MutationupdateCountryArgs, MeshContext>,
  /** Updates a single `Country` using a unique key and a patch. **/
  updateCountryById: InContextSdkMethod<Mutation['updateCountryById'], MutationupdateCountryByIdArgs, MeshContext>,
  /** Updates a single `Coupon` using its globally unique id and a patch. **/
  updateCoupon: InContextSdkMethod<Mutation['updateCoupon'], MutationupdateCouponArgs, MeshContext>,
  /** Updates a single `Coupon` using a unique key and a patch. **/
  updateCouponById: InContextSdkMethod<Mutation['updateCouponById'], MutationupdateCouponByIdArgs, MeshContext>,
  /** Updates a single `CreditMemo` using its globally unique id and a patch. **/
  updateCreditMemo: InContextSdkMethod<Mutation['updateCreditMemo'], MutationupdateCreditMemoArgs, MeshContext>,
  /** Updates a single `CreditMemo` using a unique key and a patch. **/
  updateCreditMemoByCreditMemoAndId: InContextSdkMethod<Mutation['updateCreditMemoByCreditMemoAndId'], MutationupdateCreditMemoByCreditMemoAndIdArgs, MeshContext>,
  /** Updates a single `Currency` using its globally unique id and a patch. **/
  updateCurrency: InContextSdkMethod<Mutation['updateCurrency'], MutationupdateCurrencyArgs, MeshContext>,
  /** Updates a single `Currency` using a unique key and a patch. **/
  updateCurrencyById: InContextSdkMethod<Mutation['updateCurrencyById'], MutationupdateCurrencyByIdArgs, MeshContext>,
  /** Updates a single `CurrencyRate` using its globally unique id and a patch. **/
  updateCurrencyRate: InContextSdkMethod<Mutation['updateCurrencyRate'], MutationupdateCurrencyRateArgs, MeshContext>,
  /** Updates a single `CurrencyRate` using a unique key and a patch. **/
  updateCurrencyRateByImportService: InContextSdkMethod<Mutation['updateCurrencyRateByImportService'], MutationupdateCurrencyRateByImportServiceArgs, MeshContext>,
  /** Updates a single `CurrencySymbol` using its globally unique id and a patch. **/
  updateCurrencySymbol: InContextSdkMethod<Mutation['updateCurrencySymbol'], MutationupdateCurrencySymbolArgs, MeshContext>,
  /** Updates a single `CurrencySymbol` using a unique key and a patch. **/
  updateCurrencySymbolBySymbol: InContextSdkMethod<Mutation['updateCurrencySymbolBySymbol'], MutationupdateCurrencySymbolBySymbolArgs, MeshContext>,
  /** Updates a single `CustomerGroup` using its globally unique id and a patch. **/
  updateCustomerGroup: InContextSdkMethod<Mutation['updateCustomerGroup'], MutationupdateCustomerGroupArgs, MeshContext>,
  /** Updates a single `CustomerGroup` using a unique key and a patch. **/
  updateCustomerGroupById: InContextSdkMethod<Mutation['updateCustomerGroupById'], MutationupdateCustomerGroupByIdArgs, MeshContext>,
  /** Updates a single `Customer` using its globally unique id and a patch. **/
  updateCustomer: InContextSdkMethod<Mutation['updateCustomer'], MutationupdateCustomerArgs, MeshContext>,
  /** Updates a single `Customer` using a unique key and a patch. **/
  updateCustomerById: InContextSdkMethod<Mutation['updateCustomerById'], MutationupdateCustomerByIdArgs, MeshContext>,
  /** Updates a single `Customization` using its globally unique id and a patch. **/
  updateCustomization: InContextSdkMethod<Mutation['updateCustomization'], MutationupdateCustomizationArgs, MeshContext>,
  /** Updates a single `Customization` using a unique key and a patch. **/
  updateCustomizationById: InContextSdkMethod<Mutation['updateCustomizationById'], MutationupdateCustomizationByIdArgs, MeshContext>,
  /** Updates a single `Dashboard` using its globally unique id and a patch. **/
  updateDashboard: InContextSdkMethod<Mutation['updateDashboard'], MutationupdateDashboardArgs, MeshContext>,
  /** Updates a single `Dashboard` using a unique key and a patch. **/
  updateDashboardById: InContextSdkMethod<Mutation['updateDashboardById'], MutationupdateDashboardByIdArgs, MeshContext>,
  /** Updates a single `Deepdive` using its globally unique id and a patch. **/
  updateDeepdive: InContextSdkMethod<Mutation['updateDeepdive'], MutationupdateDeepdiveArgs, MeshContext>,
  /** Updates a single `Deepdive` using a unique key and a patch. **/
  updateDeepdiveById: InContextSdkMethod<Mutation['updateDeepdiveById'], MutationupdateDeepdiveByIdArgs, MeshContext>,
  /** Updates a single `Digiboard` using its globally unique id and a patch. **/
  updateDigiboard: InContextSdkMethod<Mutation['updateDigiboard'], MutationupdateDigiboardArgs, MeshContext>,
  /** Updates a single `Digiboard` using a unique key and a patch. **/
  updateDigiboardById: InContextSdkMethod<Mutation['updateDigiboardById'], MutationupdateDigiboardByIdArgs, MeshContext>,
  /** Updates a single `Email` using its globally unique id and a patch. **/
  updateEmail: InContextSdkMethod<Mutation['updateEmail'], MutationupdateEmailArgs, MeshContext>,
  /** Updates a single `Email` using a unique key and a patch. **/
  updateEmailById: InContextSdkMethod<Mutation['updateEmailById'], MutationupdateEmailByIdArgs, MeshContext>,
  /** Updates a single `Endofshift` using its globally unique id and a patch. **/
  updateEndofshift: InContextSdkMethod<Mutation['updateEndofshift'], MutationupdateEndofshiftArgs, MeshContext>,
  /** Updates a single `Endofshift` using a unique key and a patch. **/
  updateEndofshiftById: InContextSdkMethod<Mutation['updateEndofshiftById'], MutationupdateEndofshiftByIdArgs, MeshContext>,
  /** Updates a single `Event` using its globally unique id and a patch. **/
  updateEvent: InContextSdkMethod<Mutation['updateEvent'], MutationupdateEventArgs, MeshContext>,
  /** Updates a single `Event` using a unique key and a patch. **/
  updateEventById: InContextSdkMethod<Mutation['updateEventById'], MutationupdateEventByIdArgs, MeshContext>,
  /** Updates a single `Fullfillment` using its globally unique id and a patch. **/
  updateFullfillment: InContextSdkMethod<Mutation['updateFullfillment'], MutationupdateFullfillmentArgs, MeshContext>,
  /** Updates a single `Fullfillment` using a unique key and a patch. **/
  updateFullfillmentById: InContextSdkMethod<Mutation['updateFullfillmentById'], MutationupdateFullfillmentByIdArgs, MeshContext>,
  /** Updates a single `GiftCertificate` using its globally unique id and a patch. **/
  updateGiftCertificate: InContextSdkMethod<Mutation['updateGiftCertificate'], MutationupdateGiftCertificateArgs, MeshContext>,
  /** Updates a single `GiftCertificate` using a unique key and a patch. **/
  updateGiftCertificateById: InContextSdkMethod<Mutation['updateGiftCertificateById'], MutationupdateGiftCertificateByIdArgs, MeshContext>,
  /** Updates a single `Glossary` using its globally unique id and a patch. **/
  updateGlossary: InContextSdkMethod<Mutation['updateGlossary'], MutationupdateGlossaryArgs, MeshContext>,
  /** Updates a single `Glossary` using a unique key and a patch. **/
  updateGlossaryById: InContextSdkMethod<Mutation['updateGlossaryById'], MutationupdateGlossaryByIdArgs, MeshContext>,
  /** Updates a single `Importm` using its globally unique id and a patch. **/
  updateImportm: InContextSdkMethod<Mutation['updateImportm'], MutationupdateImportmArgs, MeshContext>,
  /** Updates a single `Importm` using a unique key and a patch. **/
  updateImportmById: InContextSdkMethod<Mutation['updateImportmById'], MutationupdateImportmByIdArgs, MeshContext>,
  /** Updates a single `Integration` using its globally unique id and a patch. **/
  updateIntegration: InContextSdkMethod<Mutation['updateIntegration'], MutationupdateIntegrationArgs, MeshContext>,
  /** Updates a single `Integration` using a unique key and a patch. **/
  updateIntegrationById: InContextSdkMethod<Mutation['updateIntegrationById'], MutationupdateIntegrationByIdArgs, MeshContext>,
  /** Updates a single `Internalization` using its globally unique id and a patch. **/
  updateInternalization: InContextSdkMethod<Mutation['updateInternalization'], MutationupdateInternalizationArgs, MeshContext>,
  /** Updates a single `Internalization` using a unique key and a patch. **/
  updateInternalizationById: InContextSdkMethod<Mutation['updateInternalizationById'], MutationupdateInternalizationByIdArgs, MeshContext>,
  /** Updates a single `Invitation` using its globally unique id and a patch. **/
  updateInvitation: InContextSdkMethod<Mutation['updateInvitation'], MutationupdateInvitationArgs, MeshContext>,
  /** Updates a single `Invitation` using a unique key and a patch. **/
  updateInvitationById: InContextSdkMethod<Mutation['updateInvitationById'], MutationupdateInvitationByIdArgs, MeshContext>,
  /** Updates a single `Invoice` using its globally unique id and a patch. **/
  updateInvoice: InContextSdkMethod<Mutation['updateInvoice'], MutationupdateInvoiceArgs, MeshContext>,
  /** Updates a single `Invoice` using a unique key and a patch. **/
  updateInvoiceById: InContextSdkMethod<Mutation['updateInvoiceById'], MutationupdateInvoiceByIdArgs, MeshContext>,
  /** Updates a single `Lead` using its globally unique id and a patch. **/
  updateLead: InContextSdkMethod<Mutation['updateLead'], MutationupdateLeadArgs, MeshContext>,
  /** Updates a single `Lead` using a unique key and a patch. **/
  updateLeadById: InContextSdkMethod<Mutation['updateLeadById'], MutationupdateLeadByIdArgs, MeshContext>,
  /** Updates a single `Manufacturer` using its globally unique id and a patch. **/
  updateManufacturer: InContextSdkMethod<Mutation['updateManufacturer'], MutationupdateManufacturerArgs, MeshContext>,
  /** Updates a single `Manufacturer` using a unique key and a patch. **/
  updateManufacturerById: InContextSdkMethod<Mutation['updateManufacturerById'], MutationupdateManufacturerByIdArgs, MeshContext>,
  /** Updates a single `Mediamanager` using its globally unique id and a patch. **/
  updateMediamanager: InContextSdkMethod<Mutation['updateMediamanager'], MutationupdateMediamanagerArgs, MeshContext>,
  /** Updates a single `Mediamanager` using a unique key and a patch. **/
  updateMediamanagerById: InContextSdkMethod<Mutation['updateMediamanagerById'], MutationupdateMediamanagerByIdArgs, MeshContext>,
  /** Updates a single `Meeting` using its globally unique id and a patch. **/
  updateMeeting: InContextSdkMethod<Mutation['updateMeeting'], MutationupdateMeetingArgs, MeshContext>,
  /** Updates a single `Meeting` using a unique key and a patch. **/
  updateMeetingById: InContextSdkMethod<Mutation['updateMeetingById'], MutationupdateMeetingByIdArgs, MeshContext>,
  /** Updates a single `Message` using its globally unique id and a patch. **/
  updateMessage: InContextSdkMethod<Mutation['updateMessage'], MutationupdateMessageArgs, MeshContext>,
  /** Updates a single `Message` using a unique key and a patch. **/
  updateMessageById: InContextSdkMethod<Mutation['updateMessageById'], MutationupdateMessageByIdArgs, MeshContext>,
  /** Updates a single `Newsletter` using its globally unique id and a patch. **/
  updateNewsletter: InContextSdkMethod<Mutation['updateNewsletter'], MutationupdateNewsletterArgs, MeshContext>,
  /** Updates a single `Newsletter` using a unique key and a patch. **/
  updateNewsletterById: InContextSdkMethod<Mutation['updateNewsletterById'], MutationupdateNewsletterByIdArgs, MeshContext>,
  /** Updates a single `Ooto` using its globally unique id and a patch. **/
  updateOoto: InContextSdkMethod<Mutation['updateOoto'], MutationupdateOotoArgs, MeshContext>,
  /** Updates a single `Ooto` using a unique key and a patch. **/
  updateOotoById: InContextSdkMethod<Mutation['updateOotoById'], MutationupdateOotoByIdArgs, MeshContext>,
  /** Updates a single `Opportunity` using its globally unique id and a patch. **/
  updateOpportunity: InContextSdkMethod<Mutation['updateOpportunity'], MutationupdateOpportunityArgs, MeshContext>,
  /** Updates a single `Opportunity` using a unique key and a patch. **/
  updateOpportunityById: InContextSdkMethod<Mutation['updateOpportunityById'], MutationupdateOpportunityByIdArgs, MeshContext>,
  /** Updates a single `Order` using its globally unique id and a patch. **/
  updateOrder: InContextSdkMethod<Mutation['updateOrder'], MutationupdateOrderArgs, MeshContext>,
  /** Updates a single `Order` using a unique key and a patch. **/
  updateOrderById: InContextSdkMethod<Mutation['updateOrderById'], MutationupdateOrderByIdArgs, MeshContext>,
  /** Updates a single `Page` using its globally unique id and a patch. **/
  updatePage: InContextSdkMethod<Mutation['updatePage'], MutationupdatePageArgs, MeshContext>,
  /** Updates a single `Page` using a unique key and a patch. **/
  updatePageById: InContextSdkMethod<Mutation['updatePageById'], MutationupdatePageByIdArgs, MeshContext>,
  /** Updates a single `Partner` using its globally unique id and a patch. **/
  updatePartner: InContextSdkMethod<Mutation['updatePartner'], MutationupdatePartnerArgs, MeshContext>,
  /** Updates a single `Partner` using a unique key and a patch. **/
  updatePartnerById: InContextSdkMethod<Mutation['updatePartnerById'], MutationupdatePartnerByIdArgs, MeshContext>,
  /** Updates a single `Payment` using its globally unique id and a patch. **/
  updatePayment: InContextSdkMethod<Mutation['updatePayment'], MutationupdatePaymentArgs, MeshContext>,
  /** Updates a single `Payment` using a unique key and a patch. **/
  updatePaymentById: InContextSdkMethod<Mutation['updatePaymentById'], MutationupdatePaymentByIdArgs, MeshContext>,
  /** Updates a single `Permission` using its globally unique id and a patch. **/
  updatePermission: InContextSdkMethod<Mutation['updatePermission'], MutationupdatePermissionArgs, MeshContext>,
  /** Updates a single `Permission` using a unique key and a patch. **/
  updatePermissionById: InContextSdkMethod<Mutation['updatePermissionById'], MutationupdatePermissionByIdArgs, MeshContext>,
  /** Updates a single `Plugin` using its globally unique id and a patch. **/
  updatePlugin: InContextSdkMethod<Mutation['updatePlugin'], MutationupdatePluginArgs, MeshContext>,
  /** Updates a single `Plugin` using a unique key and a patch. **/
  updatePluginById: InContextSdkMethod<Mutation['updatePluginById'], MutationupdatePluginByIdArgs, MeshContext>,
  /** Updates a single `Poll` using its globally unique id and a patch. **/
  updatePoll: InContextSdkMethod<Mutation['updatePoll'], MutationupdatePollArgs, MeshContext>,
  /** Updates a single `Poll` using a unique key and a patch. **/
  updatePollById: InContextSdkMethod<Mutation['updatePollById'], MutationupdatePollByIdArgs, MeshContext>,
  /** Updates a single `ProductType` using its globally unique id and a patch. **/
  updateProductType: InContextSdkMethod<Mutation['updateProductType'], MutationupdateProductTypeArgs, MeshContext>,
  /** Updates a single `ProductType` using a unique key and a patch. **/
  updateProductTypeById: InContextSdkMethod<Mutation['updateProductTypeById'], MutationupdateProductTypeByIdArgs, MeshContext>,
  /** Updates a single `Product` using its globally unique id and a patch. **/
  updateProduct: InContextSdkMethod<Mutation['updateProduct'], MutationupdateProductArgs, MeshContext>,
  /** Updates a single `Product` using a unique key and a patch. **/
  updateProductById: InContextSdkMethod<Mutation['updateProductById'], MutationupdateProductByIdArgs, MeshContext>,
  /** Updates a single `Project` using its globally unique id and a patch. **/
  updateProject: InContextSdkMethod<Mutation['updateProject'], MutationupdateProjectArgs, MeshContext>,
  /** Updates a single `Project` using a unique key and a patch. **/
  updateProjectById: InContextSdkMethod<Mutation['updateProjectById'], MutationupdateProjectByIdArgs, MeshContext>,
  /** Updates a single `Provider` using its globally unique id and a patch. **/
  updateProvider: InContextSdkMethod<Mutation['updateProvider'], MutationupdateProviderArgs, MeshContext>,
  /** Updates a single `Provider` using a unique key and a patch. **/
  updateProviderById: InContextSdkMethod<Mutation['updateProviderById'], MutationupdateProviderByIdArgs, MeshContext>,
  /** Updates a single `Quote` using its globally unique id and a patch. **/
  updateQuote: InContextSdkMethod<Mutation['updateQuote'], MutationupdateQuoteArgs, MeshContext>,
  /** Updates a single `Quote` using a unique key and a patch. **/
  updateQuoteById: InContextSdkMethod<Mutation['updateQuoteById'], MutationupdateQuoteByIdArgs, MeshContext>,
  /** Updates a single `Rating` using its globally unique id and a patch. **/
  updateRating: InContextSdkMethod<Mutation['updateRating'], MutationupdateRatingArgs, MeshContext>,
  /** Updates a single `Rating` using a unique key and a patch. **/
  updateRatingById: InContextSdkMethod<Mutation['updateRatingById'], MutationupdateRatingByIdArgs, MeshContext>,
  /** Updates a single `Report` using its globally unique id and a patch. **/
  updateReport: InContextSdkMethod<Mutation['updateReport'], MutationupdateReportArgs, MeshContext>,
  /** Updates a single `Report` using a unique key and a patch. **/
  updateReportById: InContextSdkMethod<Mutation['updateReportById'], MutationupdateReportByIdArgs, MeshContext>,
  /** Updates a single `Return` using its globally unique id and a patch. **/
  updateReturn: InContextSdkMethod<Mutation['updateReturn'], MutationupdateReturnArgs, MeshContext>,
  /** Updates a single `Return` using a unique key and a patch. **/
  updateReturnById: InContextSdkMethod<Mutation['updateReturnById'], MutationupdateReturnByIdArgs, MeshContext>,
  /** Updates a single `Review` using its globally unique id and a patch. **/
  updateReview: InContextSdkMethod<Mutation['updateReview'], MutationupdateReviewArgs, MeshContext>,
  /** Updates a single `Review` using a unique key and a patch. **/
  updateReviewById: InContextSdkMethod<Mutation['updateReviewById'], MutationupdateReviewByIdArgs, MeshContext>,
  /** Updates a single `Reward` using its globally unique id and a patch. **/
  updateReward: InContextSdkMethod<Mutation['updateReward'], MutationupdateRewardArgs, MeshContext>,
  /** Updates a single `Reward` using a unique key and a patch. **/
  updateRewardById: InContextSdkMethod<Mutation['updateRewardById'], MutationupdateRewardByIdArgs, MeshContext>,
  /** Updates a single `Role` using its globally unique id and a patch. **/
  updateRole: InContextSdkMethod<Mutation['updateRole'], MutationupdateRoleArgs, MeshContext>,
  /** Updates a single `Role` using a unique key and a patch. **/
  updateRoleById: InContextSdkMethod<Mutation['updateRoleById'], MutationupdateRoleByIdArgs, MeshContext>,
  /** Updates a single `Scheduler` using its globally unique id and a patch. **/
  updateScheduler: InContextSdkMethod<Mutation['updateScheduler'], MutationupdateSchedulerArgs, MeshContext>,
  /** Updates a single `Scheduler` using a unique key and a patch. **/
  updateSchedulerById: InContextSdkMethod<Mutation['updateSchedulerById'], MutationupdateSchedulerByIdArgs, MeshContext>,
  /** Updates a single `Segment` using its globally unique id and a patch. **/
  updateSegment: InContextSdkMethod<Mutation['updateSegment'], MutationupdateSegmentArgs, MeshContext>,
  /** Updates a single `Segment` using a unique key and a patch. **/
  updateSegmentById: InContextSdkMethod<Mutation['updateSegmentById'], MutationupdateSegmentByIdArgs, MeshContext>,
  /** Updates a single `Setting` using its globally unique id and a patch. **/
  updateSetting: InContextSdkMethod<Mutation['updateSetting'], MutationupdateSettingArgs, MeshContext>,
  /** Updates a single `Setting` using a unique key and a patch. **/
  updateSettingById: InContextSdkMethod<Mutation['updateSettingById'], MutationupdateSettingByIdArgs, MeshContext>,
  /** Updates a single `Shipment` using its globally unique id and a patch. **/
  updateShipment: InContextSdkMethod<Mutation['updateShipment'], MutationupdateShipmentArgs, MeshContext>,
  /** Updates a single `Shipment` using a unique key and a patch. **/
  updateShipmentById: InContextSdkMethod<Mutation['updateShipmentById'], MutationupdateShipmentByIdArgs, MeshContext>,
  /** Updates a single `SpecialDiscount` using its globally unique id and a patch. **/
  updateSpecialDiscount: InContextSdkMethod<Mutation['updateSpecialDiscount'], MutationupdateSpecialDiscountArgs, MeshContext>,
  /** Updates a single `SpecialDiscount` using a unique key and a patch. **/
  updateSpecialDiscountById: InContextSdkMethod<Mutation['updateSpecialDiscountById'], MutationupdateSpecialDiscountByIdArgs, MeshContext>,
  /** Updates a single `State` using its globally unique id and a patch. **/
  updateState: InContextSdkMethod<Mutation['updateState'], MutationupdateStateArgs, MeshContext>,
  /** Updates a single `State` using a unique key and a patch. **/
  updateStateById: InContextSdkMethod<Mutation['updateStateById'], MutationupdateStateByIdArgs, MeshContext>,
  /** Updates a single `Statistic` using its globally unique id and a patch. **/
  updateStatistic: InContextSdkMethod<Mutation['updateStatistic'], MutationupdateStatisticArgs, MeshContext>,
  /** Updates a single `Statistic` using a unique key and a patch. **/
  updateStatisticById: InContextSdkMethod<Mutation['updateStatisticById'], MutationupdateStatisticByIdArgs, MeshContext>,
  /** Updates a single `Stock` using its globally unique id and a patch. **/
  updateStock: InContextSdkMethod<Mutation['updateStock'], MutationupdateStockArgs, MeshContext>,
  /** Updates a single `Stock` using a unique key and a patch. **/
  updateStockById: InContextSdkMethod<Mutation['updateStockById'], MutationupdateStockByIdArgs, MeshContext>,
  /** Updates a single `Survey` using its globally unique id and a patch. **/
  updateSurvey: InContextSdkMethod<Mutation['updateSurvey'], MutationupdateSurveyArgs, MeshContext>,
  /** Updates a single `Survey` using a unique key and a patch. **/
  updateSurveyById: InContextSdkMethod<Mutation['updateSurveyById'], MutationupdateSurveyByIdArgs, MeshContext>,
  /** Updates a single `Tag` using its globally unique id and a patch. **/
  updateTag: InContextSdkMethod<Mutation['updateTag'], MutationupdateTagArgs, MeshContext>,
  /** Updates a single `Tag` using a unique key and a patch. **/
  updateTagById: InContextSdkMethod<Mutation['updateTagById'], MutationupdateTagByIdArgs, MeshContext>,
  /** Updates a single `Target` using its globally unique id and a patch. **/
  updateTarget: InContextSdkMethod<Mutation['updateTarget'], MutationupdateTargetArgs, MeshContext>,
  /** Updates a single `Target` using a unique key and a patch. **/
  updateTargetById: InContextSdkMethod<Mutation['updateTargetById'], MutationupdateTargetByIdArgs, MeshContext>,
  /** Updates a single `TaxCategory` using its globally unique id and a patch. **/
  updateTaxCategory: InContextSdkMethod<Mutation['updateTaxCategory'], MutationupdateTaxCategoryArgs, MeshContext>,
  /** Updates a single `TaxCategory` using a unique key and a patch. **/
  updateTaxCategoryById: InContextSdkMethod<Mutation['updateTaxCategoryById'], MutationupdateTaxCategoryByIdArgs, MeshContext>,
  /** Updates a single `TaxRate` using its globally unique id and a patch. **/
  updateTaxRate: InContextSdkMethod<Mutation['updateTaxRate'], MutationupdateTaxRateArgs, MeshContext>,
  /** Updates a single `TaxRate` using a unique key and a patch. **/
  updateTaxRateById: InContextSdkMethod<Mutation['updateTaxRateById'], MutationupdateTaxRateByIdArgs, MeshContext>,
  /** Updates a single `TaxRule` using its globally unique id and a patch. **/
  updateTaxRule: InContextSdkMethod<Mutation['updateTaxRule'], MutationupdateTaxRuleArgs, MeshContext>,
  /** Updates a single `TaxRule` using a unique key and a patch. **/
  updateTaxRuleById: InContextSdkMethod<Mutation['updateTaxRuleById'], MutationupdateTaxRuleByIdArgs, MeshContext>,
  /** Updates a single `Template` using its globally unique id and a patch. **/
  updateTemplate: InContextSdkMethod<Mutation['updateTemplate'], MutationupdateTemplateArgs, MeshContext>,
  /** Updates a single `Template` using a unique key and a patch. **/
  updateTemplateById: InContextSdkMethod<Mutation['updateTemplateById'], MutationupdateTemplateByIdArgs, MeshContext>,
  /** Updates a single `Theme` using its globally unique id and a patch. **/
  updateTheme: InContextSdkMethod<Mutation['updateTheme'], MutationupdateThemeArgs, MeshContext>,
  /** Updates a single `Theme` using a unique key and a patch. **/
  updateThemeById: InContextSdkMethod<Mutation['updateThemeById'], MutationupdateThemeByIdArgs, MeshContext>,
  /** Updates a single `Ticketing` using its globally unique id and a patch. **/
  updateTicketing: InContextSdkMethod<Mutation['updateTicketing'], MutationupdateTicketingArgs, MeshContext>,
  /** Updates a single `Ticketing` using a unique key and a patch. **/
  updateTicketingById: InContextSdkMethod<Mutation['updateTicketingById'], MutationupdateTicketingByIdArgs, MeshContext>,
  /** Updates a single `Training` using its globally unique id and a patch. **/
  updateTraining: InContextSdkMethod<Mutation['updateTraining'], MutationupdateTrainingArgs, MeshContext>,
  /** Updates a single `Training` using a unique key and a patch. **/
  updateTrainingById: InContextSdkMethod<Mutation['updateTrainingById'], MutationupdateTrainingByIdArgs, MeshContext>,
  /** Updates a single `Transaction` using its globally unique id and a patch. **/
  updateTransaction: InContextSdkMethod<Mutation['updateTransaction'], MutationupdateTransactionArgs, MeshContext>,
  /** Updates a single `Transaction` using a unique key and a patch. **/
  updateTransactionById: InContextSdkMethod<Mutation['updateTransactionById'], MutationupdateTransactionByIdArgs, MeshContext>,
  /** Updates a single `UploadFile` using its globally unique id and a patch. **/
  updateUploadFile: InContextSdkMethod<Mutation['updateUploadFile'], MutationupdateUploadFileArgs, MeshContext>,
  /** Updates a single `UploadFile` using a unique key and a patch. **/
  updateUploadFileById: InContextSdkMethod<Mutation['updateUploadFileById'], MutationupdateUploadFileByIdArgs, MeshContext>,
  /** Updates a single `User` using its globally unique id and a patch. **/
  updateUser: InContextSdkMethod<Mutation['updateUser'], MutationupdateUserArgs, MeshContext>,
  /** Updates a single `User` using a unique key and a patch. **/
  updateUserById: InContextSdkMethod<Mutation['updateUserById'], MutationupdateUserByIdArgs, MeshContext>,
  /** Updates a single `Vendor` using its globally unique id and a patch. **/
  updateVendor: InContextSdkMethod<Mutation['updateVendor'], MutationupdateVendorArgs, MeshContext>,
  /** Updates a single `Vendor` using a unique key and a patch. **/
  updateVendorById: InContextSdkMethod<Mutation['updateVendorById'], MutationupdateVendorByIdArgs, MeshContext>,
  /** Updates a single `Visit` using its globally unique id and a patch. **/
  updateVisit: InContextSdkMethod<Mutation['updateVisit'], MutationupdateVisitArgs, MeshContext>,
  /** Updates a single `Visit` using a unique key and a patch. **/
  updateVisitById: InContextSdkMethod<Mutation['updateVisitById'], MutationupdateVisitByIdArgs, MeshContext>,
  /** Updates a single `Warehouse` using its globally unique id and a patch. **/
  updateWarehouse: InContextSdkMethod<Mutation['updateWarehouse'], MutationupdateWarehouseArgs, MeshContext>,
  /** Updates a single `Warehouse` using a unique key and a patch. **/
  updateWarehouseById: InContextSdkMethod<Mutation['updateWarehouseById'], MutationupdateWarehouseByIdArgs, MeshContext>,
  /** Updates a single `Webhook` using its globally unique id and a patch. **/
  updateWebhook: InContextSdkMethod<Mutation['updateWebhook'], MutationupdateWebhookArgs, MeshContext>,
  /** Updates a single `Webhook` using a unique key and a patch. **/
  updateWebhookById: InContextSdkMethod<Mutation['updateWebhookById'], MutationupdateWebhookByIdArgs, MeshContext>,
  /** Updates a single `Website` using its globally unique id and a patch. **/
  updateWebsite: InContextSdkMethod<Mutation['updateWebsite'], MutationupdateWebsiteArgs, MeshContext>,
  /** Updates a single `Website` using a unique key and a patch. **/
  updateWebsiteById: InContextSdkMethod<Mutation['updateWebsiteById'], MutationupdateWebsiteByIdArgs, MeshContext>,
  /** Updates a single `Wishlist` using its globally unique id and a patch. **/
  updateWishlist: InContextSdkMethod<Mutation['updateWishlist'], MutationupdateWishlistArgs, MeshContext>,
  /** Updates a single `Wishlist` using a unique key and a patch. **/
  updateWishlistById: InContextSdkMethod<Mutation['updateWishlistById'], MutationupdateWishlistByIdArgs, MeshContext>,
  /** Updates a single `Workspace` using its globally unique id and a patch. **/
  updateWorkspace: InContextSdkMethod<Mutation['updateWorkspace'], MutationupdateWorkspaceArgs, MeshContext>,
  /** Updates a single `Workspace` using a unique key and a patch. **/
  updateWorkspaceById: InContextSdkMethod<Mutation['updateWorkspaceById'], MutationupdateWorkspaceByIdArgs, MeshContext>,
  /** Updates a single `Zone` using its globally unique id and a patch. **/
  updateZone: InContextSdkMethod<Mutation['updateZone'], MutationupdateZoneArgs, MeshContext>,
  /** Updates a single `Zone` using a unique key and a patch. **/
  updateZoneById: InContextSdkMethod<Mutation['updateZoneById'], MutationupdateZoneByIdArgs, MeshContext>,
  /** Deletes a single `Account` using its globally unique id. **/
  deleteAccount: InContextSdkMethod<Mutation['deleteAccount'], MutationdeleteAccountArgs, MeshContext>,
  /** Deletes a single `Account` using a unique key. **/
  deleteAccountById: InContextSdkMethod<Mutation['deleteAccountById'], MutationdeleteAccountByIdArgs, MeshContext>,
  /** Deletes a single `Agreement` using its globally unique id. **/
  deleteAgreement: InContextSdkMethod<Mutation['deleteAgreement'], MutationdeleteAgreementArgs, MeshContext>,
  /** Deletes a single `Agreement` using a unique key. **/
  deleteAgreementById: InContextSdkMethod<Mutation['deleteAgreementById'], MutationdeleteAgreementByIdArgs, MeshContext>,
  /** Deletes a single `Analytic` using its globally unique id. **/
  deleteAnalytic: InContextSdkMethod<Mutation['deleteAnalytic'], MutationdeleteAnalyticArgs, MeshContext>,
  /** Deletes a single `Analytic` using a unique key. **/
  deleteAnalyticById: InContextSdkMethod<Mutation['deleteAnalyticById'], MutationdeleteAnalyticByIdArgs, MeshContext>,
  /** Deletes a single `Apitoken` using its globally unique id. **/
  deleteApitoken: InContextSdkMethod<Mutation['deleteApitoken'], MutationdeleteApitokenArgs, MeshContext>,
  /** Deletes a single `Apitoken` using a unique key. **/
  deleteApitokenById: InContextSdkMethod<Mutation['deleteApitokenById'], MutationdeleteApitokenByIdArgs, MeshContext>,
  /** Deletes a single `Article` using its globally unique id. **/
  deleteArticle: InContextSdkMethod<Mutation['deleteArticle'], MutationdeleteArticleArgs, MeshContext>,
  /** Deletes a single `Article` using a unique key. **/
  deleteArticleById: InContextSdkMethod<Mutation['deleteArticleById'], MutationdeleteArticleByIdArgs, MeshContext>,
  /** Deletes a single `Attribute` using its globally unique id. **/
  deleteAttribute: InContextSdkMethod<Mutation['deleteAttribute'], MutationdeleteAttributeArgs, MeshContext>,
  /** Deletes a single `Attribute` using a unique key. **/
  deleteAttributeById: InContextSdkMethod<Mutation['deleteAttributeById'], MutationdeleteAttributeByIdArgs, MeshContext>,
  /** Deletes a single `Brand` using its globally unique id. **/
  deleteBrand: InContextSdkMethod<Mutation['deleteBrand'], MutationdeleteBrandArgs, MeshContext>,
  /** Deletes a single `Brand` using a unique key. **/
  deleteBrandById: InContextSdkMethod<Mutation['deleteBrandById'], MutationdeleteBrandByIdArgs, MeshContext>,
  /** Deletes a single `CartPriceRule` using its globally unique id. **/
  deleteCartPriceRule: InContextSdkMethod<Mutation['deleteCartPriceRule'], MutationdeleteCartPriceRuleArgs, MeshContext>,
  /** Deletes a single `CartPriceRule` using a unique key. **/
  deleteCartPriceRuleById: InContextSdkMethod<Mutation['deleteCartPriceRuleById'], MutationdeleteCartPriceRuleByIdArgs, MeshContext>,
  /** Deletes a single `Case` using its globally unique id. **/
  deleteCase: InContextSdkMethod<Mutation['deleteCase'], MutationdeleteCaseArgs, MeshContext>,
  /** Deletes a single `Case` using a unique key. **/
  deleteCaseById: InContextSdkMethod<Mutation['deleteCaseById'], MutationdeleteCaseByIdArgs, MeshContext>,
  /** Deletes a single `CatalogPriceRule` using its globally unique id. **/
  deleteCatalogPriceRule: InContextSdkMethod<Mutation['deleteCatalogPriceRule'], MutationdeleteCatalogPriceRuleArgs, MeshContext>,
  /** Deletes a single `CatalogPriceRule` using a unique key. **/
  deleteCatalogPriceRuleById: InContextSdkMethod<Mutation['deleteCatalogPriceRuleById'], MutationdeleteCatalogPriceRuleByIdArgs, MeshContext>,
  /** Deletes a single `Category` using its globally unique id. **/
  deleteCategory: InContextSdkMethod<Mutation['deleteCategory'], MutationdeleteCategoryArgs, MeshContext>,
  /** Deletes a single `Category` using a unique key. **/
  deleteCategoryById: InContextSdkMethod<Mutation['deleteCategoryById'], MutationdeleteCategoryByIdArgs, MeshContext>,
  /** Deletes a single `Channel` using its globally unique id. **/
  deleteChannel: InContextSdkMethod<Mutation['deleteChannel'], MutationdeleteChannelArgs, MeshContext>,
  /** Deletes a single `Channel` using a unique key. **/
  deleteChannelById: InContextSdkMethod<Mutation['deleteChannelById'], MutationdeleteChannelByIdArgs, MeshContext>,
  /** Deletes a single `Checklist` using its globally unique id. **/
  deleteChecklist: InContextSdkMethod<Mutation['deleteChecklist'], MutationdeleteChecklistArgs, MeshContext>,
  /** Deletes a single `Checklist` using a unique key. **/
  deleteChecklistById: InContextSdkMethod<Mutation['deleteChecklistById'], MutationdeleteChecklistByIdArgs, MeshContext>,
  /** Deletes a single `City` using its globally unique id. **/
  deleteCity: InContextSdkMethod<Mutation['deleteCity'], MutationdeleteCityArgs, MeshContext>,
  /** Deletes a single `City` using a unique key. **/
  deleteCityById: InContextSdkMethod<Mutation['deleteCityById'], MutationdeleteCityByIdArgs, MeshContext>,
  /** Deletes a single `Collection` using its globally unique id. **/
  deleteCollection: InContextSdkMethod<Mutation['deleteCollection'], MutationdeleteCollectionArgs, MeshContext>,
  /** Deletes a single `Collection` using a unique key. **/
  deleteCollectionById: InContextSdkMethod<Mutation['deleteCollectionById'], MutationdeleteCollectionByIdArgs, MeshContext>,
  /** Deletes a single `Comment` using its globally unique id. **/
  deleteComment: InContextSdkMethod<Mutation['deleteComment'], MutationdeleteCommentArgs, MeshContext>,
  /** Deletes a single `Comment` using a unique key. **/
  deleteCommentById: InContextSdkMethod<Mutation['deleteCommentById'], MutationdeleteCommentByIdArgs, MeshContext>,
  /** Deletes a single `ContentType` using its globally unique id. **/
  deleteContentType: InContextSdkMethod<Mutation['deleteContentType'], MutationdeleteContentTypeArgs, MeshContext>,
  /** Deletes a single `ContentType` using a unique key. **/
  deleteContentTypeById: InContextSdkMethod<Mutation['deleteContentTypeById'], MutationdeleteContentTypeByIdArgs, MeshContext>,
  /** Deletes a single `Contract` using its globally unique id. **/
  deleteContract: InContextSdkMethod<Mutation['deleteContract'], MutationdeleteContractArgs, MeshContext>,
  /** Deletes a single `Contract` using a unique key. **/
  deleteContractById: InContextSdkMethod<Mutation['deleteContractById'], MutationdeleteContractByIdArgs, MeshContext>,
  /** Deletes a single `Country` using its globally unique id. **/
  deleteCountry: InContextSdkMethod<Mutation['deleteCountry'], MutationdeleteCountryArgs, MeshContext>,
  /** Deletes a single `Country` using a unique key. **/
  deleteCountryById: InContextSdkMethod<Mutation['deleteCountryById'], MutationdeleteCountryByIdArgs, MeshContext>,
  /** Deletes a single `Coupon` using its globally unique id. **/
  deleteCoupon: InContextSdkMethod<Mutation['deleteCoupon'], MutationdeleteCouponArgs, MeshContext>,
  /** Deletes a single `Coupon` using a unique key. **/
  deleteCouponById: InContextSdkMethod<Mutation['deleteCouponById'], MutationdeleteCouponByIdArgs, MeshContext>,
  /** Deletes a single `CreditMemo` using its globally unique id. **/
  deleteCreditMemo: InContextSdkMethod<Mutation['deleteCreditMemo'], MutationdeleteCreditMemoArgs, MeshContext>,
  /** Deletes a single `CreditMemo` using a unique key. **/
  deleteCreditMemoByCreditMemoAndId: InContextSdkMethod<Mutation['deleteCreditMemoByCreditMemoAndId'], MutationdeleteCreditMemoByCreditMemoAndIdArgs, MeshContext>,
  /** Deletes a single `Currency` using its globally unique id. **/
  deleteCurrency: InContextSdkMethod<Mutation['deleteCurrency'], MutationdeleteCurrencyArgs, MeshContext>,
  /** Deletes a single `Currency` using a unique key. **/
  deleteCurrencyById: InContextSdkMethod<Mutation['deleteCurrencyById'], MutationdeleteCurrencyByIdArgs, MeshContext>,
  /** Deletes a single `CurrencyRate` using its globally unique id. **/
  deleteCurrencyRate: InContextSdkMethod<Mutation['deleteCurrencyRate'], MutationdeleteCurrencyRateArgs, MeshContext>,
  /** Deletes a single `CurrencyRate` using a unique key. **/
  deleteCurrencyRateByImportService: InContextSdkMethod<Mutation['deleteCurrencyRateByImportService'], MutationdeleteCurrencyRateByImportServiceArgs, MeshContext>,
  /** Deletes a single `CurrencySymbol` using its globally unique id. **/
  deleteCurrencySymbol: InContextSdkMethod<Mutation['deleteCurrencySymbol'], MutationdeleteCurrencySymbolArgs, MeshContext>,
  /** Deletes a single `CurrencySymbol` using a unique key. **/
  deleteCurrencySymbolBySymbol: InContextSdkMethod<Mutation['deleteCurrencySymbolBySymbol'], MutationdeleteCurrencySymbolBySymbolArgs, MeshContext>,
  /** Deletes a single `CustomerGroup` using its globally unique id. **/
  deleteCustomerGroup: InContextSdkMethod<Mutation['deleteCustomerGroup'], MutationdeleteCustomerGroupArgs, MeshContext>,
  /** Deletes a single `CustomerGroup` using a unique key. **/
  deleteCustomerGroupById: InContextSdkMethod<Mutation['deleteCustomerGroupById'], MutationdeleteCustomerGroupByIdArgs, MeshContext>,
  /** Deletes a single `Customer` using its globally unique id. **/
  deleteCustomer: InContextSdkMethod<Mutation['deleteCustomer'], MutationdeleteCustomerArgs, MeshContext>,
  /** Deletes a single `Customer` using a unique key. **/
  deleteCustomerById: InContextSdkMethod<Mutation['deleteCustomerById'], MutationdeleteCustomerByIdArgs, MeshContext>,
  /** Deletes a single `Customization` using its globally unique id. **/
  deleteCustomization: InContextSdkMethod<Mutation['deleteCustomization'], MutationdeleteCustomizationArgs, MeshContext>,
  /** Deletes a single `Customization` using a unique key. **/
  deleteCustomizationById: InContextSdkMethod<Mutation['deleteCustomizationById'], MutationdeleteCustomizationByIdArgs, MeshContext>,
  /** Deletes a single `Dashboard` using its globally unique id. **/
  deleteDashboard: InContextSdkMethod<Mutation['deleteDashboard'], MutationdeleteDashboardArgs, MeshContext>,
  /** Deletes a single `Dashboard` using a unique key. **/
  deleteDashboardById: InContextSdkMethod<Mutation['deleteDashboardById'], MutationdeleteDashboardByIdArgs, MeshContext>,
  /** Deletes a single `Deepdive` using its globally unique id. **/
  deleteDeepdive: InContextSdkMethod<Mutation['deleteDeepdive'], MutationdeleteDeepdiveArgs, MeshContext>,
  /** Deletes a single `Deepdive` using a unique key. **/
  deleteDeepdiveById: InContextSdkMethod<Mutation['deleteDeepdiveById'], MutationdeleteDeepdiveByIdArgs, MeshContext>,
  /** Deletes a single `Digiboard` using its globally unique id. **/
  deleteDigiboard: InContextSdkMethod<Mutation['deleteDigiboard'], MutationdeleteDigiboardArgs, MeshContext>,
  /** Deletes a single `Digiboard` using a unique key. **/
  deleteDigiboardById: InContextSdkMethod<Mutation['deleteDigiboardById'], MutationdeleteDigiboardByIdArgs, MeshContext>,
  /** Deletes a single `Email` using its globally unique id. **/
  deleteEmail: InContextSdkMethod<Mutation['deleteEmail'], MutationdeleteEmailArgs, MeshContext>,
  /** Deletes a single `Email` using a unique key. **/
  deleteEmailById: InContextSdkMethod<Mutation['deleteEmailById'], MutationdeleteEmailByIdArgs, MeshContext>,
  /** Deletes a single `Endofshift` using its globally unique id. **/
  deleteEndofshift: InContextSdkMethod<Mutation['deleteEndofshift'], MutationdeleteEndofshiftArgs, MeshContext>,
  /** Deletes a single `Endofshift` using a unique key. **/
  deleteEndofshiftById: InContextSdkMethod<Mutation['deleteEndofshiftById'], MutationdeleteEndofshiftByIdArgs, MeshContext>,
  /** Deletes a single `Event` using its globally unique id. **/
  deleteEvent: InContextSdkMethod<Mutation['deleteEvent'], MutationdeleteEventArgs, MeshContext>,
  /** Deletes a single `Event` using a unique key. **/
  deleteEventById: InContextSdkMethod<Mutation['deleteEventById'], MutationdeleteEventByIdArgs, MeshContext>,
  /** Deletes a single `Fullfillment` using its globally unique id. **/
  deleteFullfillment: InContextSdkMethod<Mutation['deleteFullfillment'], MutationdeleteFullfillmentArgs, MeshContext>,
  /** Deletes a single `Fullfillment` using a unique key. **/
  deleteFullfillmentById: InContextSdkMethod<Mutation['deleteFullfillmentById'], MutationdeleteFullfillmentByIdArgs, MeshContext>,
  /** Deletes a single `GiftCertificate` using its globally unique id. **/
  deleteGiftCertificate: InContextSdkMethod<Mutation['deleteGiftCertificate'], MutationdeleteGiftCertificateArgs, MeshContext>,
  /** Deletes a single `GiftCertificate` using a unique key. **/
  deleteGiftCertificateById: InContextSdkMethod<Mutation['deleteGiftCertificateById'], MutationdeleteGiftCertificateByIdArgs, MeshContext>,
  /** Deletes a single `Glossary` using its globally unique id. **/
  deleteGlossary: InContextSdkMethod<Mutation['deleteGlossary'], MutationdeleteGlossaryArgs, MeshContext>,
  /** Deletes a single `Glossary` using a unique key. **/
  deleteGlossaryById: InContextSdkMethod<Mutation['deleteGlossaryById'], MutationdeleteGlossaryByIdArgs, MeshContext>,
  /** Deletes a single `Importm` using its globally unique id. **/
  deleteImportm: InContextSdkMethod<Mutation['deleteImportm'], MutationdeleteImportmArgs, MeshContext>,
  /** Deletes a single `Importm` using a unique key. **/
  deleteImportmById: InContextSdkMethod<Mutation['deleteImportmById'], MutationdeleteImportmByIdArgs, MeshContext>,
  /** Deletes a single `Integration` using its globally unique id. **/
  deleteIntegration: InContextSdkMethod<Mutation['deleteIntegration'], MutationdeleteIntegrationArgs, MeshContext>,
  /** Deletes a single `Integration` using a unique key. **/
  deleteIntegrationById: InContextSdkMethod<Mutation['deleteIntegrationById'], MutationdeleteIntegrationByIdArgs, MeshContext>,
  /** Deletes a single `Internalization` using its globally unique id. **/
  deleteInternalization: InContextSdkMethod<Mutation['deleteInternalization'], MutationdeleteInternalizationArgs, MeshContext>,
  /** Deletes a single `Internalization` using a unique key. **/
  deleteInternalizationById: InContextSdkMethod<Mutation['deleteInternalizationById'], MutationdeleteInternalizationByIdArgs, MeshContext>,
  /** Deletes a single `Invitation` using its globally unique id. **/
  deleteInvitation: InContextSdkMethod<Mutation['deleteInvitation'], MutationdeleteInvitationArgs, MeshContext>,
  /** Deletes a single `Invitation` using a unique key. **/
  deleteInvitationById: InContextSdkMethod<Mutation['deleteInvitationById'], MutationdeleteInvitationByIdArgs, MeshContext>,
  /** Deletes a single `Invoice` using its globally unique id. **/
  deleteInvoice: InContextSdkMethod<Mutation['deleteInvoice'], MutationdeleteInvoiceArgs, MeshContext>,
  /** Deletes a single `Invoice` using a unique key. **/
  deleteInvoiceById: InContextSdkMethod<Mutation['deleteInvoiceById'], MutationdeleteInvoiceByIdArgs, MeshContext>,
  /** Deletes a single `Lead` using its globally unique id. **/
  deleteLead: InContextSdkMethod<Mutation['deleteLead'], MutationdeleteLeadArgs, MeshContext>,
  /** Deletes a single `Lead` using a unique key. **/
  deleteLeadById: InContextSdkMethod<Mutation['deleteLeadById'], MutationdeleteLeadByIdArgs, MeshContext>,
  /** Deletes a single `Manufacturer` using its globally unique id. **/
  deleteManufacturer: InContextSdkMethod<Mutation['deleteManufacturer'], MutationdeleteManufacturerArgs, MeshContext>,
  /** Deletes a single `Manufacturer` using a unique key. **/
  deleteManufacturerById: InContextSdkMethod<Mutation['deleteManufacturerById'], MutationdeleteManufacturerByIdArgs, MeshContext>,
  /** Deletes a single `Mediamanager` using its globally unique id. **/
  deleteMediamanager: InContextSdkMethod<Mutation['deleteMediamanager'], MutationdeleteMediamanagerArgs, MeshContext>,
  /** Deletes a single `Mediamanager` using a unique key. **/
  deleteMediamanagerById: InContextSdkMethod<Mutation['deleteMediamanagerById'], MutationdeleteMediamanagerByIdArgs, MeshContext>,
  /** Deletes a single `Meeting` using its globally unique id. **/
  deleteMeeting: InContextSdkMethod<Mutation['deleteMeeting'], MutationdeleteMeetingArgs, MeshContext>,
  /** Deletes a single `Meeting` using a unique key. **/
  deleteMeetingById: InContextSdkMethod<Mutation['deleteMeetingById'], MutationdeleteMeetingByIdArgs, MeshContext>,
  /** Deletes a single `Message` using its globally unique id. **/
  deleteMessage: InContextSdkMethod<Mutation['deleteMessage'], MutationdeleteMessageArgs, MeshContext>,
  /** Deletes a single `Message` using a unique key. **/
  deleteMessageById: InContextSdkMethod<Mutation['deleteMessageById'], MutationdeleteMessageByIdArgs, MeshContext>,
  /** Deletes a single `Newsletter` using its globally unique id. **/
  deleteNewsletter: InContextSdkMethod<Mutation['deleteNewsletter'], MutationdeleteNewsletterArgs, MeshContext>,
  /** Deletes a single `Newsletter` using a unique key. **/
  deleteNewsletterById: InContextSdkMethod<Mutation['deleteNewsletterById'], MutationdeleteNewsletterByIdArgs, MeshContext>,
  /** Deletes a single `Ooto` using its globally unique id. **/
  deleteOoto: InContextSdkMethod<Mutation['deleteOoto'], MutationdeleteOotoArgs, MeshContext>,
  /** Deletes a single `Ooto` using a unique key. **/
  deleteOotoById: InContextSdkMethod<Mutation['deleteOotoById'], MutationdeleteOotoByIdArgs, MeshContext>,
  /** Deletes a single `Opportunity` using its globally unique id. **/
  deleteOpportunity: InContextSdkMethod<Mutation['deleteOpportunity'], MutationdeleteOpportunityArgs, MeshContext>,
  /** Deletes a single `Opportunity` using a unique key. **/
  deleteOpportunityById: InContextSdkMethod<Mutation['deleteOpportunityById'], MutationdeleteOpportunityByIdArgs, MeshContext>,
  /** Deletes a single `Order` using its globally unique id. **/
  deleteOrder: InContextSdkMethod<Mutation['deleteOrder'], MutationdeleteOrderArgs, MeshContext>,
  /** Deletes a single `Order` using a unique key. **/
  deleteOrderById: InContextSdkMethod<Mutation['deleteOrderById'], MutationdeleteOrderByIdArgs, MeshContext>,
  /** Deletes a single `Page` using its globally unique id. **/
  deletePage: InContextSdkMethod<Mutation['deletePage'], MutationdeletePageArgs, MeshContext>,
  /** Deletes a single `Page` using a unique key. **/
  deletePageById: InContextSdkMethod<Mutation['deletePageById'], MutationdeletePageByIdArgs, MeshContext>,
  /** Deletes a single `Partner` using its globally unique id. **/
  deletePartner: InContextSdkMethod<Mutation['deletePartner'], MutationdeletePartnerArgs, MeshContext>,
  /** Deletes a single `Partner` using a unique key. **/
  deletePartnerById: InContextSdkMethod<Mutation['deletePartnerById'], MutationdeletePartnerByIdArgs, MeshContext>,
  /** Deletes a single `Payment` using its globally unique id. **/
  deletePayment: InContextSdkMethod<Mutation['deletePayment'], MutationdeletePaymentArgs, MeshContext>,
  /** Deletes a single `Payment` using a unique key. **/
  deletePaymentById: InContextSdkMethod<Mutation['deletePaymentById'], MutationdeletePaymentByIdArgs, MeshContext>,
  /** Deletes a single `Permission` using its globally unique id. **/
  deletePermission: InContextSdkMethod<Mutation['deletePermission'], MutationdeletePermissionArgs, MeshContext>,
  /** Deletes a single `Permission` using a unique key. **/
  deletePermissionById: InContextSdkMethod<Mutation['deletePermissionById'], MutationdeletePermissionByIdArgs, MeshContext>,
  /** Deletes a single `Plugin` using its globally unique id. **/
  deletePlugin: InContextSdkMethod<Mutation['deletePlugin'], MutationdeletePluginArgs, MeshContext>,
  /** Deletes a single `Plugin` using a unique key. **/
  deletePluginById: InContextSdkMethod<Mutation['deletePluginById'], MutationdeletePluginByIdArgs, MeshContext>,
  /** Deletes a single `Poll` using its globally unique id. **/
  deletePoll: InContextSdkMethod<Mutation['deletePoll'], MutationdeletePollArgs, MeshContext>,
  /** Deletes a single `Poll` using a unique key. **/
  deletePollById: InContextSdkMethod<Mutation['deletePollById'], MutationdeletePollByIdArgs, MeshContext>,
  /** Deletes a single `ProductType` using its globally unique id. **/
  deleteProductType: InContextSdkMethod<Mutation['deleteProductType'], MutationdeleteProductTypeArgs, MeshContext>,
  /** Deletes a single `ProductType` using a unique key. **/
  deleteProductTypeById: InContextSdkMethod<Mutation['deleteProductTypeById'], MutationdeleteProductTypeByIdArgs, MeshContext>,
  /** Deletes a single `Product` using its globally unique id. **/
  deleteProduct: InContextSdkMethod<Mutation['deleteProduct'], MutationdeleteProductArgs, MeshContext>,
  /** Deletes a single `Product` using a unique key. **/
  deleteProductById: InContextSdkMethod<Mutation['deleteProductById'], MutationdeleteProductByIdArgs, MeshContext>,
  /** Deletes a single `Project` using its globally unique id. **/
  deleteProject: InContextSdkMethod<Mutation['deleteProject'], MutationdeleteProjectArgs, MeshContext>,
  /** Deletes a single `Project` using a unique key. **/
  deleteProjectById: InContextSdkMethod<Mutation['deleteProjectById'], MutationdeleteProjectByIdArgs, MeshContext>,
  /** Deletes a single `Provider` using its globally unique id. **/
  deleteProvider: InContextSdkMethod<Mutation['deleteProvider'], MutationdeleteProviderArgs, MeshContext>,
  /** Deletes a single `Provider` using a unique key. **/
  deleteProviderById: InContextSdkMethod<Mutation['deleteProviderById'], MutationdeleteProviderByIdArgs, MeshContext>,
  /** Deletes a single `Quote` using its globally unique id. **/
  deleteQuote: InContextSdkMethod<Mutation['deleteQuote'], MutationdeleteQuoteArgs, MeshContext>,
  /** Deletes a single `Quote` using a unique key. **/
  deleteQuoteById: InContextSdkMethod<Mutation['deleteQuoteById'], MutationdeleteQuoteByIdArgs, MeshContext>,
  /** Deletes a single `Rating` using its globally unique id. **/
  deleteRating: InContextSdkMethod<Mutation['deleteRating'], MutationdeleteRatingArgs, MeshContext>,
  /** Deletes a single `Rating` using a unique key. **/
  deleteRatingById: InContextSdkMethod<Mutation['deleteRatingById'], MutationdeleteRatingByIdArgs, MeshContext>,
  /** Deletes a single `Report` using its globally unique id. **/
  deleteReport: InContextSdkMethod<Mutation['deleteReport'], MutationdeleteReportArgs, MeshContext>,
  /** Deletes a single `Report` using a unique key. **/
  deleteReportById: InContextSdkMethod<Mutation['deleteReportById'], MutationdeleteReportByIdArgs, MeshContext>,
  /** Deletes a single `Return` using its globally unique id. **/
  deleteReturn: InContextSdkMethod<Mutation['deleteReturn'], MutationdeleteReturnArgs, MeshContext>,
  /** Deletes a single `Return` using a unique key. **/
  deleteReturnById: InContextSdkMethod<Mutation['deleteReturnById'], MutationdeleteReturnByIdArgs, MeshContext>,
  /** Deletes a single `Review` using its globally unique id. **/
  deleteReview: InContextSdkMethod<Mutation['deleteReview'], MutationdeleteReviewArgs, MeshContext>,
  /** Deletes a single `Review` using a unique key. **/
  deleteReviewById: InContextSdkMethod<Mutation['deleteReviewById'], MutationdeleteReviewByIdArgs, MeshContext>,
  /** Deletes a single `Reward` using its globally unique id. **/
  deleteReward: InContextSdkMethod<Mutation['deleteReward'], MutationdeleteRewardArgs, MeshContext>,
  /** Deletes a single `Reward` using a unique key. **/
  deleteRewardById: InContextSdkMethod<Mutation['deleteRewardById'], MutationdeleteRewardByIdArgs, MeshContext>,
  /** Deletes a single `Role` using its globally unique id. **/
  deleteRole: InContextSdkMethod<Mutation['deleteRole'], MutationdeleteRoleArgs, MeshContext>,
  /** Deletes a single `Role` using a unique key. **/
  deleteRoleById: InContextSdkMethod<Mutation['deleteRoleById'], MutationdeleteRoleByIdArgs, MeshContext>,
  /** Deletes a single `Scheduler` using its globally unique id. **/
  deleteScheduler: InContextSdkMethod<Mutation['deleteScheduler'], MutationdeleteSchedulerArgs, MeshContext>,
  /** Deletes a single `Scheduler` using a unique key. **/
  deleteSchedulerById: InContextSdkMethod<Mutation['deleteSchedulerById'], MutationdeleteSchedulerByIdArgs, MeshContext>,
  /** Deletes a single `Segment` using its globally unique id. **/
  deleteSegment: InContextSdkMethod<Mutation['deleteSegment'], MutationdeleteSegmentArgs, MeshContext>,
  /** Deletes a single `Segment` using a unique key. **/
  deleteSegmentById: InContextSdkMethod<Mutation['deleteSegmentById'], MutationdeleteSegmentByIdArgs, MeshContext>,
  /** Deletes a single `Setting` using its globally unique id. **/
  deleteSetting: InContextSdkMethod<Mutation['deleteSetting'], MutationdeleteSettingArgs, MeshContext>,
  /** Deletes a single `Setting` using a unique key. **/
  deleteSettingById: InContextSdkMethod<Mutation['deleteSettingById'], MutationdeleteSettingByIdArgs, MeshContext>,
  /** Deletes a single `Shipment` using its globally unique id. **/
  deleteShipment: InContextSdkMethod<Mutation['deleteShipment'], MutationdeleteShipmentArgs, MeshContext>,
  /** Deletes a single `Shipment` using a unique key. **/
  deleteShipmentById: InContextSdkMethod<Mutation['deleteShipmentById'], MutationdeleteShipmentByIdArgs, MeshContext>,
  /** Deletes a single `SpecialDiscount` using its globally unique id. **/
  deleteSpecialDiscount: InContextSdkMethod<Mutation['deleteSpecialDiscount'], MutationdeleteSpecialDiscountArgs, MeshContext>,
  /** Deletes a single `SpecialDiscount` using a unique key. **/
  deleteSpecialDiscountById: InContextSdkMethod<Mutation['deleteSpecialDiscountById'], MutationdeleteSpecialDiscountByIdArgs, MeshContext>,
  /** Deletes a single `State` using its globally unique id. **/
  deleteState: InContextSdkMethod<Mutation['deleteState'], MutationdeleteStateArgs, MeshContext>,
  /** Deletes a single `State` using a unique key. **/
  deleteStateById: InContextSdkMethod<Mutation['deleteStateById'], MutationdeleteStateByIdArgs, MeshContext>,
  /** Deletes a single `Statistic` using its globally unique id. **/
  deleteStatistic: InContextSdkMethod<Mutation['deleteStatistic'], MutationdeleteStatisticArgs, MeshContext>,
  /** Deletes a single `Statistic` using a unique key. **/
  deleteStatisticById: InContextSdkMethod<Mutation['deleteStatisticById'], MutationdeleteStatisticByIdArgs, MeshContext>,
  /** Deletes a single `Stock` using its globally unique id. **/
  deleteStock: InContextSdkMethod<Mutation['deleteStock'], MutationdeleteStockArgs, MeshContext>,
  /** Deletes a single `Stock` using a unique key. **/
  deleteStockById: InContextSdkMethod<Mutation['deleteStockById'], MutationdeleteStockByIdArgs, MeshContext>,
  /** Deletes a single `Survey` using its globally unique id. **/
  deleteSurvey: InContextSdkMethod<Mutation['deleteSurvey'], MutationdeleteSurveyArgs, MeshContext>,
  /** Deletes a single `Survey` using a unique key. **/
  deleteSurveyById: InContextSdkMethod<Mutation['deleteSurveyById'], MutationdeleteSurveyByIdArgs, MeshContext>,
  /** Deletes a single `Tag` using its globally unique id. **/
  deleteTag: InContextSdkMethod<Mutation['deleteTag'], MutationdeleteTagArgs, MeshContext>,
  /** Deletes a single `Tag` using a unique key. **/
  deleteTagById: InContextSdkMethod<Mutation['deleteTagById'], MutationdeleteTagByIdArgs, MeshContext>,
  /** Deletes a single `Target` using its globally unique id. **/
  deleteTarget: InContextSdkMethod<Mutation['deleteTarget'], MutationdeleteTargetArgs, MeshContext>,
  /** Deletes a single `Target` using a unique key. **/
  deleteTargetById: InContextSdkMethod<Mutation['deleteTargetById'], MutationdeleteTargetByIdArgs, MeshContext>,
  /** Deletes a single `TaxCategory` using its globally unique id. **/
  deleteTaxCategory: InContextSdkMethod<Mutation['deleteTaxCategory'], MutationdeleteTaxCategoryArgs, MeshContext>,
  /** Deletes a single `TaxCategory` using a unique key. **/
  deleteTaxCategoryById: InContextSdkMethod<Mutation['deleteTaxCategoryById'], MutationdeleteTaxCategoryByIdArgs, MeshContext>,
  /** Deletes a single `TaxRate` using its globally unique id. **/
  deleteTaxRate: InContextSdkMethod<Mutation['deleteTaxRate'], MutationdeleteTaxRateArgs, MeshContext>,
  /** Deletes a single `TaxRate` using a unique key. **/
  deleteTaxRateById: InContextSdkMethod<Mutation['deleteTaxRateById'], MutationdeleteTaxRateByIdArgs, MeshContext>,
  /** Deletes a single `TaxRule` using its globally unique id. **/
  deleteTaxRule: InContextSdkMethod<Mutation['deleteTaxRule'], MutationdeleteTaxRuleArgs, MeshContext>,
  /** Deletes a single `TaxRule` using a unique key. **/
  deleteTaxRuleById: InContextSdkMethod<Mutation['deleteTaxRuleById'], MutationdeleteTaxRuleByIdArgs, MeshContext>,
  /** Deletes a single `Template` using its globally unique id. **/
  deleteTemplate: InContextSdkMethod<Mutation['deleteTemplate'], MutationdeleteTemplateArgs, MeshContext>,
  /** Deletes a single `Template` using a unique key. **/
  deleteTemplateById: InContextSdkMethod<Mutation['deleteTemplateById'], MutationdeleteTemplateByIdArgs, MeshContext>,
  /** Deletes a single `Theme` using its globally unique id. **/
  deleteTheme: InContextSdkMethod<Mutation['deleteTheme'], MutationdeleteThemeArgs, MeshContext>,
  /** Deletes a single `Theme` using a unique key. **/
  deleteThemeById: InContextSdkMethod<Mutation['deleteThemeById'], MutationdeleteThemeByIdArgs, MeshContext>,
  /** Deletes a single `Ticketing` using its globally unique id. **/
  deleteTicketing: InContextSdkMethod<Mutation['deleteTicketing'], MutationdeleteTicketingArgs, MeshContext>,
  /** Deletes a single `Ticketing` using a unique key. **/
  deleteTicketingById: InContextSdkMethod<Mutation['deleteTicketingById'], MutationdeleteTicketingByIdArgs, MeshContext>,
  /** Deletes a single `Training` using its globally unique id. **/
  deleteTraining: InContextSdkMethod<Mutation['deleteTraining'], MutationdeleteTrainingArgs, MeshContext>,
  /** Deletes a single `Training` using a unique key. **/
  deleteTrainingById: InContextSdkMethod<Mutation['deleteTrainingById'], MutationdeleteTrainingByIdArgs, MeshContext>,
  /** Deletes a single `Transaction` using its globally unique id. **/
  deleteTransaction: InContextSdkMethod<Mutation['deleteTransaction'], MutationdeleteTransactionArgs, MeshContext>,
  /** Deletes a single `Transaction` using a unique key. **/
  deleteTransactionById: InContextSdkMethod<Mutation['deleteTransactionById'], MutationdeleteTransactionByIdArgs, MeshContext>,
  /** Deletes a single `UploadFile` using its globally unique id. **/
  deleteUploadFile: InContextSdkMethod<Mutation['deleteUploadFile'], MutationdeleteUploadFileArgs, MeshContext>,
  /** Deletes a single `UploadFile` using a unique key. **/
  deleteUploadFileById: InContextSdkMethod<Mutation['deleteUploadFileById'], MutationdeleteUploadFileByIdArgs, MeshContext>,
  /** Deletes a single `User` using its globally unique id. **/
  deleteUser: InContextSdkMethod<Mutation['deleteUser'], MutationdeleteUserArgs, MeshContext>,
  /** Deletes a single `User` using a unique key. **/
  deleteUserById: InContextSdkMethod<Mutation['deleteUserById'], MutationdeleteUserByIdArgs, MeshContext>,
  /** Deletes a single `Vendor` using its globally unique id. **/
  deleteVendor: InContextSdkMethod<Mutation['deleteVendor'], MutationdeleteVendorArgs, MeshContext>,
  /** Deletes a single `Vendor` using a unique key. **/
  deleteVendorById: InContextSdkMethod<Mutation['deleteVendorById'], MutationdeleteVendorByIdArgs, MeshContext>,
  /** Deletes a single `Visit` using its globally unique id. **/
  deleteVisit: InContextSdkMethod<Mutation['deleteVisit'], MutationdeleteVisitArgs, MeshContext>,
  /** Deletes a single `Visit` using a unique key. **/
  deleteVisitById: InContextSdkMethod<Mutation['deleteVisitById'], MutationdeleteVisitByIdArgs, MeshContext>,
  /** Deletes a single `Warehouse` using its globally unique id. **/
  deleteWarehouse: InContextSdkMethod<Mutation['deleteWarehouse'], MutationdeleteWarehouseArgs, MeshContext>,
  /** Deletes a single `Warehouse` using a unique key. **/
  deleteWarehouseById: InContextSdkMethod<Mutation['deleteWarehouseById'], MutationdeleteWarehouseByIdArgs, MeshContext>,
  /** Deletes a single `Webhook` using its globally unique id. **/
  deleteWebhook: InContextSdkMethod<Mutation['deleteWebhook'], MutationdeleteWebhookArgs, MeshContext>,
  /** Deletes a single `Webhook` using a unique key. **/
  deleteWebhookById: InContextSdkMethod<Mutation['deleteWebhookById'], MutationdeleteWebhookByIdArgs, MeshContext>,
  /** Deletes a single `Website` using its globally unique id. **/
  deleteWebsite: InContextSdkMethod<Mutation['deleteWebsite'], MutationdeleteWebsiteArgs, MeshContext>,
  /** Deletes a single `Website` using a unique key. **/
  deleteWebsiteById: InContextSdkMethod<Mutation['deleteWebsiteById'], MutationdeleteWebsiteByIdArgs, MeshContext>,
  /** Deletes a single `Wishlist` using its globally unique id. **/
  deleteWishlist: InContextSdkMethod<Mutation['deleteWishlist'], MutationdeleteWishlistArgs, MeshContext>,
  /** Deletes a single `Wishlist` using a unique key. **/
  deleteWishlistById: InContextSdkMethod<Mutation['deleteWishlistById'], MutationdeleteWishlistByIdArgs, MeshContext>,
  /** Deletes a single `Workspace` using its globally unique id. **/
  deleteWorkspace: InContextSdkMethod<Mutation['deleteWorkspace'], MutationdeleteWorkspaceArgs, MeshContext>,
  /** Deletes a single `Workspace` using a unique key. **/
  deleteWorkspaceById: InContextSdkMethod<Mutation['deleteWorkspaceById'], MutationdeleteWorkspaceByIdArgs, MeshContext>,
  /** Deletes a single `Zone` using its globally unique id. **/
  deleteZone: InContextSdkMethod<Mutation['deleteZone'], MutationdeleteZoneArgs, MeshContext>,
  /** Deletes a single `Zone` using a unique key. **/
  deleteZoneById: InContextSdkMethod<Mutation['deleteZoneById'], MutationdeleteZoneByIdArgs, MeshContext>
  };

  export type SubscriptionSdk = {
      /** Exposes the root query type nested one level down. This is helpful for Relay 1
which can only query top level fields if they are in a particular form. (live) **/
  query: InContextSdkMethod<Subscription['query'], {}, MeshContext>,
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. (live) **/
  nodeId: InContextSdkMethod<Subscription['nodeId'], {}, MeshContext>,
  /** Fetches an object given its globally unique `ID`. (live) **/
  node: InContextSdkMethod<Subscription['node'], SubscriptionnodeArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Account`. (live) **/
  allAccounts: InContextSdkMethod<Subscription['allAccounts'], SubscriptionallAccountsArgs, MeshContext>,
  /** Reads a set of `Account`. (live) **/
  allAccountsList: InContextSdkMethod<Subscription['allAccountsList'], SubscriptionallAccountsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Agreement`. (live) **/
  allAgreements: InContextSdkMethod<Subscription['allAgreements'], SubscriptionallAgreementsArgs, MeshContext>,
  /** Reads a set of `Agreement`. (live) **/
  allAgreementsList: InContextSdkMethod<Subscription['allAgreementsList'], SubscriptionallAgreementsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Analytic`. (live) **/
  allAnalytics: InContextSdkMethod<Subscription['allAnalytics'], SubscriptionallAnalyticsArgs, MeshContext>,
  /** Reads a set of `Analytic`. (live) **/
  allAnalyticsList: InContextSdkMethod<Subscription['allAnalyticsList'], SubscriptionallAnalyticsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Apitoken`. (live) **/
  allApitokens: InContextSdkMethod<Subscription['allApitokens'], SubscriptionallApitokensArgs, MeshContext>,
  /** Reads a set of `Apitoken`. (live) **/
  allApitokensList: InContextSdkMethod<Subscription['allApitokensList'], SubscriptionallApitokensListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Article`. (live) **/
  allArticles: InContextSdkMethod<Subscription['allArticles'], SubscriptionallArticlesArgs, MeshContext>,
  /** Reads a set of `Article`. (live) **/
  allArticlesList: InContextSdkMethod<Subscription['allArticlesList'], SubscriptionallArticlesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Attribute`. (live) **/
  allAttributes: InContextSdkMethod<Subscription['allAttributes'], SubscriptionallAttributesArgs, MeshContext>,
  /** Reads a set of `Attribute`. (live) **/
  allAttributesList: InContextSdkMethod<Subscription['allAttributesList'], SubscriptionallAttributesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Brand`. (live) **/
  allBrands: InContextSdkMethod<Subscription['allBrands'], SubscriptionallBrandsArgs, MeshContext>,
  /** Reads a set of `Brand`. (live) **/
  allBrandsList: InContextSdkMethod<Subscription['allBrandsList'], SubscriptionallBrandsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CartPriceRule`. (live) **/
  allCartPriceRules: InContextSdkMethod<Subscription['allCartPriceRules'], SubscriptionallCartPriceRulesArgs, MeshContext>,
  /** Reads a set of `CartPriceRule`. (live) **/
  allCartPriceRulesList: InContextSdkMethod<Subscription['allCartPriceRulesList'], SubscriptionallCartPriceRulesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Case`. (live) **/
  allCases: InContextSdkMethod<Subscription['allCases'], SubscriptionallCasesArgs, MeshContext>,
  /** Reads a set of `Case`. (live) **/
  allCasesList: InContextSdkMethod<Subscription['allCasesList'], SubscriptionallCasesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CatalogPriceRule`. (live) **/
  allCatalogPriceRules: InContextSdkMethod<Subscription['allCatalogPriceRules'], SubscriptionallCatalogPriceRulesArgs, MeshContext>,
  /** Reads a set of `CatalogPriceRule`. (live) **/
  allCatalogPriceRulesList: InContextSdkMethod<Subscription['allCatalogPriceRulesList'], SubscriptionallCatalogPriceRulesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Category`. (live) **/
  allCategories: InContextSdkMethod<Subscription['allCategories'], SubscriptionallCategoriesArgs, MeshContext>,
  /** Reads a set of `Category`. (live) **/
  allCategoriesList: InContextSdkMethod<Subscription['allCategoriesList'], SubscriptionallCategoriesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Channel`. (live) **/
  allChannels: InContextSdkMethod<Subscription['allChannels'], SubscriptionallChannelsArgs, MeshContext>,
  /** Reads a set of `Channel`. (live) **/
  allChannelsList: InContextSdkMethod<Subscription['allChannelsList'], SubscriptionallChannelsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Checklist`. (live) **/
  allChecklists: InContextSdkMethod<Subscription['allChecklists'], SubscriptionallChecklistsArgs, MeshContext>,
  /** Reads a set of `Checklist`. (live) **/
  allChecklistsList: InContextSdkMethod<Subscription['allChecklistsList'], SubscriptionallChecklistsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `City`. (live) **/
  allCities: InContextSdkMethod<Subscription['allCities'], SubscriptionallCitiesArgs, MeshContext>,
  /** Reads a set of `City`. (live) **/
  allCitiesList: InContextSdkMethod<Subscription['allCitiesList'], SubscriptionallCitiesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Collection`. (live) **/
  allCollections: InContextSdkMethod<Subscription['allCollections'], SubscriptionallCollectionsArgs, MeshContext>,
  /** Reads a set of `Collection`. (live) **/
  allCollectionsList: InContextSdkMethod<Subscription['allCollectionsList'], SubscriptionallCollectionsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Comment`. (live) **/
  allComments: InContextSdkMethod<Subscription['allComments'], SubscriptionallCommentsArgs, MeshContext>,
  /** Reads a set of `Comment`. (live) **/
  allCommentsList: InContextSdkMethod<Subscription['allCommentsList'], SubscriptionallCommentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `ContentType`. (live) **/
  allContentTypes: InContextSdkMethod<Subscription['allContentTypes'], SubscriptionallContentTypesArgs, MeshContext>,
  /** Reads a set of `ContentType`. (live) **/
  allContentTypesList: InContextSdkMethod<Subscription['allContentTypesList'], SubscriptionallContentTypesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Contract`. (live) **/
  allContracts: InContextSdkMethod<Subscription['allContracts'], SubscriptionallContractsArgs, MeshContext>,
  /** Reads a set of `Contract`. (live) **/
  allContractsList: InContextSdkMethod<Subscription['allContractsList'], SubscriptionallContractsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Country`. (live) **/
  allCountries: InContextSdkMethod<Subscription['allCountries'], SubscriptionallCountriesArgs, MeshContext>,
  /** Reads a set of `Country`. (live) **/
  allCountriesList: InContextSdkMethod<Subscription['allCountriesList'], SubscriptionallCountriesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Coupon`. (live) **/
  allCoupons: InContextSdkMethod<Subscription['allCoupons'], SubscriptionallCouponsArgs, MeshContext>,
  /** Reads a set of `Coupon`. (live) **/
  allCouponsList: InContextSdkMethod<Subscription['allCouponsList'], SubscriptionallCouponsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CreditMemo`. (live) **/
  allCreditMemos: InContextSdkMethod<Subscription['allCreditMemos'], SubscriptionallCreditMemosArgs, MeshContext>,
  /** Reads a set of `CreditMemo`. (live) **/
  allCreditMemosList: InContextSdkMethod<Subscription['allCreditMemosList'], SubscriptionallCreditMemosListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Currency`. (live) **/
  allCurrencies: InContextSdkMethod<Subscription['allCurrencies'], SubscriptionallCurrenciesArgs, MeshContext>,
  /** Reads a set of `Currency`. (live) **/
  allCurrenciesList: InContextSdkMethod<Subscription['allCurrenciesList'], SubscriptionallCurrenciesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CurrencyRate`. (live) **/
  allCurrencyRates: InContextSdkMethod<Subscription['allCurrencyRates'], SubscriptionallCurrencyRatesArgs, MeshContext>,
  /** Reads a set of `CurrencyRate`. (live) **/
  allCurrencyRatesList: InContextSdkMethod<Subscription['allCurrencyRatesList'], SubscriptionallCurrencyRatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CurrencySymbol`. (live) **/
  allCurrencySymbols: InContextSdkMethod<Subscription['allCurrencySymbols'], SubscriptionallCurrencySymbolsArgs, MeshContext>,
  /** Reads a set of `CurrencySymbol`. (live) **/
  allCurrencySymbolsList: InContextSdkMethod<Subscription['allCurrencySymbolsList'], SubscriptionallCurrencySymbolsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `CustomerGroup`. (live) **/
  allCustomerGroups: InContextSdkMethod<Subscription['allCustomerGroups'], SubscriptionallCustomerGroupsArgs, MeshContext>,
  /** Reads a set of `CustomerGroup`. (live) **/
  allCustomerGroupsList: InContextSdkMethod<Subscription['allCustomerGroupsList'], SubscriptionallCustomerGroupsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Customer`. (live) **/
  allCustomers: InContextSdkMethod<Subscription['allCustomers'], SubscriptionallCustomersArgs, MeshContext>,
  /** Reads a set of `Customer`. (live) **/
  allCustomersList: InContextSdkMethod<Subscription['allCustomersList'], SubscriptionallCustomersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Customization`. (live) **/
  allCustomizations: InContextSdkMethod<Subscription['allCustomizations'], SubscriptionallCustomizationsArgs, MeshContext>,
  /** Reads a set of `Customization`. (live) **/
  allCustomizationsList: InContextSdkMethod<Subscription['allCustomizationsList'], SubscriptionallCustomizationsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Dashboard`. (live) **/
  allDashboards: InContextSdkMethod<Subscription['allDashboards'], SubscriptionallDashboardsArgs, MeshContext>,
  /** Reads a set of `Dashboard`. (live) **/
  allDashboardsList: InContextSdkMethod<Subscription['allDashboardsList'], SubscriptionallDashboardsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Deepdive`. (live) **/
  allDeepdives: InContextSdkMethod<Subscription['allDeepdives'], SubscriptionallDeepdivesArgs, MeshContext>,
  /** Reads a set of `Deepdive`. (live) **/
  allDeepdivesList: InContextSdkMethod<Subscription['allDeepdivesList'], SubscriptionallDeepdivesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Digiboard`. (live) **/
  allDigiboards: InContextSdkMethod<Subscription['allDigiboards'], SubscriptionallDigiboardsArgs, MeshContext>,
  /** Reads a set of `Digiboard`. (live) **/
  allDigiboardsList: InContextSdkMethod<Subscription['allDigiboardsList'], SubscriptionallDigiboardsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Email`. (live) **/
  allEmails: InContextSdkMethod<Subscription['allEmails'], SubscriptionallEmailsArgs, MeshContext>,
  /** Reads a set of `Email`. (live) **/
  allEmailsList: InContextSdkMethod<Subscription['allEmailsList'], SubscriptionallEmailsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Endofshift`. (live) **/
  allEndofshifts: InContextSdkMethod<Subscription['allEndofshifts'], SubscriptionallEndofshiftsArgs, MeshContext>,
  /** Reads a set of `Endofshift`. (live) **/
  allEndofshiftsList: InContextSdkMethod<Subscription['allEndofshiftsList'], SubscriptionallEndofshiftsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Event`. (live) **/
  allEvents: InContextSdkMethod<Subscription['allEvents'], SubscriptionallEventsArgs, MeshContext>,
  /** Reads a set of `Event`. (live) **/
  allEventsList: InContextSdkMethod<Subscription['allEventsList'], SubscriptionallEventsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Fullfillment`. (live) **/
  allFullfillments: InContextSdkMethod<Subscription['allFullfillments'], SubscriptionallFullfillmentsArgs, MeshContext>,
  /** Reads a set of `Fullfillment`. (live) **/
  allFullfillmentsList: InContextSdkMethod<Subscription['allFullfillmentsList'], SubscriptionallFullfillmentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `GiftCertificate`. (live) **/
  allGiftCertificates: InContextSdkMethod<Subscription['allGiftCertificates'], SubscriptionallGiftCertificatesArgs, MeshContext>,
  /** Reads a set of `GiftCertificate`. (live) **/
  allGiftCertificatesList: InContextSdkMethod<Subscription['allGiftCertificatesList'], SubscriptionallGiftCertificatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Glossary`. (live) **/
  allGlossaries: InContextSdkMethod<Subscription['allGlossaries'], SubscriptionallGlossariesArgs, MeshContext>,
  /** Reads a set of `Glossary`. (live) **/
  allGlossariesList: InContextSdkMethod<Subscription['allGlossariesList'], SubscriptionallGlossariesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Importm`. (live) **/
  allImportms: InContextSdkMethod<Subscription['allImportms'], SubscriptionallImportmsArgs, MeshContext>,
  /** Reads a set of `Importm`. (live) **/
  allImportmsList: InContextSdkMethod<Subscription['allImportmsList'], SubscriptionallImportmsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Integration`. (live) **/
  allIntegrations: InContextSdkMethod<Subscription['allIntegrations'], SubscriptionallIntegrationsArgs, MeshContext>,
  /** Reads a set of `Integration`. (live) **/
  allIntegrationsList: InContextSdkMethod<Subscription['allIntegrationsList'], SubscriptionallIntegrationsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Internalization`. (live) **/
  allInternalizations: InContextSdkMethod<Subscription['allInternalizations'], SubscriptionallInternalizationsArgs, MeshContext>,
  /** Reads a set of `Internalization`. (live) **/
  allInternalizationsList: InContextSdkMethod<Subscription['allInternalizationsList'], SubscriptionallInternalizationsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Invitation`. (live) **/
  allInvitations: InContextSdkMethod<Subscription['allInvitations'], SubscriptionallInvitationsArgs, MeshContext>,
  /** Reads a set of `Invitation`. (live) **/
  allInvitationsList: InContextSdkMethod<Subscription['allInvitationsList'], SubscriptionallInvitationsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Invoice`. (live) **/
  allInvoices: InContextSdkMethod<Subscription['allInvoices'], SubscriptionallInvoicesArgs, MeshContext>,
  /** Reads a set of `Invoice`. (live) **/
  allInvoicesList: InContextSdkMethod<Subscription['allInvoicesList'], SubscriptionallInvoicesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Lead`. (live) **/
  allLeads: InContextSdkMethod<Subscription['allLeads'], SubscriptionallLeadsArgs, MeshContext>,
  /** Reads a set of `Lead`. (live) **/
  allLeadsList: InContextSdkMethod<Subscription['allLeadsList'], SubscriptionallLeadsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Manufacturer`. (live) **/
  allManufacturers: InContextSdkMethod<Subscription['allManufacturers'], SubscriptionallManufacturersArgs, MeshContext>,
  /** Reads a set of `Manufacturer`. (live) **/
  allManufacturersList: InContextSdkMethod<Subscription['allManufacturersList'], SubscriptionallManufacturersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Mediamanager`. (live) **/
  allMediamanagers: InContextSdkMethod<Subscription['allMediamanagers'], SubscriptionallMediamanagersArgs, MeshContext>,
  /** Reads a set of `Mediamanager`. (live) **/
  allMediamanagersList: InContextSdkMethod<Subscription['allMediamanagersList'], SubscriptionallMediamanagersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Meeting`. (live) **/
  allMeetings: InContextSdkMethod<Subscription['allMeetings'], SubscriptionallMeetingsArgs, MeshContext>,
  /** Reads a set of `Meeting`. (live) **/
  allMeetingsList: InContextSdkMethod<Subscription['allMeetingsList'], SubscriptionallMeetingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Message`. (live) **/
  allMessages: InContextSdkMethod<Subscription['allMessages'], SubscriptionallMessagesArgs, MeshContext>,
  /** Reads a set of `Message`. (live) **/
  allMessagesList: InContextSdkMethod<Subscription['allMessagesList'], SubscriptionallMessagesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Newsletter`. (live) **/
  allNewsletters: InContextSdkMethod<Subscription['allNewsletters'], SubscriptionallNewslettersArgs, MeshContext>,
  /** Reads a set of `Newsletter`. (live) **/
  allNewslettersList: InContextSdkMethod<Subscription['allNewslettersList'], SubscriptionallNewslettersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Ooto`. (live) **/
  allOotos: InContextSdkMethod<Subscription['allOotos'], SubscriptionallOotosArgs, MeshContext>,
  /** Reads a set of `Ooto`. (live) **/
  allOotosList: InContextSdkMethod<Subscription['allOotosList'], SubscriptionallOotosListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Opportunity`. (live) **/
  allOpportunities: InContextSdkMethod<Subscription['allOpportunities'], SubscriptionallOpportunitiesArgs, MeshContext>,
  /** Reads a set of `Opportunity`. (live) **/
  allOpportunitiesList: InContextSdkMethod<Subscription['allOpportunitiesList'], SubscriptionallOpportunitiesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Order`. (live) **/
  allOrders: InContextSdkMethod<Subscription['allOrders'], SubscriptionallOrdersArgs, MeshContext>,
  /** Reads a set of `Order`. (live) **/
  allOrdersList: InContextSdkMethod<Subscription['allOrdersList'], SubscriptionallOrdersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Page`. (live) **/
  allPages: InContextSdkMethod<Subscription['allPages'], SubscriptionallPagesArgs, MeshContext>,
  /** Reads a set of `Page`. (live) **/
  allPagesList: InContextSdkMethod<Subscription['allPagesList'], SubscriptionallPagesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Partner`. (live) **/
  allPartners: InContextSdkMethod<Subscription['allPartners'], SubscriptionallPartnersArgs, MeshContext>,
  /** Reads a set of `Partner`. (live) **/
  allPartnersList: InContextSdkMethod<Subscription['allPartnersList'], SubscriptionallPartnersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Payment`. (live) **/
  allPayments: InContextSdkMethod<Subscription['allPayments'], SubscriptionallPaymentsArgs, MeshContext>,
  /** Reads a set of `Payment`. (live) **/
  allPaymentsList: InContextSdkMethod<Subscription['allPaymentsList'], SubscriptionallPaymentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Permission`. (live) **/
  allPermissions: InContextSdkMethod<Subscription['allPermissions'], SubscriptionallPermissionsArgs, MeshContext>,
  /** Reads a set of `Permission`. (live) **/
  allPermissionsList: InContextSdkMethod<Subscription['allPermissionsList'], SubscriptionallPermissionsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Plugin`. (live) **/
  allPlugins: InContextSdkMethod<Subscription['allPlugins'], SubscriptionallPluginsArgs, MeshContext>,
  /** Reads a set of `Plugin`. (live) **/
  allPluginsList: InContextSdkMethod<Subscription['allPluginsList'], SubscriptionallPluginsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Poll`. (live) **/
  allPolls: InContextSdkMethod<Subscription['allPolls'], SubscriptionallPollsArgs, MeshContext>,
  /** Reads a set of `Poll`. (live) **/
  allPollsList: InContextSdkMethod<Subscription['allPollsList'], SubscriptionallPollsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `ProductType`. (live) **/
  allProductTypes: InContextSdkMethod<Subscription['allProductTypes'], SubscriptionallProductTypesArgs, MeshContext>,
  /** Reads a set of `ProductType`. (live) **/
  allProductTypesList: InContextSdkMethod<Subscription['allProductTypesList'], SubscriptionallProductTypesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Product`. (live) **/
  allProducts: InContextSdkMethod<Subscription['allProducts'], SubscriptionallProductsArgs, MeshContext>,
  /** Reads a set of `Product`. (live) **/
  allProductsList: InContextSdkMethod<Subscription['allProductsList'], SubscriptionallProductsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Project`. (live) **/
  allProjects: InContextSdkMethod<Subscription['allProjects'], SubscriptionallProjectsArgs, MeshContext>,
  /** Reads a set of `Project`. (live) **/
  allProjectsList: InContextSdkMethod<Subscription['allProjectsList'], SubscriptionallProjectsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Provider`. (live) **/
  allProviders: InContextSdkMethod<Subscription['allProviders'], SubscriptionallProvidersArgs, MeshContext>,
  /** Reads a set of `Provider`. (live) **/
  allProvidersList: InContextSdkMethod<Subscription['allProvidersList'], SubscriptionallProvidersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Quote`. (live) **/
  allQuotes: InContextSdkMethod<Subscription['allQuotes'], SubscriptionallQuotesArgs, MeshContext>,
  /** Reads a set of `Quote`. (live) **/
  allQuotesList: InContextSdkMethod<Subscription['allQuotesList'], SubscriptionallQuotesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Rating`. (live) **/
  allRatings: InContextSdkMethod<Subscription['allRatings'], SubscriptionallRatingsArgs, MeshContext>,
  /** Reads a set of `Rating`. (live) **/
  allRatingsList: InContextSdkMethod<Subscription['allRatingsList'], SubscriptionallRatingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Report`. (live) **/
  allReports: InContextSdkMethod<Subscription['allReports'], SubscriptionallReportsArgs, MeshContext>,
  /** Reads a set of `Report`. (live) **/
  allReportsList: InContextSdkMethod<Subscription['allReportsList'], SubscriptionallReportsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Return`. (live) **/
  allReturns: InContextSdkMethod<Subscription['allReturns'], SubscriptionallReturnsArgs, MeshContext>,
  /** Reads a set of `Return`. (live) **/
  allReturnsList: InContextSdkMethod<Subscription['allReturnsList'], SubscriptionallReturnsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Review`. (live) **/
  allReviews: InContextSdkMethod<Subscription['allReviews'], SubscriptionallReviewsArgs, MeshContext>,
  /** Reads a set of `Review`. (live) **/
  allReviewsList: InContextSdkMethod<Subscription['allReviewsList'], SubscriptionallReviewsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Reward`. (live) **/
  allRewards: InContextSdkMethod<Subscription['allRewards'], SubscriptionallRewardsArgs, MeshContext>,
  /** Reads a set of `Reward`. (live) **/
  allRewardsList: InContextSdkMethod<Subscription['allRewardsList'], SubscriptionallRewardsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Role`. (live) **/
  allRoles: InContextSdkMethod<Subscription['allRoles'], SubscriptionallRolesArgs, MeshContext>,
  /** Reads a set of `Role`. (live) **/
  allRolesList: InContextSdkMethod<Subscription['allRolesList'], SubscriptionallRolesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Scheduler`. (live) **/
  allSchedulers: InContextSdkMethod<Subscription['allSchedulers'], SubscriptionallSchedulersArgs, MeshContext>,
  /** Reads a set of `Scheduler`. (live) **/
  allSchedulersList: InContextSdkMethod<Subscription['allSchedulersList'], SubscriptionallSchedulersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Segment`. (live) **/
  allSegments: InContextSdkMethod<Subscription['allSegments'], SubscriptionallSegmentsArgs, MeshContext>,
  /** Reads a set of `Segment`. (live) **/
  allSegmentsList: InContextSdkMethod<Subscription['allSegmentsList'], SubscriptionallSegmentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Setting`. (live) **/
  allSettings: InContextSdkMethod<Subscription['allSettings'], SubscriptionallSettingsArgs, MeshContext>,
  /** Reads a set of `Setting`. (live) **/
  allSettingsList: InContextSdkMethod<Subscription['allSettingsList'], SubscriptionallSettingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Shipment`. (live) **/
  allShipments: InContextSdkMethod<Subscription['allShipments'], SubscriptionallShipmentsArgs, MeshContext>,
  /** Reads a set of `Shipment`. (live) **/
  allShipmentsList: InContextSdkMethod<Subscription['allShipmentsList'], SubscriptionallShipmentsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `SpecialDiscount`. (live) **/
  allSpecialDiscounts: InContextSdkMethod<Subscription['allSpecialDiscounts'], SubscriptionallSpecialDiscountsArgs, MeshContext>,
  /** Reads a set of `SpecialDiscount`. (live) **/
  allSpecialDiscountsList: InContextSdkMethod<Subscription['allSpecialDiscountsList'], SubscriptionallSpecialDiscountsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `State`. (live) **/
  allStates: InContextSdkMethod<Subscription['allStates'], SubscriptionallStatesArgs, MeshContext>,
  /** Reads a set of `State`. (live) **/
  allStatesList: InContextSdkMethod<Subscription['allStatesList'], SubscriptionallStatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Statistic`. (live) **/
  allStatistics: InContextSdkMethod<Subscription['allStatistics'], SubscriptionallStatisticsArgs, MeshContext>,
  /** Reads a set of `Statistic`. (live) **/
  allStatisticsList: InContextSdkMethod<Subscription['allStatisticsList'], SubscriptionallStatisticsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Stock`. (live) **/
  allStocks: InContextSdkMethod<Subscription['allStocks'], SubscriptionallStocksArgs, MeshContext>,
  /** Reads a set of `Stock`. (live) **/
  allStocksList: InContextSdkMethod<Subscription['allStocksList'], SubscriptionallStocksListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Survey`. (live) **/
  allSurveys: InContextSdkMethod<Subscription['allSurveys'], SubscriptionallSurveysArgs, MeshContext>,
  /** Reads a set of `Survey`. (live) **/
  allSurveysList: InContextSdkMethod<Subscription['allSurveysList'], SubscriptionallSurveysListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Tag`. (live) **/
  allTags: InContextSdkMethod<Subscription['allTags'], SubscriptionallTagsArgs, MeshContext>,
  /** Reads a set of `Tag`. (live) **/
  allTagsList: InContextSdkMethod<Subscription['allTagsList'], SubscriptionallTagsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Target`. (live) **/
  allTargets: InContextSdkMethod<Subscription['allTargets'], SubscriptionallTargetsArgs, MeshContext>,
  /** Reads a set of `Target`. (live) **/
  allTargetsList: InContextSdkMethod<Subscription['allTargetsList'], SubscriptionallTargetsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `TaxCategory`. (live) **/
  allTaxCategories: InContextSdkMethod<Subscription['allTaxCategories'], SubscriptionallTaxCategoriesArgs, MeshContext>,
  /** Reads a set of `TaxCategory`. (live) **/
  allTaxCategoriesList: InContextSdkMethod<Subscription['allTaxCategoriesList'], SubscriptionallTaxCategoriesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `TaxRate`. (live) **/
  allTaxRates: InContextSdkMethod<Subscription['allTaxRates'], SubscriptionallTaxRatesArgs, MeshContext>,
  /** Reads a set of `TaxRate`. (live) **/
  allTaxRatesList: InContextSdkMethod<Subscription['allTaxRatesList'], SubscriptionallTaxRatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `TaxRule`. (live) **/
  allTaxRules: InContextSdkMethod<Subscription['allTaxRules'], SubscriptionallTaxRulesArgs, MeshContext>,
  /** Reads a set of `TaxRule`. (live) **/
  allTaxRulesList: InContextSdkMethod<Subscription['allTaxRulesList'], SubscriptionallTaxRulesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Template`. (live) **/
  allTemplates: InContextSdkMethod<Subscription['allTemplates'], SubscriptionallTemplatesArgs, MeshContext>,
  /** Reads a set of `Template`. (live) **/
  allTemplatesList: InContextSdkMethod<Subscription['allTemplatesList'], SubscriptionallTemplatesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Theme`. (live) **/
  allThemes: InContextSdkMethod<Subscription['allThemes'], SubscriptionallThemesArgs, MeshContext>,
  /** Reads a set of `Theme`. (live) **/
  allThemesList: InContextSdkMethod<Subscription['allThemesList'], SubscriptionallThemesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Ticketing`. (live) **/
  allTicketings: InContextSdkMethod<Subscription['allTicketings'], SubscriptionallTicketingsArgs, MeshContext>,
  /** Reads a set of `Ticketing`. (live) **/
  allTicketingsList: InContextSdkMethod<Subscription['allTicketingsList'], SubscriptionallTicketingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Training`. (live) **/
  allTrainings: InContextSdkMethod<Subscription['allTrainings'], SubscriptionallTrainingsArgs, MeshContext>,
  /** Reads a set of `Training`. (live) **/
  allTrainingsList: InContextSdkMethod<Subscription['allTrainingsList'], SubscriptionallTrainingsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Transaction`. (live) **/
  allTransactions: InContextSdkMethod<Subscription['allTransactions'], SubscriptionallTransactionsArgs, MeshContext>,
  /** Reads a set of `Transaction`. (live) **/
  allTransactionsList: InContextSdkMethod<Subscription['allTransactionsList'], SubscriptionallTransactionsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `UploadFile`. (live) **/
  allUploadFiles: InContextSdkMethod<Subscription['allUploadFiles'], SubscriptionallUploadFilesArgs, MeshContext>,
  /** Reads a set of `UploadFile`. (live) **/
  allUploadFilesList: InContextSdkMethod<Subscription['allUploadFilesList'], SubscriptionallUploadFilesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `User`. (live) **/
  allUsers: InContextSdkMethod<Subscription['allUsers'], SubscriptionallUsersArgs, MeshContext>,
  /** Reads a set of `User`. (live) **/
  allUsersList: InContextSdkMethod<Subscription['allUsersList'], SubscriptionallUsersListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Vendor`. (live) **/
  allVendors: InContextSdkMethod<Subscription['allVendors'], SubscriptionallVendorsArgs, MeshContext>,
  /** Reads a set of `Vendor`. (live) **/
  allVendorsList: InContextSdkMethod<Subscription['allVendorsList'], SubscriptionallVendorsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Visit`. (live) **/
  allVisits: InContextSdkMethod<Subscription['allVisits'], SubscriptionallVisitsArgs, MeshContext>,
  /** Reads a set of `Visit`. (live) **/
  allVisitsList: InContextSdkMethod<Subscription['allVisitsList'], SubscriptionallVisitsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Warehouse`. (live) **/
  allWarehouses: InContextSdkMethod<Subscription['allWarehouses'], SubscriptionallWarehousesArgs, MeshContext>,
  /** Reads a set of `Warehouse`. (live) **/
  allWarehousesList: InContextSdkMethod<Subscription['allWarehousesList'], SubscriptionallWarehousesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Webhook`. (live) **/
  allWebhooks: InContextSdkMethod<Subscription['allWebhooks'], SubscriptionallWebhooksArgs, MeshContext>,
  /** Reads a set of `Webhook`. (live) **/
  allWebhooksList: InContextSdkMethod<Subscription['allWebhooksList'], SubscriptionallWebhooksListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Website`. (live) **/
  allWebsites: InContextSdkMethod<Subscription['allWebsites'], SubscriptionallWebsitesArgs, MeshContext>,
  /** Reads a set of `Website`. (live) **/
  allWebsitesList: InContextSdkMethod<Subscription['allWebsitesList'], SubscriptionallWebsitesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Wishlist`. (live) **/
  allWishlists: InContextSdkMethod<Subscription['allWishlists'], SubscriptionallWishlistsArgs, MeshContext>,
  /** Reads a set of `Wishlist`. (live) **/
  allWishlistsList: InContextSdkMethod<Subscription['allWishlistsList'], SubscriptionallWishlistsListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Workspace`. (live) **/
  allWorkspaces: InContextSdkMethod<Subscription['allWorkspaces'], SubscriptionallWorkspacesArgs, MeshContext>,
  /** Reads a set of `Workspace`. (live) **/
  allWorkspacesList: InContextSdkMethod<Subscription['allWorkspacesList'], SubscriptionallWorkspacesListArgs, MeshContext>,
  /** Reads and enables pagination through a set of `Zone`. (live) **/
  allZones: InContextSdkMethod<Subscription['allZones'], SubscriptionallZonesArgs, MeshContext>,
  /** Reads a set of `Zone`. (live) **/
  allZonesList: InContextSdkMethod<Subscription['allZonesList'], SubscriptionallZonesListArgs, MeshContext>,
  /**  (live) **/
  accountById: InContextSdkMethod<Subscription['accountById'], SubscriptionaccountByIdArgs, MeshContext>,
  /**  (live) **/
  agreementById: InContextSdkMethod<Subscription['agreementById'], SubscriptionagreementByIdArgs, MeshContext>,
  /**  (live) **/
  analyticById: InContextSdkMethod<Subscription['analyticById'], SubscriptionanalyticByIdArgs, MeshContext>,
  /**  (live) **/
  apitokenById: InContextSdkMethod<Subscription['apitokenById'], SubscriptionapitokenByIdArgs, MeshContext>,
  /**  (live) **/
  articleById: InContextSdkMethod<Subscription['articleById'], SubscriptionarticleByIdArgs, MeshContext>,
  /**  (live) **/
  attributeById: InContextSdkMethod<Subscription['attributeById'], SubscriptionattributeByIdArgs, MeshContext>,
  /**  (live) **/
  brandById: InContextSdkMethod<Subscription['brandById'], SubscriptionbrandByIdArgs, MeshContext>,
  /**  (live) **/
  cartPriceRuleById: InContextSdkMethod<Subscription['cartPriceRuleById'], SubscriptioncartPriceRuleByIdArgs, MeshContext>,
  /**  (live) **/
  caseById: InContextSdkMethod<Subscription['caseById'], SubscriptioncaseByIdArgs, MeshContext>,
  /**  (live) **/
  catalogPriceRuleById: InContextSdkMethod<Subscription['catalogPriceRuleById'], SubscriptioncatalogPriceRuleByIdArgs, MeshContext>,
  /**  (live) **/
  categoryById: InContextSdkMethod<Subscription['categoryById'], SubscriptioncategoryByIdArgs, MeshContext>,
  /**  (live) **/
  channelById: InContextSdkMethod<Subscription['channelById'], SubscriptionchannelByIdArgs, MeshContext>,
  /**  (live) **/
  checklistById: InContextSdkMethod<Subscription['checklistById'], SubscriptionchecklistByIdArgs, MeshContext>,
  /**  (live) **/
  cityById: InContextSdkMethod<Subscription['cityById'], SubscriptioncityByIdArgs, MeshContext>,
  /**  (live) **/
  collectionById: InContextSdkMethod<Subscription['collectionById'], SubscriptioncollectionByIdArgs, MeshContext>,
  /**  (live) **/
  commentById: InContextSdkMethod<Subscription['commentById'], SubscriptioncommentByIdArgs, MeshContext>,
  /**  (live) **/
  contentTypeById: InContextSdkMethod<Subscription['contentTypeById'], SubscriptioncontentTypeByIdArgs, MeshContext>,
  /**  (live) **/
  contractById: InContextSdkMethod<Subscription['contractById'], SubscriptioncontractByIdArgs, MeshContext>,
  /**  (live) **/
  countryById: InContextSdkMethod<Subscription['countryById'], SubscriptioncountryByIdArgs, MeshContext>,
  /**  (live) **/
  couponById: InContextSdkMethod<Subscription['couponById'], SubscriptioncouponByIdArgs, MeshContext>,
  /**  (live) **/
  creditMemoByCreditMemoAndId: InContextSdkMethod<Subscription['creditMemoByCreditMemoAndId'], SubscriptioncreditMemoByCreditMemoAndIdArgs, MeshContext>,
  /**  (live) **/
  currencyById: InContextSdkMethod<Subscription['currencyById'], SubscriptioncurrencyByIdArgs, MeshContext>,
  /**  (live) **/
  currencyRateByImportService: InContextSdkMethod<Subscription['currencyRateByImportService'], SubscriptioncurrencyRateByImportServiceArgs, MeshContext>,
  /**  (live) **/
  currencySymbolBySymbol: InContextSdkMethod<Subscription['currencySymbolBySymbol'], SubscriptioncurrencySymbolBySymbolArgs, MeshContext>,
  /**  (live) **/
  customerGroupById: InContextSdkMethod<Subscription['customerGroupById'], SubscriptioncustomerGroupByIdArgs, MeshContext>,
  /**  (live) **/
  customerById: InContextSdkMethod<Subscription['customerById'], SubscriptioncustomerByIdArgs, MeshContext>,
  /**  (live) **/
  customizationById: InContextSdkMethod<Subscription['customizationById'], SubscriptioncustomizationByIdArgs, MeshContext>,
  /**  (live) **/
  dashboardById: InContextSdkMethod<Subscription['dashboardById'], SubscriptiondashboardByIdArgs, MeshContext>,
  /**  (live) **/
  deepdiveById: InContextSdkMethod<Subscription['deepdiveById'], SubscriptiondeepdiveByIdArgs, MeshContext>,
  /**  (live) **/
  digiboardById: InContextSdkMethod<Subscription['digiboardById'], SubscriptiondigiboardByIdArgs, MeshContext>,
  /**  (live) **/
  emailById: InContextSdkMethod<Subscription['emailById'], SubscriptionemailByIdArgs, MeshContext>,
  /**  (live) **/
  endofshiftById: InContextSdkMethod<Subscription['endofshiftById'], SubscriptionendofshiftByIdArgs, MeshContext>,
  /**  (live) **/
  eventById: InContextSdkMethod<Subscription['eventById'], SubscriptioneventByIdArgs, MeshContext>,
  /**  (live) **/
  fullfillmentById: InContextSdkMethod<Subscription['fullfillmentById'], SubscriptionfullfillmentByIdArgs, MeshContext>,
  /**  (live) **/
  giftCertificateById: InContextSdkMethod<Subscription['giftCertificateById'], SubscriptiongiftCertificateByIdArgs, MeshContext>,
  /**  (live) **/
  glossaryById: InContextSdkMethod<Subscription['glossaryById'], SubscriptionglossaryByIdArgs, MeshContext>,
  /**  (live) **/
  importmById: InContextSdkMethod<Subscription['importmById'], SubscriptionimportmByIdArgs, MeshContext>,
  /**  (live) **/
  integrationById: InContextSdkMethod<Subscription['integrationById'], SubscriptionintegrationByIdArgs, MeshContext>,
  /**  (live) **/
  internalizationById: InContextSdkMethod<Subscription['internalizationById'], SubscriptioninternalizationByIdArgs, MeshContext>,
  /**  (live) **/
  invitationById: InContextSdkMethod<Subscription['invitationById'], SubscriptioninvitationByIdArgs, MeshContext>,
  /**  (live) **/
  invoiceById: InContextSdkMethod<Subscription['invoiceById'], SubscriptioninvoiceByIdArgs, MeshContext>,
  /**  (live) **/
  leadById: InContextSdkMethod<Subscription['leadById'], SubscriptionleadByIdArgs, MeshContext>,
  /**  (live) **/
  manufacturerById: InContextSdkMethod<Subscription['manufacturerById'], SubscriptionmanufacturerByIdArgs, MeshContext>,
  /**  (live) **/
  mediamanagerById: InContextSdkMethod<Subscription['mediamanagerById'], SubscriptionmediamanagerByIdArgs, MeshContext>,
  /**  (live) **/
  meetingById: InContextSdkMethod<Subscription['meetingById'], SubscriptionmeetingByIdArgs, MeshContext>,
  /**  (live) **/
  messageById: InContextSdkMethod<Subscription['messageById'], SubscriptionmessageByIdArgs, MeshContext>,
  /**  (live) **/
  newsletterById: InContextSdkMethod<Subscription['newsletterById'], SubscriptionnewsletterByIdArgs, MeshContext>,
  /**  (live) **/
  ootoById: InContextSdkMethod<Subscription['ootoById'], SubscriptionootoByIdArgs, MeshContext>,
  /**  (live) **/
  opportunityById: InContextSdkMethod<Subscription['opportunityById'], SubscriptionopportunityByIdArgs, MeshContext>,
  /**  (live) **/
  orderById: InContextSdkMethod<Subscription['orderById'], SubscriptionorderByIdArgs, MeshContext>,
  /**  (live) **/
  pageById: InContextSdkMethod<Subscription['pageById'], SubscriptionpageByIdArgs, MeshContext>,
  /**  (live) **/
  partnerById: InContextSdkMethod<Subscription['partnerById'], SubscriptionpartnerByIdArgs, MeshContext>,
  /**  (live) **/
  paymentById: InContextSdkMethod<Subscription['paymentById'], SubscriptionpaymentByIdArgs, MeshContext>,
  /**  (live) **/
  permissionById: InContextSdkMethod<Subscription['permissionById'], SubscriptionpermissionByIdArgs, MeshContext>,
  /**  (live) **/
  pluginById: InContextSdkMethod<Subscription['pluginById'], SubscriptionpluginByIdArgs, MeshContext>,
  /**  (live) **/
  pollById: InContextSdkMethod<Subscription['pollById'], SubscriptionpollByIdArgs, MeshContext>,
  /**  (live) **/
  productTypeById: InContextSdkMethod<Subscription['productTypeById'], SubscriptionproductTypeByIdArgs, MeshContext>,
  /**  (live) **/
  productById: InContextSdkMethod<Subscription['productById'], SubscriptionproductByIdArgs, MeshContext>,
  /**  (live) **/
  projectById: InContextSdkMethod<Subscription['projectById'], SubscriptionprojectByIdArgs, MeshContext>,
  /**  (live) **/
  providerById: InContextSdkMethod<Subscription['providerById'], SubscriptionproviderByIdArgs, MeshContext>,
  /**  (live) **/
  quoteById: InContextSdkMethod<Subscription['quoteById'], SubscriptionquoteByIdArgs, MeshContext>,
  /**  (live) **/
  ratingById: InContextSdkMethod<Subscription['ratingById'], SubscriptionratingByIdArgs, MeshContext>,
  /**  (live) **/
  reportById: InContextSdkMethod<Subscription['reportById'], SubscriptionreportByIdArgs, MeshContext>,
  /**  (live) **/
  returnById: InContextSdkMethod<Subscription['returnById'], SubscriptionreturnByIdArgs, MeshContext>,
  /**  (live) **/
  reviewById: InContextSdkMethod<Subscription['reviewById'], SubscriptionreviewByIdArgs, MeshContext>,
  /**  (live) **/
  rewardById: InContextSdkMethod<Subscription['rewardById'], SubscriptionrewardByIdArgs, MeshContext>,
  /**  (live) **/
  roleById: InContextSdkMethod<Subscription['roleById'], SubscriptionroleByIdArgs, MeshContext>,
  /**  (live) **/
  schedulerById: InContextSdkMethod<Subscription['schedulerById'], SubscriptionschedulerByIdArgs, MeshContext>,
  /**  (live) **/
  segmentById: InContextSdkMethod<Subscription['segmentById'], SubscriptionsegmentByIdArgs, MeshContext>,
  /**  (live) **/
  settingById: InContextSdkMethod<Subscription['settingById'], SubscriptionsettingByIdArgs, MeshContext>,
  /**  (live) **/
  shipmentById: InContextSdkMethod<Subscription['shipmentById'], SubscriptionshipmentByIdArgs, MeshContext>,
  /**  (live) **/
  specialDiscountById: InContextSdkMethod<Subscription['specialDiscountById'], SubscriptionspecialDiscountByIdArgs, MeshContext>,
  /**  (live) **/
  stateById: InContextSdkMethod<Subscription['stateById'], SubscriptionstateByIdArgs, MeshContext>,
  /**  (live) **/
  statisticById: InContextSdkMethod<Subscription['statisticById'], SubscriptionstatisticByIdArgs, MeshContext>,
  /**  (live) **/
  stockById: InContextSdkMethod<Subscription['stockById'], SubscriptionstockByIdArgs, MeshContext>,
  /**  (live) **/
  surveyById: InContextSdkMethod<Subscription['surveyById'], SubscriptionsurveyByIdArgs, MeshContext>,
  /**  (live) **/
  tagById: InContextSdkMethod<Subscription['tagById'], SubscriptiontagByIdArgs, MeshContext>,
  /**  (live) **/
  targetById: InContextSdkMethod<Subscription['targetById'], SubscriptiontargetByIdArgs, MeshContext>,
  /**  (live) **/
  taxCategoryById: InContextSdkMethod<Subscription['taxCategoryById'], SubscriptiontaxCategoryByIdArgs, MeshContext>,
  /**  (live) **/
  taxRateById: InContextSdkMethod<Subscription['taxRateById'], SubscriptiontaxRateByIdArgs, MeshContext>,
  /**  (live) **/
  taxRuleById: InContextSdkMethod<Subscription['taxRuleById'], SubscriptiontaxRuleByIdArgs, MeshContext>,
  /**  (live) **/
  templateById: InContextSdkMethod<Subscription['templateById'], SubscriptiontemplateByIdArgs, MeshContext>,
  /**  (live) **/
  themeById: InContextSdkMethod<Subscription['themeById'], SubscriptionthemeByIdArgs, MeshContext>,
  /**  (live) **/
  ticketingById: InContextSdkMethod<Subscription['ticketingById'], SubscriptionticketingByIdArgs, MeshContext>,
  /**  (live) **/
  trainingById: InContextSdkMethod<Subscription['trainingById'], SubscriptiontrainingByIdArgs, MeshContext>,
  /**  (live) **/
  transactionById: InContextSdkMethod<Subscription['transactionById'], SubscriptiontransactionByIdArgs, MeshContext>,
  /**  (live) **/
  uploadFileById: InContextSdkMethod<Subscription['uploadFileById'], SubscriptionuploadFileByIdArgs, MeshContext>,
  /**  (live) **/
  userById: InContextSdkMethod<Subscription['userById'], SubscriptionuserByIdArgs, MeshContext>,
  /**  (live) **/
  vendorById: InContextSdkMethod<Subscription['vendorById'], SubscriptionvendorByIdArgs, MeshContext>,
  /**  (live) **/
  visitById: InContextSdkMethod<Subscription['visitById'], SubscriptionvisitByIdArgs, MeshContext>,
  /**  (live) **/
  warehouseById: InContextSdkMethod<Subscription['warehouseById'], SubscriptionwarehouseByIdArgs, MeshContext>,
  /**  (live) **/
  webhookById: InContextSdkMethod<Subscription['webhookById'], SubscriptionwebhookByIdArgs, MeshContext>,
  /**  (live) **/
  websiteById: InContextSdkMethod<Subscription['websiteById'], SubscriptionwebsiteByIdArgs, MeshContext>,
  /**  (live) **/
  wishlistById: InContextSdkMethod<Subscription['wishlistById'], SubscriptionwishlistByIdArgs, MeshContext>,
  /**  (live) **/
  workspaceById: InContextSdkMethod<Subscription['workspaceById'], SubscriptionworkspaceByIdArgs, MeshContext>,
  /**  (live) **/
  zoneById: InContextSdkMethod<Subscription['zoneById'], SubscriptionzoneByIdArgs, MeshContext>,
  /** Reads a single `Account` using its globally unique `ID`. (live) **/
  account: InContextSdkMethod<Subscription['account'], SubscriptionaccountArgs, MeshContext>,
  /** Reads a single `Agreement` using its globally unique `ID`. (live) **/
  agreement: InContextSdkMethod<Subscription['agreement'], SubscriptionagreementArgs, MeshContext>,
  /** Reads a single `Analytic` using its globally unique `ID`. (live) **/
  analytic: InContextSdkMethod<Subscription['analytic'], SubscriptionanalyticArgs, MeshContext>,
  /** Reads a single `Apitoken` using its globally unique `ID`. (live) **/
  apitoken: InContextSdkMethod<Subscription['apitoken'], SubscriptionapitokenArgs, MeshContext>,
  /** Reads a single `Article` using its globally unique `ID`. (live) **/
  article: InContextSdkMethod<Subscription['article'], SubscriptionarticleArgs, MeshContext>,
  /** Reads a single `Attribute` using its globally unique `ID`. (live) **/
  attribute: InContextSdkMethod<Subscription['attribute'], SubscriptionattributeArgs, MeshContext>,
  /** Reads a single `Brand` using its globally unique `ID`. (live) **/
  brand: InContextSdkMethod<Subscription['brand'], SubscriptionbrandArgs, MeshContext>,
  /** Reads a single `CartPriceRule` using its globally unique `ID`. (live) **/
  cartPriceRule: InContextSdkMethod<Subscription['cartPriceRule'], SubscriptioncartPriceRuleArgs, MeshContext>,
  /** Reads a single `Case` using its globally unique `ID`. (live) **/
  case: InContextSdkMethod<Subscription['case'], SubscriptioncaseArgs, MeshContext>,
  /** Reads a single `CatalogPriceRule` using its globally unique `ID`. (live) **/
  catalogPriceRule: InContextSdkMethod<Subscription['catalogPriceRule'], SubscriptioncatalogPriceRuleArgs, MeshContext>,
  /** Reads a single `Category` using its globally unique `ID`. (live) **/
  category: InContextSdkMethod<Subscription['category'], SubscriptioncategoryArgs, MeshContext>,
  /** Reads a single `Channel` using its globally unique `ID`. (live) **/
  channel: InContextSdkMethod<Subscription['channel'], SubscriptionchannelArgs, MeshContext>,
  /** Reads a single `Checklist` using its globally unique `ID`. (live) **/
  checklist: InContextSdkMethod<Subscription['checklist'], SubscriptionchecklistArgs, MeshContext>,
  /** Reads a single `City` using its globally unique `ID`. (live) **/
  city: InContextSdkMethod<Subscription['city'], SubscriptioncityArgs, MeshContext>,
  /** Reads a single `Collection` using its globally unique `ID`. (live) **/
  collection: InContextSdkMethod<Subscription['collection'], SubscriptioncollectionArgs, MeshContext>,
  /** Reads a single `Comment` using its globally unique `ID`. (live) **/
  comment: InContextSdkMethod<Subscription['comment'], SubscriptioncommentArgs, MeshContext>,
  /** Reads a single `ContentType` using its globally unique `ID`. (live) **/
  contentType: InContextSdkMethod<Subscription['contentType'], SubscriptioncontentTypeArgs, MeshContext>,
  /** Reads a single `Contract` using its globally unique `ID`. (live) **/
  contract: InContextSdkMethod<Subscription['contract'], SubscriptioncontractArgs, MeshContext>,
  /** Reads a single `Country` using its globally unique `ID`. (live) **/
  country: InContextSdkMethod<Subscription['country'], SubscriptioncountryArgs, MeshContext>,
  /** Reads a single `Coupon` using its globally unique `ID`. (live) **/
  coupon: InContextSdkMethod<Subscription['coupon'], SubscriptioncouponArgs, MeshContext>,
  /** Reads a single `CreditMemo` using its globally unique `ID`. (live) **/
  creditMemo: InContextSdkMethod<Subscription['creditMemo'], SubscriptioncreditMemoArgs, MeshContext>,
  /** Reads a single `Currency` using its globally unique `ID`. (live) **/
  currency: InContextSdkMethod<Subscription['currency'], SubscriptioncurrencyArgs, MeshContext>,
  /** Reads a single `CurrencyRate` using its globally unique `ID`. (live) **/
  currencyRate: InContextSdkMethod<Subscription['currencyRate'], SubscriptioncurrencyRateArgs, MeshContext>,
  /** Reads a single `CurrencySymbol` using its globally unique `ID`. (live) **/
  currencySymbol: InContextSdkMethod<Subscription['currencySymbol'], SubscriptioncurrencySymbolArgs, MeshContext>,
  /** Reads a single `CustomerGroup` using its globally unique `ID`. (live) **/
  customerGroup: InContextSdkMethod<Subscription['customerGroup'], SubscriptioncustomerGroupArgs, MeshContext>,
  /** Reads a single `Customer` using its globally unique `ID`. (live) **/
  customer: InContextSdkMethod<Subscription['customer'], SubscriptioncustomerArgs, MeshContext>,
  /** Reads a single `Customization` using its globally unique `ID`. (live) **/
  customization: InContextSdkMethod<Subscription['customization'], SubscriptioncustomizationArgs, MeshContext>,
  /** Reads a single `Dashboard` using its globally unique `ID`. (live) **/
  dashboard: InContextSdkMethod<Subscription['dashboard'], SubscriptiondashboardArgs, MeshContext>,
  /** Reads a single `Deepdive` using its globally unique `ID`. (live) **/
  deepdive: InContextSdkMethod<Subscription['deepdive'], SubscriptiondeepdiveArgs, MeshContext>,
  /** Reads a single `Digiboard` using its globally unique `ID`. (live) **/
  digiboard: InContextSdkMethod<Subscription['digiboard'], SubscriptiondigiboardArgs, MeshContext>,
  /** Reads a single `Email` using its globally unique `ID`. (live) **/
  email: InContextSdkMethod<Subscription['email'], SubscriptionemailArgs, MeshContext>,
  /** Reads a single `Endofshift` using its globally unique `ID`. (live) **/
  endofshift: InContextSdkMethod<Subscription['endofshift'], SubscriptionendofshiftArgs, MeshContext>,
  /** Reads a single `Event` using its globally unique `ID`. (live) **/
  event: InContextSdkMethod<Subscription['event'], SubscriptioneventArgs, MeshContext>,
  /** Reads a single `Fullfillment` using its globally unique `ID`. (live) **/
  fullfillment: InContextSdkMethod<Subscription['fullfillment'], SubscriptionfullfillmentArgs, MeshContext>,
  /** Reads a single `GiftCertificate` using its globally unique `ID`. (live) **/
  giftCertificate: InContextSdkMethod<Subscription['giftCertificate'], SubscriptiongiftCertificateArgs, MeshContext>,
  /** Reads a single `Glossary` using its globally unique `ID`. (live) **/
  glossary: InContextSdkMethod<Subscription['glossary'], SubscriptionglossaryArgs, MeshContext>,
  /** Reads a single `Importm` using its globally unique `ID`. (live) **/
  importm: InContextSdkMethod<Subscription['importm'], SubscriptionimportmArgs, MeshContext>,
  /** Reads a single `Integration` using its globally unique `ID`. (live) **/
  integration: InContextSdkMethod<Subscription['integration'], SubscriptionintegrationArgs, MeshContext>,
  /** Reads a single `Internalization` using its globally unique `ID`. (live) **/
  internalization: InContextSdkMethod<Subscription['internalization'], SubscriptioninternalizationArgs, MeshContext>,
  /** Reads a single `Invitation` using its globally unique `ID`. (live) **/
  invitation: InContextSdkMethod<Subscription['invitation'], SubscriptioninvitationArgs, MeshContext>,
  /** Reads a single `Invoice` using its globally unique `ID`. (live) **/
  invoice: InContextSdkMethod<Subscription['invoice'], SubscriptioninvoiceArgs, MeshContext>,
  /** Reads a single `Lead` using its globally unique `ID`. (live) **/
  lead: InContextSdkMethod<Subscription['lead'], SubscriptionleadArgs, MeshContext>,
  /** Reads a single `Manufacturer` using its globally unique `ID`. (live) **/
  manufacturer: InContextSdkMethod<Subscription['manufacturer'], SubscriptionmanufacturerArgs, MeshContext>,
  /** Reads a single `Mediamanager` using its globally unique `ID`. (live) **/
  mediamanager: InContextSdkMethod<Subscription['mediamanager'], SubscriptionmediamanagerArgs, MeshContext>,
  /** Reads a single `Meeting` using its globally unique `ID`. (live) **/
  meeting: InContextSdkMethod<Subscription['meeting'], SubscriptionmeetingArgs, MeshContext>,
  /** Reads a single `Message` using its globally unique `ID`. (live) **/
  message: InContextSdkMethod<Subscription['message'], SubscriptionmessageArgs, MeshContext>,
  /** Reads a single `Newsletter` using its globally unique `ID`. (live) **/
  newsletter: InContextSdkMethod<Subscription['newsletter'], SubscriptionnewsletterArgs, MeshContext>,
  /** Reads a single `Ooto` using its globally unique `ID`. (live) **/
  ooto: InContextSdkMethod<Subscription['ooto'], SubscriptionootoArgs, MeshContext>,
  /** Reads a single `Opportunity` using its globally unique `ID`. (live) **/
  opportunity: InContextSdkMethod<Subscription['opportunity'], SubscriptionopportunityArgs, MeshContext>,
  /** Reads a single `Order` using its globally unique `ID`. (live) **/
  order: InContextSdkMethod<Subscription['order'], SubscriptionorderArgs, MeshContext>,
  /** Reads a single `Page` using its globally unique `ID`. (live) **/
  page: InContextSdkMethod<Subscription['page'], SubscriptionpageArgs, MeshContext>,
  /** Reads a single `Partner` using its globally unique `ID`. (live) **/
  partner: InContextSdkMethod<Subscription['partner'], SubscriptionpartnerArgs, MeshContext>,
  /** Reads a single `Payment` using its globally unique `ID`. (live) **/
  payment: InContextSdkMethod<Subscription['payment'], SubscriptionpaymentArgs, MeshContext>,
  /** Reads a single `Permission` using its globally unique `ID`. (live) **/
  permission: InContextSdkMethod<Subscription['permission'], SubscriptionpermissionArgs, MeshContext>,
  /** Reads a single `Plugin` using its globally unique `ID`. (live) **/
  plugin: InContextSdkMethod<Subscription['plugin'], SubscriptionpluginArgs, MeshContext>,
  /** Reads a single `Poll` using its globally unique `ID`. (live) **/
  poll: InContextSdkMethod<Subscription['poll'], SubscriptionpollArgs, MeshContext>,
  /** Reads a single `ProductType` using its globally unique `ID`. (live) **/
  productType: InContextSdkMethod<Subscription['productType'], SubscriptionproductTypeArgs, MeshContext>,
  /** Reads a single `Product` using its globally unique `ID`. (live) **/
  product: InContextSdkMethod<Subscription['product'], SubscriptionproductArgs, MeshContext>,
  /** Reads a single `Project` using its globally unique `ID`. (live) **/
  project: InContextSdkMethod<Subscription['project'], SubscriptionprojectArgs, MeshContext>,
  /** Reads a single `Provider` using its globally unique `ID`. (live) **/
  provider: InContextSdkMethod<Subscription['provider'], SubscriptionproviderArgs, MeshContext>,
  /** Reads a single `Quote` using its globally unique `ID`. (live) **/
  quote: InContextSdkMethod<Subscription['quote'], SubscriptionquoteArgs, MeshContext>,
  /** Reads a single `Rating` using its globally unique `ID`. (live) **/
  rating: InContextSdkMethod<Subscription['rating'], SubscriptionratingArgs, MeshContext>,
  /** Reads a single `Report` using its globally unique `ID`. (live) **/
  report: InContextSdkMethod<Subscription['report'], SubscriptionreportArgs, MeshContext>,
  /** Reads a single `Return` using its globally unique `ID`. (live) **/
  return: InContextSdkMethod<Subscription['return'], SubscriptionreturnArgs, MeshContext>,
  /** Reads a single `Review` using its globally unique `ID`. (live) **/
  review: InContextSdkMethod<Subscription['review'], SubscriptionreviewArgs, MeshContext>,
  /** Reads a single `Reward` using its globally unique `ID`. (live) **/
  reward: InContextSdkMethod<Subscription['reward'], SubscriptionrewardArgs, MeshContext>,
  /** Reads a single `Role` using its globally unique `ID`. (live) **/
  role: InContextSdkMethod<Subscription['role'], SubscriptionroleArgs, MeshContext>,
  /** Reads a single `Scheduler` using its globally unique `ID`. (live) **/
  scheduler: InContextSdkMethod<Subscription['scheduler'], SubscriptionschedulerArgs, MeshContext>,
  /** Reads a single `Segment` using its globally unique `ID`. (live) **/
  segment: InContextSdkMethod<Subscription['segment'], SubscriptionsegmentArgs, MeshContext>,
  /** Reads a single `Setting` using its globally unique `ID`. (live) **/
  setting: InContextSdkMethod<Subscription['setting'], SubscriptionsettingArgs, MeshContext>,
  /** Reads a single `Shipment` using its globally unique `ID`. (live) **/
  shipment: InContextSdkMethod<Subscription['shipment'], SubscriptionshipmentArgs, MeshContext>,
  /** Reads a single `SpecialDiscount` using its globally unique `ID`. (live) **/
  specialDiscount: InContextSdkMethod<Subscription['specialDiscount'], SubscriptionspecialDiscountArgs, MeshContext>,
  /** Reads a single `State` using its globally unique `ID`. (live) **/
  state: InContextSdkMethod<Subscription['state'], SubscriptionstateArgs, MeshContext>,
  /** Reads a single `Statistic` using its globally unique `ID`. (live) **/
  statistic: InContextSdkMethod<Subscription['statistic'], SubscriptionstatisticArgs, MeshContext>,
  /** Reads a single `Stock` using its globally unique `ID`. (live) **/
  stock: InContextSdkMethod<Subscription['stock'], SubscriptionstockArgs, MeshContext>,
  /** Reads a single `Survey` using its globally unique `ID`. (live) **/
  survey: InContextSdkMethod<Subscription['survey'], SubscriptionsurveyArgs, MeshContext>,
  /** Reads a single `Tag` using its globally unique `ID`. (live) **/
  tag: InContextSdkMethod<Subscription['tag'], SubscriptiontagArgs, MeshContext>,
  /** Reads a single `Target` using its globally unique `ID`. (live) **/
  target: InContextSdkMethod<Subscription['target'], SubscriptiontargetArgs, MeshContext>,
  /** Reads a single `TaxCategory` using its globally unique `ID`. (live) **/
  taxCategory: InContextSdkMethod<Subscription['taxCategory'], SubscriptiontaxCategoryArgs, MeshContext>,
  /** Reads a single `TaxRate` using its globally unique `ID`. (live) **/
  taxRate: InContextSdkMethod<Subscription['taxRate'], SubscriptiontaxRateArgs, MeshContext>,
  /** Reads a single `TaxRule` using its globally unique `ID`. (live) **/
  taxRule: InContextSdkMethod<Subscription['taxRule'], SubscriptiontaxRuleArgs, MeshContext>,
  /** Reads a single `Template` using its globally unique `ID`. (live) **/
  template: InContextSdkMethod<Subscription['template'], SubscriptiontemplateArgs, MeshContext>,
  /** Reads a single `Theme` using its globally unique `ID`. (live) **/
  theme: InContextSdkMethod<Subscription['theme'], SubscriptionthemeArgs, MeshContext>,
  /** Reads a single `Ticketing` using its globally unique `ID`. (live) **/
  ticketing: InContextSdkMethod<Subscription['ticketing'], SubscriptionticketingArgs, MeshContext>,
  /** Reads a single `Training` using its globally unique `ID`. (live) **/
  training: InContextSdkMethod<Subscription['training'], SubscriptiontrainingArgs, MeshContext>,
  /** Reads a single `Transaction` using its globally unique `ID`. (live) **/
  transaction: InContextSdkMethod<Subscription['transaction'], SubscriptiontransactionArgs, MeshContext>,
  /** Reads a single `UploadFile` using its globally unique `ID`. (live) **/
  uploadFile: InContextSdkMethod<Subscription['uploadFile'], SubscriptionuploadFileArgs, MeshContext>,
  /** Reads a single `User` using its globally unique `ID`. (live) **/
  user: InContextSdkMethod<Subscription['user'], SubscriptionuserArgs, MeshContext>,
  /** Reads a single `Vendor` using its globally unique `ID`. (live) **/
  vendor: InContextSdkMethod<Subscription['vendor'], SubscriptionvendorArgs, MeshContext>,
  /** Reads a single `Visit` using its globally unique `ID`. (live) **/
  visit: InContextSdkMethod<Subscription['visit'], SubscriptionvisitArgs, MeshContext>,
  /** Reads a single `Warehouse` using its globally unique `ID`. (live) **/
  warehouse: InContextSdkMethod<Subscription['warehouse'], SubscriptionwarehouseArgs, MeshContext>,
  /** Reads a single `Webhook` using its globally unique `ID`. (live) **/
  webhook: InContextSdkMethod<Subscription['webhook'], SubscriptionwebhookArgs, MeshContext>,
  /** Reads a single `Website` using its globally unique `ID`. (live) **/
  website: InContextSdkMethod<Subscription['website'], SubscriptionwebsiteArgs, MeshContext>,
  /** Reads a single `Wishlist` using its globally unique `ID`. (live) **/
  wishlist: InContextSdkMethod<Subscription['wishlist'], SubscriptionwishlistArgs, MeshContext>,
  /** Reads a single `Workspace` using its globally unique `ID`. (live) **/
  workspace: InContextSdkMethod<Subscription['workspace'], SubscriptionworkspaceArgs, MeshContext>,
  /** Reads a single `Zone` using its globally unique `ID`. (live) **/
  zone: InContextSdkMethod<Subscription['zone'], SubscriptionzoneArgs, MeshContext>
  };

  export type Context = {
      ["MainDB"]: { Query: QuerySdk, Mutation: MutationSdk, Subscription: SubscriptionSdk },
      
    };
}
